/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-client)/./node_modules/chess.js/chess.js":
/*!****************************************!*\
  !*** ./node_modules/chess.js/chess.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_RESULT__;/*\n * Copyright (c) 2021, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n *----------------------------------------------------------------------------*/\n\nvar Chess = function (fen) {\n  var BLACK = 'b'\n  var WHITE = 'w'\n\n  var EMPTY = -1\n\n  var PAWN = 'p'\n  var KNIGHT = 'n'\n  var BISHOP = 'b'\n  var ROOK = 'r'\n  var QUEEN = 'q'\n  var KING = 'k'\n\n  var SYMBOLS = 'pnbrqkPNBRQK'\n\n  var DEFAULT_POSITION =\n    'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n\n  var POSSIBLE_RESULTS = ['1-0', '0-1', '1/2-1/2', '*']\n\n  var PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n  }\n\n  var PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n  }\n\n  // prettier-ignore\n  var ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\n     0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n     0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n     0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n     0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\n     0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n     0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n     0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n     0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\n  ];\n\n  // prettier-ignore\n  var RAYS = [\n     17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\n      0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\n      0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\n      0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\n      0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\n      1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\n      0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\n      0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\n      0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\n      0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\n    -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\n  ];\n\n  var SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 }\n\n  var FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n  }\n\n  var BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n  }\n\n  var RANK_1 = 7\n  var RANK_2 = 6\n  var RANK_3 = 5\n  var RANK_4 = 4\n  var RANK_5 = 3\n  var RANK_6 = 2\n  var RANK_7 = 1\n  var RANK_8 = 0\n\n  // prettier-ignore\n  var SQUARES = {\n    a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\n    a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\n    a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\n    a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\n    a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\n    a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\n    a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n  };\n\n  var ROOKS = {\n    w: [\n      { square: SQUARES.a1, flag: BITS.QSIDE_CASTLE },\n      { square: SQUARES.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n      { square: SQUARES.a8, flag: BITS.QSIDE_CASTLE },\n      { square: SQUARES.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n  }\n\n  var board = new Array(128)\n  var kings = { w: EMPTY, b: EMPTY }\n  var turn = WHITE\n  var castling = { w: 0, b: 0 }\n  var ep_square = EMPTY\n  var half_moves = 0\n  var move_number = 1\n  var history = []\n  var header = {}\n  var comments = {}\n\n  /* if the user passes in a fen string, load it, else default to\n   * starting position\n   */\n  if (typeof fen === 'undefined') {\n    load(DEFAULT_POSITION)\n  } else {\n    load(fen)\n  }\n\n  function clear(keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false\n    }\n\n    board = new Array(128)\n    kings = { w: EMPTY, b: EMPTY }\n    turn = WHITE\n    castling = { w: 0, b: 0 }\n    ep_square = EMPTY\n    half_moves = 0\n    move_number = 1\n    history = []\n    if (!keep_headers) header = {}\n    comments = {}\n    update_setup(generate_fen())\n  }\n\n  function prune_comments() {\n    var reversed_history = []\n    var current_comments = {}\n    var copy_comment = function (fen) {\n      if (fen in comments) {\n        current_comments[fen] = comments[fen]\n      }\n    }\n    while (history.length > 0) {\n      reversed_history.push(undo_move())\n    }\n    copy_comment(generate_fen())\n    while (reversed_history.length > 0) {\n      make_move(reversed_history.pop())\n      copy_comment(generate_fen())\n    }\n    comments = current_comments\n  }\n\n  function reset() {\n    load(DEFAULT_POSITION)\n  }\n\n  function load(fen, keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false\n    }\n\n    var tokens = fen.split(/\\s+/)\n    var position = tokens[0]\n    var square = 0\n\n    if (!validate_fen(fen).valid) {\n      return false\n    }\n\n    clear(keep_headers)\n\n    for (var i = 0; i < position.length; i++) {\n      var piece = position.charAt(i)\n\n      if (piece === '/') {\n        square += 8\n      } else if (is_digit(piece)) {\n        square += parseInt(piece, 10)\n      } else {\n        var color = piece < 'a' ? WHITE : BLACK\n        put({ type: piece.toLowerCase(), color: color }, algebraic(square))\n        square++\n      }\n    }\n\n    turn = tokens[1]\n\n    if (tokens[2].indexOf('K') > -1) {\n      castling.w |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      castling.w |= BITS.QSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      castling.b |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      castling.b |= BITS.QSIDE_CASTLE\n    }\n\n    ep_square = tokens[3] === '-' ? EMPTY : SQUARES[tokens[3]]\n    half_moves = parseInt(tokens[4], 10)\n    move_number = parseInt(tokens[5], 10)\n\n    update_setup(generate_fen())\n\n    return true\n  }\n\n  /* TODO: this function is pretty much crap - it validates structure but\n   * completely ignores content (e.g. doesn't verify that each side has a king)\n   * ... we should rewrite this, and ditch the silly error_number field while\n   * we're at it\n   */\n  function validate_fen(fen) {\n    var errors = {\n      0: 'No errors.',\n      1: 'FEN string must contain six space-delimited fields.',\n      2: '6th field (move number) must be a positive integer.',\n      3: '5th field (half move counter) must be a non-negative integer.',\n      4: '4th field (en-passant square) is invalid.',\n      5: '3rd field (castling availability) is invalid.',\n      6: '2nd field (side to move) is invalid.',\n      7: \"1st field (piece positions) does not contain 8 '/'-delimited rows.\",\n      8: '1st field (piece positions) is invalid [consecutive numbers].',\n      9: '1st field (piece positions) is invalid [invalid piece].',\n      10: '1st field (piece positions) is invalid [row too large].',\n      11: 'Illegal en-passant square',\n    }\n\n    /* 1st criterion: 6 space-seperated fields? */\n    var tokens = fen.split(/\\s+/)\n    if (tokens.length !== 6) {\n      return { valid: false, error_number: 1, error: errors[1] }\n    }\n\n    /* 2nd criterion: move number field is a integer value > 0? */\n    if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) {\n      return { valid: false, error_number: 2, error: errors[2] }\n    }\n\n    /* 3rd criterion: half move counter is an integer >= 0? */\n    if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) {\n      return { valid: false, error_number: 3, error: errors[3] }\n    }\n\n    /* 4th criterion: 4th field is a valid e.p.-string? */\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n      return { valid: false, error_number: 4, error: errors[4] }\n    }\n\n    /* 5th criterion: 3th field is a valid castle-string? */\n    if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n      return { valid: false, error_number: 5, error: errors[5] }\n    }\n\n    /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n    if (!/^(w|b)$/.test(tokens[1])) {\n      return { valid: false, error_number: 6, error: errors[6] }\n    }\n\n    /* 7th criterion: 1st field contains 8 rows? */\n    var rows = tokens[0].split('/')\n    if (rows.length !== 8) {\n      return { valid: false, error_number: 7, error: errors[7] }\n    }\n\n    /* 8th criterion: every row is valid? */\n    for (var i = 0; i < rows.length; i++) {\n      /* check for right sum of fields AND not two numbers in succession */\n      var sum_fields = 0\n      var previous_was_number = false\n\n      for (var k = 0; k < rows[i].length; k++) {\n        if (!isNaN(rows[i][k])) {\n          if (previous_was_number) {\n            return { valid: false, error_number: 8, error: errors[8] }\n          }\n          sum_fields += parseInt(rows[i][k], 10)\n          previous_was_number = true\n        } else {\n          if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n            return { valid: false, error_number: 9, error: errors[9] }\n          }\n          sum_fields += 1\n          previous_was_number = false\n        }\n      }\n      if (sum_fields !== 8) {\n        return { valid: false, error_number: 10, error: errors[10] }\n      }\n    }\n\n    if (\n      (tokens[3][1] == '3' && tokens[1] == 'w') ||\n      (tokens[3][1] == '6' && tokens[1] == 'b')\n    ) {\n      return { valid: false, error_number: 11, error: errors[11] }\n    }\n\n    /* everything's okay! */\n    return { valid: true, error_number: 0, error: errors[0] }\n  }\n\n  function generate_fen() {\n    var empty = 0\n    var fen = ''\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      if (board[i] == null) {\n        empty++\n      } else {\n        if (empty > 0) {\n          fen += empty\n          empty = 0\n        }\n        var color = board[i].color\n        var piece = board[i].type\n\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n      }\n\n      if ((i + 1) & 0x88) {\n        if (empty > 0) {\n          fen += empty\n        }\n\n        if (i !== SQUARES.h1) {\n          fen += '/'\n        }\n\n        empty = 0\n        i += 8\n      }\n    }\n\n    var cflags = ''\n    if (castling[WHITE] & BITS.KSIDE_CASTLE) {\n      cflags += 'K'\n    }\n    if (castling[WHITE] & BITS.QSIDE_CASTLE) {\n      cflags += 'Q'\n    }\n    if (castling[BLACK] & BITS.KSIDE_CASTLE) {\n      cflags += 'k'\n    }\n    if (castling[BLACK] & BITS.QSIDE_CASTLE) {\n      cflags += 'q'\n    }\n\n    /* do we have an empty castling flag? */\n    cflags = cflags || '-'\n    var epflags = ep_square === EMPTY ? '-' : algebraic(ep_square)\n\n    return [fen, turn, cflags, epflags, half_moves, move_number].join(' ')\n  }\n\n  function set_header(args) {\n    for (var i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        header[args[i]] = args[i + 1]\n      }\n    }\n    return header\n  }\n\n  /* called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object.  if the FEN is\n   * equal to the default position, the SetUp and FEN are deleted\n   * the setup is only updated if history.length is zero, ie moves haven't been\n   * made.\n   */\n  function update_setup(fen) {\n    if (history.length > 0) return\n\n    if (fen !== DEFAULT_POSITION) {\n      header['SetUp'] = '1'\n      header['FEN'] = fen\n    } else {\n      delete header['SetUp']\n      delete header['FEN']\n    }\n  }\n\n  function get(square) {\n    var piece = board[SQUARES[square]]\n    return piece ? { type: piece.type, color: piece.color } : null\n  }\n\n  function put(piece, square) {\n    /* check for valid piece object */\n    if (!('type' in piece && 'color' in piece)) {\n      return false\n    }\n\n    /* check for piece */\n    if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\n      return false\n    }\n\n    /* check for valid square */\n    if (!(square in SQUARES)) {\n      return false\n    }\n\n    var sq = SQUARES[square]\n\n    /* don't let the user place more than one king */\n    if (\n      piece.type == KING &&\n      !(kings[piece.color] == EMPTY || kings[piece.color] == sq)\n    ) {\n      return false\n    }\n\n    board[sq] = { type: piece.type, color: piece.color }\n    if (piece.type === KING) {\n      kings[piece.color] = sq\n    }\n\n    update_setup(generate_fen())\n\n    return true\n  }\n\n  function remove(square) {\n    var piece = get(square)\n    board[SQUARES[square]] = null\n    if (piece && piece.type === KING) {\n      kings[piece.color] = EMPTY\n    }\n\n    update_setup(generate_fen())\n\n    return piece\n  }\n\n  function build_move(board, from, to, flags, promotion) {\n    var move = {\n      color: turn,\n      from: from,\n      to: to,\n      flags: flags,\n      piece: board[from].type,\n    }\n\n    if (promotion) {\n      move.flags |= BITS.PROMOTION\n      move.promotion = promotion\n    }\n\n    if (board[to]) {\n      move.captured = board[to].type\n    } else if (flags & BITS.EP_CAPTURE) {\n      move.captured = PAWN\n    }\n    return move\n  }\n\n  function generate_moves(options) {\n    function add_move(board, moves, from, to, flags) {\n      /* if pawn promotion */\n      if (\n        board[from].type === PAWN &&\n        (rank(to) === RANK_8 || rank(to) === RANK_1)\n      ) {\n        var pieces = [QUEEN, ROOK, BISHOP, KNIGHT]\n        for (var i = 0, len = pieces.length; i < len; i++) {\n          moves.push(build_move(board, from, to, flags, pieces[i]))\n        }\n      } else {\n        moves.push(build_move(board, from, to, flags))\n      }\n    }\n\n    var moves = []\n    var us = turn\n    var them = swap_color(us)\n    var second_rank = { b: RANK_7, w: RANK_2 }\n\n    var first_sq = SQUARES.a8\n    var last_sq = SQUARES.h1\n    var single_square = false\n\n    /* do we want legal moves? */\n    var legal =\n      typeof options !== 'undefined' && 'legal' in options\n        ? options.legal\n        : true\n\n    var piece_type =\n      typeof options !== 'undefined' &&\n      'piece' in options &&\n      typeof options.piece === 'string'\n        ? options.piece.toLowerCase()\n        : true\n\n    /* are we generating moves for a single square? */\n    if (typeof options !== 'undefined' && 'square' in options) {\n      if (options.square in SQUARES) {\n        first_sq = last_sq = SQUARES[options.square]\n        single_square = true\n      } else {\n        /* invalid square */\n        return []\n      }\n    }\n\n    for (var i = first_sq; i <= last_sq; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      var piece = board[i]\n      if (piece == null || piece.color !== us) {\n        continue\n      }\n\n      if (piece.type === PAWN && (piece_type === true || piece_type === PAWN)) {\n        /* single square, non-capturing */\n        var square = i + PAWN_OFFSETS[us][0]\n        if (board[square] == null) {\n          add_move(board, moves, i, square, BITS.NORMAL)\n\n          /* double square */\n          var square = i + PAWN_OFFSETS[us][1]\n          if (second_rank[us] === rank(i) && board[square] == null) {\n            add_move(board, moves, i, square, BITS.BIG_PAWN)\n          }\n        }\n\n        /* pawn captures */\n        for (j = 2; j < 4; j++) {\n          var square = i + PAWN_OFFSETS[us][j]\n          if (square & 0x88) continue\n\n          if (board[square] != null && board[square].color === them) {\n            add_move(board, moves, i, square, BITS.CAPTURE)\n          } else if (square === ep_square) {\n            add_move(board, moves, i, ep_square, BITS.EP_CAPTURE)\n          }\n        }\n      } else if (piece_type === true || piece_type === piece.type) {\n        for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {\n          var offset = PIECE_OFFSETS[piece.type][j]\n          var square = i\n\n          while (true) {\n            square += offset\n            if (square & 0x88) break\n\n            if (board[square] == null) {\n              add_move(board, moves, i, square, BITS.NORMAL)\n            } else {\n              if (board[square].color === us) break\n              add_move(board, moves, i, square, BITS.CAPTURE)\n              break\n            }\n\n            /* break, if knight or king */\n            if (piece.type === 'n' || piece.type === 'k') break\n          }\n        }\n      }\n    }\n\n    /* check for castling if: a) we're generating all moves, or b) we're doing\n     * single square move generation on the king's square\n     */\n    if (piece_type === true || piece_type === KING) {\n      if (!single_square || last_sq === kings[us]) {\n        /* king-side castling */\n        if (castling[us] & BITS.KSIDE_CASTLE) {\n          var castling_from = kings[us]\n          var castling_to = castling_from + 2\n\n          if (\n            board[castling_from + 1] == null &&\n            board[castling_to] == null &&\n            !attacked(them, kings[us]) &&\n            !attacked(them, castling_from + 1) &&\n            !attacked(them, castling_to)\n          ) {\n            add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE)\n          }\n        }\n\n        /* queen-side castling */\n        if (castling[us] & BITS.QSIDE_CASTLE) {\n          var castling_from = kings[us]\n          var castling_to = castling_from - 2\n\n          if (\n            board[castling_from - 1] == null &&\n            board[castling_from - 2] == null &&\n            board[castling_from - 3] == null &&\n            !attacked(them, kings[us]) &&\n            !attacked(them, castling_from - 1) &&\n            !attacked(them, castling_to)\n          ) {\n            add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE)\n          }\n        }\n      }\n    }\n\n    /* return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal) {\n      return moves\n    }\n\n    /* filter out illegal moves */\n    var legal_moves = []\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i])\n      if (!king_attacked(us)) {\n        legal_moves.push(moves[i])\n      }\n      undo_move()\n    }\n\n    return legal_moves\n  }\n\n  /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} sloppy Use the sloppy SAN generator to work around over\n   * disambiguation bugs in Fritz and Chessbase.  See below:\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n  function move_to_san(move, moves) {\n    var output = ''\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O'\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O'\n    } else {\n      if (move.piece !== PAWN) {\n        var disambiguator = get_disambiguator(move, moves)\n        output += move.piece.toUpperCase() + disambiguator\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0]\n        }\n        output += 'x'\n      }\n\n      output += algebraic(move.to)\n\n      if (move.flags & BITS.PROMOTION) {\n        output += '=' + move.promotion.toUpperCase()\n      }\n    }\n\n    make_move(move)\n    if (in_check()) {\n      if (in_checkmate()) {\n        output += '#'\n      } else {\n        output += '+'\n      }\n    }\n    undo_move()\n\n    return output\n  }\n  // parses all of the decorators out of a SAN string\n  function stripped_san(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\n  }\n\n  function attacked(color, square) {\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      /* if empty square or wrong color */\n      if (board[i] == null || board[i].color !== color) continue\n\n      var piece = board[i]\n      var difference = i - square\n      var index = difference + 119\n\n      if (ATTACKS[index] & (1 << SHIFTS[piece.type])) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true\n          } else {\n            if (piece.color === BLACK) return true\n          }\n          continue\n        }\n\n        /* if the piece is a knight or a king */\n        if (piece.type === 'n' || piece.type === 'k') return true\n\n        var offset = RAYS[index]\n        var j = i + offset\n\n        var blocked = false\n        while (j !== square) {\n          if (board[j] != null) {\n            blocked = true\n            break\n          }\n          j += offset\n        }\n\n        if (!blocked) return true\n      }\n    }\n\n    return false\n  }\n\n  function king_attacked(color) {\n    return attacked(swap_color(color), kings[color])\n  }\n\n  function in_check() {\n    return king_attacked(turn)\n  }\n\n  function in_checkmate() {\n    return in_check() && generate_moves().length === 0\n  }\n\n  function in_stalemate() {\n    return !in_check() && generate_moves().length === 0\n  }\n\n  function insufficient_material() {\n    var pieces = {}\n    var bishops = []\n    var num_pieces = 0\n    var sq_color = 0\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      sq_color = (sq_color + 1) % 2\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      var piece = board[i]\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\n        if (piece.type === BISHOP) {\n          bishops.push(sq_color)\n        }\n        num_pieces++\n      }\n    }\n\n    /* k vs. k */\n    if (num_pieces === 2) {\n      return true\n    } else if (\n      /* k vs. kn .... or .... k vs. kb */\n      num_pieces === 3 &&\n      (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\n    ) {\n      return true\n    } else if (num_pieces === pieces[BISHOP] + 2) {\n      /* kb vs. kb where any number of bishops are all on the same color */\n      var sum = 0\n      var len = bishops.length\n      for (var i = 0; i < len; i++) {\n        sum += bishops[i]\n      }\n      if (sum === 0 || sum === len) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  function in_threefold_repetition() {\n    /* TODO: while this function is fine for casual use, a better\n     * implementation would use a Zobrist key (instead of FEN). the\n     * Zobrist key would be maintained in the make_move/undo_move functions,\n     * avoiding the costly that we do below.\n     */\n    var moves = []\n    var positions = {}\n    var repetition = false\n\n    while (true) {\n      var move = undo_move()\n      if (!move) break\n      moves.push(move)\n    }\n\n    while (true) {\n      /* remove the last two fields in the FEN string, they're not needed\n       * when checking for draw by rep */\n      var fen = generate_fen().split(' ').slice(0, 4).join(' ')\n\n      /* has the position occurred three or move times */\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1\n      if (positions[fen] >= 3) {\n        repetition = true\n      }\n\n      if (!moves.length) {\n        break\n      }\n      make_move(moves.pop())\n    }\n\n    return repetition\n  }\n\n  function push(move) {\n    history.push({\n      move: move,\n      kings: { b: kings.b, w: kings.w },\n      turn: turn,\n      castling: { b: castling.b, w: castling.w },\n      ep_square: ep_square,\n      half_moves: half_moves,\n      move_number: move_number,\n    })\n  }\n\n  function make_move(move) {\n    var us = turn\n    var them = swap_color(us)\n    push(move)\n\n    board[move.to] = board[move.from]\n    board[move.from] = null\n\n    /* if ep capture, remove the captured pawn */\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (turn === BLACK) {\n        board[move.to - 16] = null\n      } else {\n        board[move.to + 16] = null\n      }\n    }\n\n    /* if pawn promotion, replace with new piece */\n    if (move.flags & BITS.PROMOTION) {\n      board[move.to] = { type: move.promotion, color: us }\n    }\n\n    /* if we moved the king */\n    if (board[move.to].type === KING) {\n      kings[board[move.to].color] = move.to\n\n      /* if we castled, move the rook next to the king */\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        var castling_to = move.to - 1\n        var castling_from = move.to + 1\n        board[castling_to] = board[castling_from]\n        board[castling_from] = null\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        var castling_to = move.to + 1\n        var castling_from = move.to - 2\n        board[castling_to] = board[castling_from]\n        board[castling_from] = null\n      }\n\n      /* turn off castling */\n      castling[us] = ''\n    }\n\n    /* turn off castling if we move a rook */\n    if (castling[us]) {\n      for (var i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (\n          move.from === ROOKS[us][i].square &&\n          castling[us] & ROOKS[us][i].flag\n        ) {\n          castling[us] ^= ROOKS[us][i].flag\n          break\n        }\n      }\n    }\n\n    /* turn off castling if we capture a rook */\n    if (castling[them]) {\n      for (var i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (\n          move.to === ROOKS[them][i].square &&\n          castling[them] & ROOKS[them][i].flag\n        ) {\n          castling[them] ^= ROOKS[them][i].flag\n          break\n        }\n      }\n    }\n\n    /* if big pawn move, update the en passant square */\n    if (move.flags & BITS.BIG_PAWN) {\n      if (turn === 'b') {\n        ep_square = move.to - 16\n      } else {\n        ep_square = move.to + 16\n      }\n    } else {\n      ep_square = EMPTY\n    }\n\n    /* reset the 50 move counter if a pawn is moved or a piece is captured */\n    if (move.piece === PAWN) {\n      half_moves = 0\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      half_moves = 0\n    } else {\n      half_moves++\n    }\n\n    if (turn === BLACK) {\n      move_number++\n    }\n    turn = swap_color(turn)\n  }\n\n  function undo_move() {\n    var old = history.pop()\n    if (old == null) {\n      return null\n    }\n\n    var move = old.move\n    kings = old.kings\n    turn = old.turn\n    castling = old.castling\n    ep_square = old.ep_square\n    half_moves = old.half_moves\n    move_number = old.move_number\n\n    var us = turn\n    var them = swap_color(turn)\n\n    board[move.from] = board[move.to]\n    board[move.from].type = move.piece // to undo any promotions\n    board[move.to] = null\n\n    if (move.flags & BITS.CAPTURE) {\n      board[move.to] = { type: move.captured, color: them }\n    } else if (move.flags & BITS.EP_CAPTURE) {\n      var index\n      if (us === BLACK) {\n        index = move.to - 16\n      } else {\n        index = move.to + 16\n      }\n      board[index] = { type: PAWN, color: them }\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      var castling_to, castling_from\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castling_to = move.to + 1\n        castling_from = move.to - 1\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        castling_to = move.to - 2\n        castling_from = move.to + 1\n      }\n\n      board[castling_to] = board[castling_from]\n      board[castling_from] = null\n    }\n\n    return move\n  }\n\n  /* this function is used to uniquely identify ambiguous moves */\n  function get_disambiguator(move, moves) {\n    var from = move.from\n    var to = move.to\n    var piece = move.piece\n\n    var ambiguities = 0\n    var same_rank = 0\n    var same_file = 0\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      var ambig_from = moves[i].from\n      var ambig_to = moves[i].to\n      var ambig_piece = moves[i].piece\n\n      /* if a move of the same piece type ends on the same to square, we'll\n       * need to add a disambiguator to the algebraic notation\n       */\n      if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\n        ambiguities++\n\n        if (rank(from) === rank(ambig_from)) {\n          same_rank++\n        }\n\n        if (file(from) === file(ambig_from)) {\n          same_file++\n        }\n      }\n    }\n\n    if (ambiguities > 0) {\n      /* if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      if (same_rank > 0 && same_file > 0) {\n        return algebraic(from)\n      } else if (same_file > 0) {\n        /* if the moving piece rests on the same file, use the rank symbol as the\n         * disambiguator\n         */\n        return algebraic(from).charAt(1)\n      } else {\n        /* else use the file symbol */\n        return algebraic(from).charAt(0)\n      }\n    }\n\n    return ''\n  }\n\n  function infer_piece_type(san) {\n    var piece_type = san.charAt(0)\n    if (piece_type >= 'a' && piece_type <= 'h') {\n      var matches = san.match(/[a-h]\\d.*[a-h]\\d/)\n      if (matches) {\n        return undefined\n      }\n      return PAWN\n    }\n    piece_type = piece_type.toLowerCase()\n    if (piece_type === 'o') {\n      return KING\n    }\n    return piece_type\n  }\n  function ascii() {\n    var s = '   +------------------------+\\n'\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* display the rank */\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |'\n      }\n\n      /* empty piece */\n      if (board[i] == null) {\n        s += ' . '\n      } else {\n        var piece = board[i].type\n        var color = board[i].color\n        var symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n        s += ' ' + symbol + ' '\n      }\n\n      if ((i + 1) & 0x88) {\n        s += '|\\n'\n        i += 8\n      }\n    }\n    s += '   +------------------------+\\n'\n    s += '     a  b  c  d  e  f  g  h\\n'\n\n    return s\n  }\n\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  function move_from_san(move, sloppy) {\n    // strip off any move decorations: e.g Nf3+?!\n    var clean_move = stripped_san(move)\n\n    // if we're using the sloppy parser run a regex to grab piece, to, and from\n    // this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7\n    if (sloppy) {\n      var matches = clean_move.match(\n        /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n      )\n      if (matches) {\n        var piece = matches[1]\n        var from = matches[2]\n        var to = matches[3]\n        var promotion = matches[4]\n      }\n    }\n    var piece_type = infer_piece_type(clean_move)\n    var moves = null\n    var legalMoves = generate_moves({\n      legal: true,\n      piece: piece ? piece : piece_type,\n    })\n    moves = legalMoves\n    if (sloppy) {\n      var illegalMoves = generate_moves({\n        legal: false,\n        piece: piece ? piece : piece_type,\n      })\n      moves = illegalMoves\n    }\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      // try the strict parser first, then the sloppy parser if requested\n      // by the user\n      if (\n        clean_move === stripped_san(move_to_san(moves[i], legalMoves)) ||\n        (sloppy &&\n          clean_move === stripped_san(move_to_san(moves[i], illegalMoves)))\n      ) {\n        return moves[i]\n      } else {\n        if (\n          matches &&\n          (!piece || piece.toLowerCase() == moves[i].piece) &&\n          SQUARES[from] == moves[i].from &&\n          SQUARES[to] == moves[i].to &&\n          (!promotion || promotion.toLowerCase() == moves[i].promotion)\n        ) {\n          return moves[i]\n        }\n      }\n    }\n\n    return null\n  }\n\n  /*****************************************************************************\n   * UTILITY FUNCTIONS\n   ****************************************************************************/\n  function rank(i) {\n    return i >> 4\n  }\n\n  function file(i) {\n    return i & 15\n  }\n\n  function algebraic(i) {\n    var f = file(i),\n      r = rank(i)\n    return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1)\n  }\n\n  function swap_color(c) {\n    return c === WHITE ? BLACK : WHITE\n  }\n\n  function is_digit(c) {\n    return '0123456789'.indexOf(c) !== -1\n  }\n\n  /* pretty = external move object */\n  function make_pretty(ugly_move) {\n    var move = clone(ugly_move)\n    move.san = move_to_san(move, generate_moves({ legal: true }))\n    move.to = algebraic(move.to)\n    move.from = algebraic(move.from)\n\n    var flags = ''\n\n    for (var flag in BITS) {\n      if (BITS[flag] & move.flags) {\n        flags += FLAGS[flag]\n      }\n    }\n    move.flags = flags\n\n    return move\n  }\n\n  function clone(obj) {\n    var dupe = obj instanceof Array ? [] : {}\n\n    for (var property in obj) {\n      if (typeof property === 'object') {\n        dupe[property] = clone(obj[property])\n      } else {\n        dupe[property] = obj[property]\n      }\n    }\n\n    return dupe\n  }\n\n  function trim(str) {\n    return str.replace(/^\\s+|\\s+$/g, '')\n  }\n\n  /*****************************************************************************\n   * DEBUGGING UTILITIES\n   ****************************************************************************/\n  function perft(depth) {\n    var moves = generate_moves({ legal: false })\n    var nodes = 0\n    var color = turn\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i])\n      if (!king_attacked(color)) {\n        if (depth - 1 > 0) {\n          var child_nodes = perft(depth - 1)\n          nodes += child_nodes\n        } else {\n          nodes++\n        }\n      }\n      undo_move()\n    }\n\n    return nodes\n  }\n\n  return {\n    /***************************************************************************\n     * PUBLIC CONSTANTS (is there a better way to do this?)\n     **************************************************************************/\n    WHITE: WHITE,\n    BLACK: BLACK,\n    PAWN: PAWN,\n    KNIGHT: KNIGHT,\n    BISHOP: BISHOP,\n    ROOK: ROOK,\n    QUEEN: QUEEN,\n    KING: KING,\n    SQUARES: (function () {\n      /* from the ECMA-262 spec (section 12.6.4):\n       * \"The mechanics of enumerating the properties ... is\n       * implementation dependent\"\n       * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n       * ordered correctly\n       */\n      var keys = []\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (i & 0x88) {\n          i += 7\n          continue\n        }\n        keys.push(algebraic(i))\n      }\n      return keys\n    })(),\n    FLAGS: FLAGS,\n\n    /***************************************************************************\n     * PUBLIC API\n     **************************************************************************/\n    load: function (fen) {\n      return load(fen)\n    },\n\n    reset: function () {\n      return reset()\n    },\n\n    moves: function (options) {\n      /* The internal representation of a chess move is in 0x88 format, and\n       * not meant to be human-readable.  The code below converts the 0x88\n       * square coordinates to algebraic coordinates.  It also prunes an\n       * unnecessary move keys resulting from a verbose call.\n       */\n\n      var ugly_moves = generate_moves(options)\n      var moves = []\n\n      for (var i = 0, len = ugly_moves.length; i < len; i++) {\n        /* does the user want a full move object (most likely not), or just\n         * SAN\n         */\n        if (\n          typeof options !== 'undefined' &&\n          'verbose' in options &&\n          options.verbose\n        ) {\n          moves.push(make_pretty(ugly_moves[i]))\n        } else {\n          moves.push(\n            move_to_san(ugly_moves[i], generate_moves({ legal: true }))\n          )\n        }\n      }\n\n      return moves\n    },\n\n    in_check: function () {\n      return in_check()\n    },\n\n    in_checkmate: function () {\n      return in_checkmate()\n    },\n\n    in_stalemate: function () {\n      return in_stalemate()\n    },\n\n    in_draw: function () {\n      return (\n        half_moves >= 100 ||\n        in_stalemate() ||\n        insufficient_material() ||\n        in_threefold_repetition()\n      )\n    },\n\n    insufficient_material: function () {\n      return insufficient_material()\n    },\n\n    in_threefold_repetition: function () {\n      return in_threefold_repetition()\n    },\n\n    game_over: function () {\n      return (\n        half_moves >= 100 ||\n        in_checkmate() ||\n        in_stalemate() ||\n        insufficient_material() ||\n        in_threefold_repetition()\n      )\n    },\n\n    validate_fen: function (fen) {\n      return validate_fen(fen)\n    },\n\n    fen: function () {\n      return generate_fen()\n    },\n\n    board: function () {\n      var output = [],\n        row = []\n\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (board[i] == null) {\n          row.push(null)\n        } else {\n          row.push({ type: board[i].type, color: board[i].color })\n        }\n        if ((i + 1) & 0x88) {\n          output.push(row)\n          row = []\n          i += 8\n        }\n      }\n\n      return output\n    },\n\n    pgn: function (options) {\n      /* using the specification from http://www.chessclub.com/help/PGN-spec\n       * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n       */\n      var newline =\n        typeof options === 'object' && typeof options.newline_char === 'string'\n          ? options.newline_char\n          : '\\n'\n      var max_width =\n        typeof options === 'object' && typeof options.max_width === 'number'\n          ? options.max_width\n          : 0\n      var result = []\n      var header_exists = false\n\n      /* add the PGN header headerrmation */\n      for (var i in header) {\n        /* TODO: order of enumerated properties in header object is not\n         * guaranteed, see ECMA-262 spec (section 12.6.4)\n         */\n        result.push('[' + i + ' \"' + header[i] + '\"]' + newline)\n        header_exists = true\n      }\n\n      if (header_exists && history.length) {\n        result.push(newline)\n      }\n\n      var append_comment = function (move_string) {\n        var comment = comments[generate_fen()]\n        if (typeof comment !== 'undefined') {\n          var delimiter = move_string.length > 0 ? ' ' : ''\n          move_string = `${move_string}${delimiter}{${comment}}`\n        }\n        return move_string\n      }\n\n      /* pop all of history onto reversed_history */\n      var reversed_history = []\n      while (history.length > 0) {\n        reversed_history.push(undo_move())\n      }\n\n      var moves = []\n      var move_string = ''\n\n      /* special case of a commented starting position with no moves */\n      if (reversed_history.length === 0) {\n        moves.push(append_comment(''))\n      }\n\n      /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n      while (reversed_history.length > 0) {\n        move_string = append_comment(move_string)\n        var move = reversed_history.pop()\n\n        /* if the position started with black to move, start PGN with 1. ... */\n        if (!history.length && move.color === 'b') {\n          move_string = move_number + '. ...'\n        } else if (move.color === 'w') {\n          /* store the previous generated move_string if we have one */\n          if (move_string.length) {\n            moves.push(move_string)\n          }\n          move_string = move_number + '.'\n        }\n\n        move_string =\n          move_string +\n          ' ' +\n          move_to_san(move, generate_moves({ legal: false }))\n        make_move(move)\n      }\n\n      /* are there any other leftover moves? */\n      if (move_string.length) {\n        moves.push(append_comment(move_string))\n      }\n\n      /* is there a result? */\n      if (typeof header.Result !== 'undefined') {\n        moves.push(header.Result)\n      }\n\n      /* history should be back to what it was before we started generating PGN,\n       * so join together moves\n       */\n      if (max_width === 0) {\n        return result.join('') + moves.join(' ')\n      }\n\n      var strip = function () {\n        if (result.length > 0 && result[result.length - 1] === ' ') {\n          result.pop()\n          return true\n        }\n        return false\n      }\n\n      /* NB: this does not preserve comment whitespace. */\n      var wrap_comment = function (width, move) {\n        for (var token of move.split(' ')) {\n          if (!token) {\n            continue\n          }\n          if (width + token.length > max_width) {\n            while (strip()) {\n              width--\n            }\n            result.push(newline)\n            width = 0\n          }\n          result.push(token)\n          width += token.length\n          result.push(' ')\n          width++\n        }\n        if (strip()) {\n          width--\n        }\n        return width\n      }\n\n      /* wrap the PGN output at max_width */\n      var current_width = 0\n      for (var i = 0; i < moves.length; i++) {\n        if (current_width + moves[i].length > max_width) {\n          if (moves[i].includes('{')) {\n            current_width = wrap_comment(current_width, moves[i])\n            continue\n          }\n        }\n        /* if the current move will push past max_width */\n        if (current_width + moves[i].length > max_width && i !== 0) {\n          /* don't end the line with whitespace */\n          if (result[result.length - 1] === ' ') {\n            result.pop()\n          }\n\n          result.push(newline)\n          current_width = 0\n        } else if (i !== 0) {\n          result.push(' ')\n          current_width++\n        }\n        result.push(moves[i])\n        current_width += moves[i].length\n      }\n\n      return result.join('')\n    },\n\n    load_pgn: function (pgn, options) {\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy =\n        typeof options !== 'undefined' && 'sloppy' in options\n          ? options.sloppy\n          : false\n\n      function mask(str) {\n        return str.replace(/\\\\/g, '\\\\')\n      }\n\n      function has_keys(object) {\n        for (var key in object) {\n          return true\n        }\n        return false\n      }\n\n      function parse_pgn_header(header, options) {\n        var newline_char =\n          typeof options === 'object' &&\n          typeof options.newline_char === 'string'\n            ? options.newline_char\n            : '\\r?\\n'\n        var header_obj = {}\n        var headers = header.split(new RegExp(mask(newline_char)))\n        var key = ''\n        var value = ''\n\n        for (var i = 0; i < headers.length; i++) {\n          key = headers[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1')\n          value = headers[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\ *\\]$/, '$1')\n          if (trim(key).length > 0) {\n            header_obj[key] = value\n          }\n        }\n\n        return header_obj\n      }\n\n      var newline_char =\n        typeof options === 'object' && typeof options.newline_char === 'string'\n          ? options.newline_char\n          : '\\r?\\n'\n\n      // RegExp to split header. Takes advantage of the fact that header and movetext\n      // will always have a blank line between them (ie, two newline_char's).\n      // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\r?\\n){2}/\n      var header_regex = new RegExp(\n        '^(\\\\[((?:' +\n          mask(newline_char) +\n          ')|.)*\\\\])' +\n          '(?:' +\n          mask(newline_char) +\n          '){2}'\n      )\n\n      // If no header given, begin with moves.\n      var header_string = header_regex.test(pgn)\n        ? header_regex.exec(pgn)[1]\n        : ''\n\n      // Put the board in the starting position\n      reset()\n\n      /* parse PGN header */\n      var headers = parse_pgn_header(header_string, options)\n      for (var key in headers) {\n        set_header([key, headers[key]])\n      }\n\n      /* load the starting position indicated by [Setup '1'] and\n       * [FEN position] */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers && load(headers['FEN'], true))) {\n          // second argument to load: don't clear the headers\n          return false\n        }\n      }\n\n      /* NB: the regexes below that delete move numbers, recursive\n       * annotations, and numeric annotation glyphs may also match\n       * text in comments. To prevent this, we transform comments\n       * by hex-encoding them in place and decoding them again after\n       * the other tokens have been deleted.\n       *\n       * While the spec states that PGN files should be ASCII encoded,\n       * we use {en,de}codeURIComponent here to support arbitrary UTF8\n       * as a convenience for modern users */\n\n      var to_hex = function (string) {\n        return Array.from(string)\n          .map(function (c) {\n            /* encodeURI doesn't transform most ASCII characters,\n             * so we handle these ourselves */\n            return c.charCodeAt(0) < 128\n              ? c.charCodeAt(0).toString(16)\n              : encodeURIComponent(c).replace(/\\%/g, '').toLowerCase()\n          })\n          .join('')\n      }\n\n      var from_hex = function (string) {\n        return string.length == 0\n          ? ''\n          : decodeURIComponent('%' + string.match(/.{1,2}/g).join('%'))\n      }\n\n      var encode_comment = function (string) {\n        string = string.replace(new RegExp(mask(newline_char), 'g'), ' ')\n        return `{${to_hex(string.slice(1, string.length - 1))}}`\n      }\n\n      var decode_comment = function (string) {\n        if (string.startsWith('{') && string.endsWith('}')) {\n          return from_hex(string.slice(1, string.length - 1))\n        }\n      }\n\n      /* delete header to get the moves */\n      var ms = pgn\n        .replace(header_string, '')\n        .replace(\n          /* encode comments so they don't get deleted below */\n          new RegExp(`(\\{[^}]*\\})+?|;([^${mask(newline_char)}]*)`, 'g'),\n          function (match, bracket, semicolon) {\n            return bracket !== undefined\n              ? encode_comment(bracket)\n              : ' ' + encode_comment(`{${semicolon.slice(1)}}`)\n          }\n        )\n        .replace(new RegExp(mask(newline_char), 'g'), ' ')\n\n      /* delete recursive annotation variations */\n      var rav_regex = /(\\([^\\(\\)]+\\))+?/g\n      while (rav_regex.test(ms)) {\n        ms = ms.replace(rav_regex, '')\n      }\n\n      /* delete move numbers */\n      ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '')\n\n      /* delete ... indicating black to move */\n      ms = ms.replace(/\\.\\.\\./g, '')\n\n      /* delete numeric annotation glyphs */\n      ms = ms.replace(/\\$\\d+/g, '')\n\n      /* trim and get array of moves */\n      var moves = trim(ms).split(new RegExp(/\\s+/))\n\n      /* delete empty entries */\n      moves = moves.join(',').replace(/,,+/g, ',').split(',')\n      var move = ''\n\n      for (var half_move = 0; half_move < moves.length - 1; half_move++) {\n        var comment = decode_comment(moves[half_move])\n        if (comment !== undefined) {\n          comments[generate_fen()] = comment\n          continue\n        }\n        move = move_from_san(moves[half_move], sloppy)\n\n        /* move not possible! (don't clear the board to examine to show the\n         * latest valid position)\n         */\n        if (move == null) {\n          return false\n        } else {\n          make_move(move)\n        }\n      }\n\n      comment = decode_comment(moves[moves.length - 1])\n      if (comment !== undefined) {\n        comments[generate_fen()] = comment\n        moves.pop()\n      }\n\n      /* examine last move */\n      move = moves[moves.length - 1]\n      if (POSSIBLE_RESULTS.indexOf(move) > -1) {\n        if (has_keys(header) && typeof header.Result === 'undefined') {\n          set_header(['Result', move])\n        }\n      } else {\n        move = move_from_san(move, sloppy)\n        if (move == null) {\n          return false\n        } else {\n          make_move(move)\n        }\n      }\n      return true\n    },\n\n    header: function () {\n      return set_header(arguments)\n    },\n\n    ascii: function () {\n      return ascii()\n    },\n\n    turn: function () {\n      return turn\n    },\n\n    move: function (move, options) {\n      /* The move function can be called with in the following parameters:\n       *\n       * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n       *\n       * .move({ from: 'h7', <- where the 'move' is a move object (additional\n       *         to :'h8',      fields are ignored)\n       *         promotion: 'q',\n       *      })\n       */\n\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy =\n        typeof options !== 'undefined' && 'sloppy' in options\n          ? options.sloppy\n          : false\n\n      var move_obj = null\n\n      if (typeof move === 'string') {\n        move_obj = move_from_san(move, sloppy)\n      } else if (typeof move === 'object') {\n        var moves = generate_moves()\n\n        /* convert the pretty move object to an ugly move object */\n        for (var i = 0, len = moves.length; i < len; i++) {\n          if (\n            move.from === algebraic(moves[i].from) &&\n            move.to === algebraic(moves[i].to) &&\n            (!('promotion' in moves[i]) ||\n              move.promotion === moves[i].promotion)\n          ) {\n            move_obj = moves[i]\n            break\n          }\n        }\n      }\n\n      /* failed to find move */\n      if (!move_obj) {\n        return null\n      }\n\n      /* need to make a copy of move because we can't generate SAN after the\n       * move is made\n       */\n      var pretty_move = make_pretty(move_obj)\n\n      make_move(move_obj)\n\n      return pretty_move\n    },\n\n    undo: function () {\n      var move = undo_move()\n      return move ? make_pretty(move) : null\n    },\n\n    clear: function () {\n      return clear()\n    },\n\n    put: function (piece, square) {\n      return put(piece, square)\n    },\n\n    get: function (square) {\n      return get(square)\n    },\n\n    remove: function (square) {\n      return remove(square)\n    },\n\n    perft: function (depth) {\n      return perft(depth)\n    },\n\n    square_color: function (square) {\n      if (square in SQUARES) {\n        var sq_0x88 = SQUARES[square]\n        return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? 'light' : 'dark'\n      }\n\n      return null\n    },\n\n    history: function (options) {\n      var reversed_history = []\n      var move_history = []\n      var verbose =\n        typeof options !== 'undefined' &&\n        'verbose' in options &&\n        options.verbose\n\n      while (history.length > 0) {\n        reversed_history.push(undo_move())\n      }\n\n      while (reversed_history.length > 0) {\n        var move = reversed_history.pop()\n        if (verbose) {\n          move_history.push(make_pretty(move))\n        } else {\n          move_history.push(move_to_san(move, generate_moves({ legal: true })))\n        }\n        make_move(move)\n      }\n\n      return move_history\n    },\n\n    get_comment: function () {\n      return comments[generate_fen()]\n    },\n\n    set_comment: function (comment) {\n      comments[generate_fen()] = comment.replace('{', '[').replace('}', ']')\n    },\n\n    delete_comment: function () {\n      var comment = comments[generate_fen()]\n      delete comments[generate_fen()]\n      return comment\n    },\n\n    get_comments: function () {\n      prune_comments()\n      return Object.keys(comments).map(function (fen) {\n        return { fen: fen, comment: comments[fen] }\n      })\n    },\n\n    delete_comments: function () {\n      prune_comments()\n      return Object.keys(comments).map(function (fen) {\n        var comment = comments[fen]\n        delete comments[fen]\n        return { fen: fen, comment: comment }\n      })\n    },\n  }\n}\n\n/* export Chess object if using node or any other CommonJS compatible\n * environment */\nif (true) exports.Chess = Chess\n/* export Chess object for any RequireJS compatible environment */\nif (true)\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return Chess\n  }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL2NoZXNzLmpzL2NoZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtCQUErQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSw2Q0FBNkM7QUFDckQsUUFBUSw2Q0FBNkM7QUFDckQ7QUFDQTtBQUNBLFFBQVEsNkNBQTZDO0FBQ3JELFFBQVEsNkNBQTZDO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0Esa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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QUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsK0RBQStELGFBQWE7QUFDNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLG1EQUFtRCxrQkFBa0I7QUFDckUsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLElBQThCLEVBQUUsYUFBYTtBQUNqRDtBQUNBLElBQUksSUFBNkI7QUFDakMsRUFBRSxtQ0FBTztBQUNUO0FBQ0EsR0FBRztBQUFBLGtHQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jaGVzcy5qcy9jaGVzcy5qcz85MTNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEsIEplZmYgSGx5d2EgKGpobHl3YUBnbWFpbC5jb20pXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG52YXIgQ2hlc3MgPSBmdW5jdGlvbiAoZmVuKSB7XG4gIHZhciBCTEFDSyA9ICdiJ1xuICB2YXIgV0hJVEUgPSAndydcblxuICB2YXIgRU1QVFkgPSAtMVxuXG4gIHZhciBQQVdOID0gJ3AnXG4gIHZhciBLTklHSFQgPSAnbidcbiAgdmFyIEJJU0hPUCA9ICdiJ1xuICB2YXIgUk9PSyA9ICdyJ1xuICB2YXIgUVVFRU4gPSAncSdcbiAgdmFyIEtJTkcgPSAnaydcblxuICB2YXIgU1lNQk9MUyA9ICdwbmJycWtQTkJSUUsnXG5cbiAgdmFyIERFRkFVTFRfUE9TSVRJT04gPVxuICAgICdybmJxa2Juci9wcHBwcHBwcC84LzgvOC84L1BQUFBQUFBQL1JOQlFLQk5SIHcgS1FrcSAtIDAgMSdcblxuICB2YXIgUE9TU0lCTEVfUkVTVUxUUyA9IFsnMS0wJywgJzAtMScsICcxLzItMS8yJywgJyonXVxuXG4gIHZhciBQQVdOX09GRlNFVFMgPSB7XG4gICAgYjogWzE2LCAzMiwgMTcsIDE1XSxcbiAgICB3OiBbLTE2LCAtMzIsIC0xNywgLTE1XSxcbiAgfVxuXG4gIHZhciBQSUVDRV9PRkZTRVRTID0ge1xuICAgIG46IFstMTgsIC0zMywgLTMxLCAtMTQsIDE4LCAzMywgMzEsIDE0XSxcbiAgICBiOiBbLTE3LCAtMTUsIDE3LCAxNV0sXG4gICAgcjogWy0xNiwgMSwgMTYsIC0xXSxcbiAgICBxOiBbLTE3LCAtMTYsIC0xNSwgMSwgMTcsIDE2LCAxNSwgLTFdLFxuICAgIGs6IFstMTcsIC0xNiwgLTE1LCAxLCAxNywgMTYsIDE1LCAtMV0sXG4gIH1cblxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgdmFyIEFUVEFDS1MgPSBbXG4gICAgMjAsIDAsIDAsIDAsIDAsIDAsIDAsIDI0LCAgMCwgMCwgMCwgMCwgMCwgMCwyMCwgMCxcbiAgICAgMCwyMCwgMCwgMCwgMCwgMCwgMCwgMjQsICAwLCAwLCAwLCAwLCAwLDIwLCAwLCAwLFxuICAgICAwLCAwLDIwLCAwLCAwLCAwLCAwLCAyNCwgIDAsIDAsIDAsIDAsMjAsIDAsIDAsIDAsXG4gICAgIDAsIDAsIDAsMjAsIDAsIDAsIDAsIDI0LCAgMCwgMCwgMCwyMCwgMCwgMCwgMCwgMCxcbiAgICAgMCwgMCwgMCwgMCwyMCwgMCwgMCwgMjQsICAwLCAwLDIwLCAwLCAwLCAwLCAwLCAwLFxuICAgICAwLCAwLCAwLCAwLCAwLDIwLCAyLCAyNCwgIDIsMjAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgIDAsIDAsIDAsIDAsIDAsIDIsNTMsIDU2LCA1MywgMiwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAyNCwyNCwyNCwyNCwyNCwyNCw1NiwgIDAsIDU2LDI0LDI0LDI0LDI0LDI0LDI0LCAwLFxuICAgICAwLCAwLCAwLCAwLCAwLCAyLDUzLCA1NiwgNTMsIDIsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgIDAsIDAsIDAsIDAsIDAsMjAsIDIsIDI0LCAgMiwyMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAgMCwgMCwgMCwgMCwyMCwgMCwgMCwgMjQsICAwLCAwLDIwLCAwLCAwLCAwLCAwLCAwLFxuICAgICAwLCAwLCAwLDIwLCAwLCAwLCAwLCAyNCwgIDAsIDAsIDAsMjAsIDAsIDAsIDAsIDAsXG4gICAgIDAsIDAsMjAsIDAsIDAsIDAsIDAsIDI0LCAgMCwgMCwgMCwgMCwyMCwgMCwgMCwgMCxcbiAgICAgMCwyMCwgMCwgMCwgMCwgMCwgMCwgMjQsICAwLCAwLCAwLCAwLCAwLDIwLCAwLCAwLFxuICAgIDIwLCAwLCAwLCAwLCAwLCAwLCAwLCAyNCwgIDAsIDAsIDAsIDAsIDAsIDAsMjBcbiAgXTtcblxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgdmFyIFJBWVMgPSBbXG4gICAgIDE3LCAgMCwgIDAsICAwLCAgMCwgIDAsICAwLCAxNiwgIDAsICAwLCAgMCwgIDAsICAwLCAgMCwgMTUsIDAsXG4gICAgICAwLCAxNywgIDAsICAwLCAgMCwgIDAsICAwLCAxNiwgIDAsICAwLCAgMCwgIDAsICAwLCAxNSwgIDAsIDAsXG4gICAgICAwLCAgMCwgMTcsICAwLCAgMCwgIDAsICAwLCAxNiwgIDAsICAwLCAgMCwgIDAsIDE1LCAgMCwgIDAsIDAsXG4gICAgICAwLCAgMCwgIDAsIDE3LCAgMCwgIDAsICAwLCAxNiwgIDAsICAwLCAgMCwgMTUsICAwLCAgMCwgIDAsIDAsXG4gICAgICAwLCAgMCwgIDAsICAwLCAxNywgIDAsICAwLCAxNiwgIDAsICAwLCAxNSwgIDAsICAwLCAgMCwgIDAsIDAsXG4gICAgICAwLCAgMCwgIDAsICAwLCAgMCwgMTcsICAwLCAxNiwgIDAsIDE1LCAgMCwgIDAsICAwLCAgMCwgIDAsIDAsXG4gICAgICAwLCAgMCwgIDAsICAwLCAgMCwgIDAsIDE3LCAxNiwgMTUsICAwLCAgMCwgIDAsICAwLCAgMCwgIDAsIDAsXG4gICAgICAxLCAgMSwgIDEsICAxLCAgMSwgIDEsICAxLCAgMCwgLTEsIC0xLCAgLTEsLTEsIC0xLCAtMSwgLTEsIDAsXG4gICAgICAwLCAgMCwgIDAsICAwLCAgMCwgIDAsLTE1LC0xNiwtMTcsICAwLCAgMCwgIDAsICAwLCAgMCwgIDAsIDAsXG4gICAgICAwLCAgMCwgIDAsICAwLCAgMCwtMTUsICAwLC0xNiwgIDAsLTE3LCAgMCwgIDAsICAwLCAgMCwgIDAsIDAsXG4gICAgICAwLCAgMCwgIDAsICAwLC0xNSwgIDAsICAwLC0xNiwgIDAsICAwLC0xNywgIDAsICAwLCAgMCwgIDAsIDAsXG4gICAgICAwLCAgMCwgIDAsLTE1LCAgMCwgIDAsICAwLC0xNiwgIDAsICAwLCAgMCwtMTcsICAwLCAgMCwgIDAsIDAsXG4gICAgICAwLCAgMCwtMTUsICAwLCAgMCwgIDAsICAwLC0xNiwgIDAsICAwLCAgMCwgIDAsLTE3LCAgMCwgIDAsIDAsXG4gICAgICAwLC0xNSwgIDAsICAwLCAgMCwgIDAsICAwLC0xNiwgIDAsICAwLCAgMCwgIDAsICAwLC0xNywgIDAsIDAsXG4gICAgLTE1LCAgMCwgIDAsICAwLCAgMCwgIDAsICAwLC0xNiwgIDAsICAwLCAgMCwgIDAsICAwLCAgMCwtMTdcbiAgXTtcblxuICB2YXIgU0hJRlRTID0geyBwOiAwLCBuOiAxLCBiOiAyLCByOiAzLCBxOiA0LCBrOiA1IH1cblxuICB2YXIgRkxBR1MgPSB7XG4gICAgTk9STUFMOiAnbicsXG4gICAgQ0FQVFVSRTogJ2MnLFxuICAgIEJJR19QQVdOOiAnYicsXG4gICAgRVBfQ0FQVFVSRTogJ2UnLFxuICAgIFBST01PVElPTjogJ3AnLFxuICAgIEtTSURFX0NBU1RMRTogJ2snLFxuICAgIFFTSURFX0NBU1RMRTogJ3EnLFxuICB9XG5cbiAgdmFyIEJJVFMgPSB7XG4gICAgTk9STUFMOiAxLFxuICAgIENBUFRVUkU6IDIsXG4gICAgQklHX1BBV046IDQsXG4gICAgRVBfQ0FQVFVSRTogOCxcbiAgICBQUk9NT1RJT046IDE2LFxuICAgIEtTSURFX0NBU1RMRTogMzIsXG4gICAgUVNJREVfQ0FTVExFOiA2NCxcbiAgfVxuXG4gIHZhciBSQU5LXzEgPSA3XG4gIHZhciBSQU5LXzIgPSA2XG4gIHZhciBSQU5LXzMgPSA1XG4gIHZhciBSQU5LXzQgPSA0XG4gIHZhciBSQU5LXzUgPSAzXG4gIHZhciBSQU5LXzYgPSAyXG4gIHZhciBSQU5LXzcgPSAxXG4gIHZhciBSQU5LXzggPSAwXG5cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHZhciBTUVVBUkVTID0ge1xuICAgIGE4OiAgIDAsIGI4OiAgIDEsIGM4OiAgIDIsIGQ4OiAgIDMsIGU4OiAgIDQsIGY4OiAgIDUsIGc4OiAgIDYsIGg4OiAgIDcsXG4gICAgYTc6ICAxNiwgYjc6ICAxNywgYzc6ICAxOCwgZDc6ICAxOSwgZTc6ICAyMCwgZjc6ICAyMSwgZzc6ICAyMiwgaDc6ICAyMyxcbiAgICBhNjogIDMyLCBiNjogIDMzLCBjNjogIDM0LCBkNjogIDM1LCBlNjogIDM2LCBmNjogIDM3LCBnNjogIDM4LCBoNjogIDM5LFxuICAgIGE1OiAgNDgsIGI1OiAgNDksIGM1OiAgNTAsIGQ1OiAgNTEsIGU1OiAgNTIsIGY1OiAgNTMsIGc1OiAgNTQsIGg1OiAgNTUsXG4gICAgYTQ6ICA2NCwgYjQ6ICA2NSwgYzQ6ICA2NiwgZDQ6ICA2NywgZTQ6ICA2OCwgZjQ6ICA2OSwgZzQ6ICA3MCwgaDQ6ICA3MSxcbiAgICBhMzogIDgwLCBiMzogIDgxLCBjMzogIDgyLCBkMzogIDgzLCBlMzogIDg0LCBmMzogIDg1LCBnMzogIDg2LCBoMzogIDg3LFxuICAgIGEyOiAgOTYsIGIyOiAgOTcsIGMyOiAgOTgsIGQyOiAgOTksIGUyOiAxMDAsIGYyOiAxMDEsIGcyOiAxMDIsIGgyOiAxMDMsXG4gICAgYTE6IDExMiwgYjE6IDExMywgYzE6IDExNCwgZDE6IDExNSwgZTE6IDExNiwgZjE6IDExNywgZzE6IDExOCwgaDE6IDExOVxuICB9O1xuXG4gIHZhciBST09LUyA9IHtcbiAgICB3OiBbXG4gICAgICB7IHNxdWFyZTogU1FVQVJFUy5hMSwgZmxhZzogQklUUy5RU0lERV9DQVNUTEUgfSxcbiAgICAgIHsgc3F1YXJlOiBTUVVBUkVTLmgxLCBmbGFnOiBCSVRTLktTSURFX0NBU1RMRSB9LFxuICAgIF0sXG4gICAgYjogW1xuICAgICAgeyBzcXVhcmU6IFNRVUFSRVMuYTgsIGZsYWc6IEJJVFMuUVNJREVfQ0FTVExFIH0sXG4gICAgICB7IHNxdWFyZTogU1FVQVJFUy5oOCwgZmxhZzogQklUUy5LU0lERV9DQVNUTEUgfSxcbiAgICBdLFxuICB9XG5cbiAgdmFyIGJvYXJkID0gbmV3IEFycmF5KDEyOClcbiAgdmFyIGtpbmdzID0geyB3OiBFTVBUWSwgYjogRU1QVFkgfVxuICB2YXIgdHVybiA9IFdISVRFXG4gIHZhciBjYXN0bGluZyA9IHsgdzogMCwgYjogMCB9XG4gIHZhciBlcF9zcXVhcmUgPSBFTVBUWVxuICB2YXIgaGFsZl9tb3ZlcyA9IDBcbiAgdmFyIG1vdmVfbnVtYmVyID0gMVxuICB2YXIgaGlzdG9yeSA9IFtdXG4gIHZhciBoZWFkZXIgPSB7fVxuICB2YXIgY29tbWVudHMgPSB7fVxuXG4gIC8qIGlmIHRoZSB1c2VyIHBhc3NlcyBpbiBhIGZlbiBzdHJpbmcsIGxvYWQgaXQsIGVsc2UgZGVmYXVsdCB0b1xuICAgKiBzdGFydGluZyBwb3NpdGlvblxuICAgKi9cbiAgaWYgKHR5cGVvZiBmZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9hZChERUZBVUxUX1BPU0lUSU9OKVxuICB9IGVsc2Uge1xuICAgIGxvYWQoZmVuKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXIoa2VlcF9oZWFkZXJzKSB7XG4gICAgaWYgKHR5cGVvZiBrZWVwX2hlYWRlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBrZWVwX2hlYWRlcnMgPSBmYWxzZVxuICAgIH1cblxuICAgIGJvYXJkID0gbmV3IEFycmF5KDEyOClcbiAgICBraW5ncyA9IHsgdzogRU1QVFksIGI6IEVNUFRZIH1cbiAgICB0dXJuID0gV0hJVEVcbiAgICBjYXN0bGluZyA9IHsgdzogMCwgYjogMCB9XG4gICAgZXBfc3F1YXJlID0gRU1QVFlcbiAgICBoYWxmX21vdmVzID0gMFxuICAgIG1vdmVfbnVtYmVyID0gMVxuICAgIGhpc3RvcnkgPSBbXVxuICAgIGlmICgha2VlcF9oZWFkZXJzKSBoZWFkZXIgPSB7fVxuICAgIGNvbW1lbnRzID0ge31cbiAgICB1cGRhdGVfc2V0dXAoZ2VuZXJhdGVfZmVuKCkpXG4gIH1cblxuICBmdW5jdGlvbiBwcnVuZV9jb21tZW50cygpIHtcbiAgICB2YXIgcmV2ZXJzZWRfaGlzdG9yeSA9IFtdXG4gICAgdmFyIGN1cnJlbnRfY29tbWVudHMgPSB7fVxuICAgIHZhciBjb3B5X2NvbW1lbnQgPSBmdW5jdGlvbiAoZmVuKSB7XG4gICAgICBpZiAoZmVuIGluIGNvbW1lbnRzKSB7XG4gICAgICAgIGN1cnJlbnRfY29tbWVudHNbZmVuXSA9IGNvbW1lbnRzW2Zlbl1cbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGhpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgcmV2ZXJzZWRfaGlzdG9yeS5wdXNoKHVuZG9fbW92ZSgpKVxuICAgIH1cbiAgICBjb3B5X2NvbW1lbnQoZ2VuZXJhdGVfZmVuKCkpXG4gICAgd2hpbGUgKHJldmVyc2VkX2hpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgbWFrZV9tb3ZlKHJldmVyc2VkX2hpc3RvcnkucG9wKCkpXG4gICAgICBjb3B5X2NvbW1lbnQoZ2VuZXJhdGVfZmVuKCkpXG4gICAgfVxuICAgIGNvbW1lbnRzID0gY3VycmVudF9jb21tZW50c1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgbG9hZChERUZBVUxUX1BPU0lUSU9OKVxuICB9XG5cbiAgZnVuY3Rpb24gbG9hZChmZW4sIGtlZXBfaGVhZGVycykge1xuICAgIGlmICh0eXBlb2Yga2VlcF9oZWFkZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgICAga2VlcF9oZWFkZXJzID0gZmFsc2VcbiAgICB9XG5cbiAgICB2YXIgdG9rZW5zID0gZmVuLnNwbGl0KC9cXHMrLylcbiAgICB2YXIgcG9zaXRpb24gPSB0b2tlbnNbMF1cbiAgICB2YXIgc3F1YXJlID0gMFxuXG4gICAgaWYgKCF2YWxpZGF0ZV9mZW4oZmVuKS52YWxpZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY2xlYXIoa2VlcF9oZWFkZXJzKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBpZWNlID0gcG9zaXRpb24uY2hhckF0KGkpXG5cbiAgICAgIGlmIChwaWVjZSA9PT0gJy8nKSB7XG4gICAgICAgIHNxdWFyZSArPSA4XG4gICAgICB9IGVsc2UgaWYgKGlzX2RpZ2l0KHBpZWNlKSkge1xuICAgICAgICBzcXVhcmUgKz0gcGFyc2VJbnQocGllY2UsIDEwKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbG9yID0gcGllY2UgPCAnYScgPyBXSElURSA6IEJMQUNLXG4gICAgICAgIHB1dCh7IHR5cGU6IHBpZWNlLnRvTG93ZXJDYXNlKCksIGNvbG9yOiBjb2xvciB9LCBhbGdlYnJhaWMoc3F1YXJlKSlcbiAgICAgICAgc3F1YXJlKytcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0dXJuID0gdG9rZW5zWzFdXG5cbiAgICBpZiAodG9rZW5zWzJdLmluZGV4T2YoJ0snKSA+IC0xKSB7XG4gICAgICBjYXN0bGluZy53IHw9IEJJVFMuS1NJREVfQ0FTVExFXG4gICAgfVxuICAgIGlmICh0b2tlbnNbMl0uaW5kZXhPZignUScpID4gLTEpIHtcbiAgICAgIGNhc3RsaW5nLncgfD0gQklUUy5RU0lERV9DQVNUTEVcbiAgICB9XG4gICAgaWYgKHRva2Vuc1syXS5pbmRleE9mKCdrJykgPiAtMSkge1xuICAgICAgY2FzdGxpbmcuYiB8PSBCSVRTLktTSURFX0NBU1RMRVxuICAgIH1cbiAgICBpZiAodG9rZW5zWzJdLmluZGV4T2YoJ3EnKSA+IC0xKSB7XG4gICAgICBjYXN0bGluZy5iIHw9IEJJVFMuUVNJREVfQ0FTVExFXG4gICAgfVxuXG4gICAgZXBfc3F1YXJlID0gdG9rZW5zWzNdID09PSAnLScgPyBFTVBUWSA6IFNRVUFSRVNbdG9rZW5zWzNdXVxuICAgIGhhbGZfbW92ZXMgPSBwYXJzZUludCh0b2tlbnNbNF0sIDEwKVxuICAgIG1vdmVfbnVtYmVyID0gcGFyc2VJbnQodG9rZW5zWzVdLCAxMClcblxuICAgIHVwZGF0ZV9zZXR1cChnZW5lcmF0ZV9mZW4oKSlcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKiBUT0RPOiB0aGlzIGZ1bmN0aW9uIGlzIHByZXR0eSBtdWNoIGNyYXAgLSBpdCB2YWxpZGF0ZXMgc3RydWN0dXJlIGJ1dFxuICAgKiBjb21wbGV0ZWx5IGlnbm9yZXMgY29udGVudCAoZS5nLiBkb2Vzbid0IHZlcmlmeSB0aGF0IGVhY2ggc2lkZSBoYXMgYSBraW5nKVxuICAgKiAuLi4gd2Ugc2hvdWxkIHJld3JpdGUgdGhpcywgYW5kIGRpdGNoIHRoZSBzaWxseSBlcnJvcl9udW1iZXIgZmllbGQgd2hpbGVcbiAgICogd2UncmUgYXQgaXRcbiAgICovXG4gIGZ1bmN0aW9uIHZhbGlkYXRlX2ZlbihmZW4pIHtcbiAgICB2YXIgZXJyb3JzID0ge1xuICAgICAgMDogJ05vIGVycm9ycy4nLFxuICAgICAgMTogJ0ZFTiBzdHJpbmcgbXVzdCBjb250YWluIHNpeCBzcGFjZS1kZWxpbWl0ZWQgZmllbGRzLicsXG4gICAgICAyOiAnNnRoIGZpZWxkIChtb3ZlIG51bWJlcikgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuJyxcbiAgICAgIDM6ICc1dGggZmllbGQgKGhhbGYgbW92ZSBjb3VudGVyKSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuJyxcbiAgICAgIDQ6ICc0dGggZmllbGQgKGVuLXBhc3NhbnQgc3F1YXJlKSBpcyBpbnZhbGlkLicsXG4gICAgICA1OiAnM3JkIGZpZWxkIChjYXN0bGluZyBhdmFpbGFiaWxpdHkpIGlzIGludmFsaWQuJyxcbiAgICAgIDY6ICcybmQgZmllbGQgKHNpZGUgdG8gbW92ZSkgaXMgaW52YWxpZC4nLFxuICAgICAgNzogXCIxc3QgZmllbGQgKHBpZWNlIHBvc2l0aW9ucykgZG9lcyBub3QgY29udGFpbiA4ICcvJy1kZWxpbWl0ZWQgcm93cy5cIixcbiAgICAgIDg6ICcxc3QgZmllbGQgKHBpZWNlIHBvc2l0aW9ucykgaXMgaW52YWxpZCBbY29uc2VjdXRpdmUgbnVtYmVyc10uJyxcbiAgICAgIDk6ICcxc3QgZmllbGQgKHBpZWNlIHBvc2l0aW9ucykgaXMgaW52YWxpZCBbaW52YWxpZCBwaWVjZV0uJyxcbiAgICAgIDEwOiAnMXN0IGZpZWxkIChwaWVjZSBwb3NpdGlvbnMpIGlzIGludmFsaWQgW3JvdyB0b28gbGFyZ2VdLicsXG4gICAgICAxMTogJ0lsbGVnYWwgZW4tcGFzc2FudCBzcXVhcmUnLFxuICAgIH1cblxuICAgIC8qIDFzdCBjcml0ZXJpb246IDYgc3BhY2Utc2VwZXJhdGVkIGZpZWxkcz8gKi9cbiAgICB2YXIgdG9rZW5zID0gZmVuLnNwbGl0KC9cXHMrLylcbiAgICBpZiAodG9rZW5zLmxlbmd0aCAhPT0gNikge1xuICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcl9udW1iZXI6IDEsIGVycm9yOiBlcnJvcnNbMV0gfVxuICAgIH1cblxuICAgIC8qIDJuZCBjcml0ZXJpb246IG1vdmUgbnVtYmVyIGZpZWxkIGlzIGEgaW50ZWdlciB2YWx1ZSA+IDA/ICovXG4gICAgaWYgKGlzTmFOKHRva2Vuc1s1XSkgfHwgcGFyc2VJbnQodG9rZW5zWzVdLCAxMCkgPD0gMCkge1xuICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcl9udW1iZXI6IDIsIGVycm9yOiBlcnJvcnNbMl0gfVxuICAgIH1cblxuICAgIC8qIDNyZCBjcml0ZXJpb246IGhhbGYgbW92ZSBjb3VudGVyIGlzIGFuIGludGVnZXIgPj0gMD8gKi9cbiAgICBpZiAoaXNOYU4odG9rZW5zWzRdKSB8fCBwYXJzZUludCh0b2tlbnNbNF0sIDEwKSA8IDApIHtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3JfbnVtYmVyOiAzLCBlcnJvcjogZXJyb3JzWzNdIH1cbiAgICB9XG5cbiAgICAvKiA0dGggY3JpdGVyaW9uOiA0dGggZmllbGQgaXMgYSB2YWxpZCBlLnAuLXN0cmluZz8gKi9cbiAgICBpZiAoIS9eKC18W2FiY2RlZmdoXVszNl0pJC8udGVzdCh0b2tlbnNbM10pKSB7XG4gICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yX251bWJlcjogNCwgZXJyb3I6IGVycm9yc1s0XSB9XG4gICAgfVxuXG4gICAgLyogNXRoIGNyaXRlcmlvbjogM3RoIGZpZWxkIGlzIGEgdmFsaWQgY2FzdGxlLXN0cmluZz8gKi9cbiAgICBpZiAoIS9eKEtRP2s/cT98UWs/cT98a3E/fHF8LSkkLy50ZXN0KHRva2Vuc1syXSkpIHtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3JfbnVtYmVyOiA1LCBlcnJvcjogZXJyb3JzWzVdIH1cbiAgICB9XG5cbiAgICAvKiA2dGggY3JpdGVyaW9uOiAybmQgZmllbGQgaXMgXCJ3XCIgKHdoaXRlKSBvciBcImJcIiAoYmxhY2spPyAqL1xuICAgIGlmICghL14od3xiKSQvLnRlc3QodG9rZW5zWzFdKSkge1xuICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcl9udW1iZXI6IDYsIGVycm9yOiBlcnJvcnNbNl0gfVxuICAgIH1cblxuICAgIC8qIDd0aCBjcml0ZXJpb246IDFzdCBmaWVsZCBjb250YWlucyA4IHJvd3M/ICovXG4gICAgdmFyIHJvd3MgPSB0b2tlbnNbMF0uc3BsaXQoJy8nKVxuICAgIGlmIChyb3dzLmxlbmd0aCAhPT0gOCkge1xuICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcl9udW1iZXI6IDcsIGVycm9yOiBlcnJvcnNbN10gfVxuICAgIH1cblxuICAgIC8qIDh0aCBjcml0ZXJpb246IGV2ZXJ5IHJvdyBpcyB2YWxpZD8gKi9cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8qIGNoZWNrIGZvciByaWdodCBzdW0gb2YgZmllbGRzIEFORCBub3QgdHdvIG51bWJlcnMgaW4gc3VjY2Vzc2lvbiAqL1xuICAgICAgdmFyIHN1bV9maWVsZHMgPSAwXG4gICAgICB2YXIgcHJldmlvdXNfd2FzX251bWJlciA9IGZhbHNlXG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcm93c1tpXS5sZW5ndGg7IGsrKykge1xuICAgICAgICBpZiAoIWlzTmFOKHJvd3NbaV1ba10pKSB7XG4gICAgICAgICAgaWYgKHByZXZpb3VzX3dhc19udW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3JfbnVtYmVyOiA4LCBlcnJvcjogZXJyb3JzWzhdIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3VtX2ZpZWxkcyArPSBwYXJzZUludChyb3dzW2ldW2tdLCAxMClcbiAgICAgICAgICBwcmV2aW91c193YXNfbnVtYmVyID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghL15bcHJuYnFrUFJOQlFLXSQvLnRlc3Qocm93c1tpXVtrXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3JfbnVtYmVyOiA5LCBlcnJvcjogZXJyb3JzWzldIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3VtX2ZpZWxkcyArPSAxXG4gICAgICAgICAgcHJldmlvdXNfd2FzX251bWJlciA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdW1fZmllbGRzICE9PSA4KSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3JfbnVtYmVyOiAxMCwgZXJyb3I6IGVycm9yc1sxMF0gfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgICh0b2tlbnNbM11bMV0gPT0gJzMnICYmIHRva2Vuc1sxXSA9PSAndycpIHx8XG4gICAgICAodG9rZW5zWzNdWzFdID09ICc2JyAmJiB0b2tlbnNbMV0gPT0gJ2InKVxuICAgICkge1xuICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcl9udW1iZXI6IDExLCBlcnJvcjogZXJyb3JzWzExXSB9XG4gICAgfVxuXG4gICAgLyogZXZlcnl0aGluZydzIG9rYXkhICovXG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGVycm9yX251bWJlcjogMCwgZXJyb3I6IGVycm9yc1swXSB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZV9mZW4oKSB7XG4gICAgdmFyIGVtcHR5ID0gMFxuICAgIHZhciBmZW4gPSAnJ1xuXG4gICAgZm9yICh2YXIgaSA9IFNRVUFSRVMuYTg7IGkgPD0gU1FVQVJFUy5oMTsgaSsrKSB7XG4gICAgICBpZiAoYm9hcmRbaV0gPT0gbnVsbCkge1xuICAgICAgICBlbXB0eSsrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZW1wdHkgPiAwKSB7XG4gICAgICAgICAgZmVuICs9IGVtcHR5XG4gICAgICAgICAgZW1wdHkgPSAwXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbG9yID0gYm9hcmRbaV0uY29sb3JcbiAgICAgICAgdmFyIHBpZWNlID0gYm9hcmRbaV0udHlwZVxuXG4gICAgICAgIGZlbiArPSBjb2xvciA9PT0gV0hJVEUgPyBwaWVjZS50b1VwcGVyQ2FzZSgpIDogcGllY2UudG9Mb3dlckNhc2UoKVxuICAgICAgfVxuXG4gICAgICBpZiAoKGkgKyAxKSAmIDB4ODgpIHtcbiAgICAgICAgaWYgKGVtcHR5ID4gMCkge1xuICAgICAgICAgIGZlbiArPSBlbXB0eVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgIT09IFNRVUFSRVMuaDEpIHtcbiAgICAgICAgICBmZW4gKz0gJy8nXG4gICAgICAgIH1cblxuICAgICAgICBlbXB0eSA9IDBcbiAgICAgICAgaSArPSA4XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNmbGFncyA9ICcnXG4gICAgaWYgKGNhc3RsaW5nW1dISVRFXSAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICBjZmxhZ3MgKz0gJ0snXG4gICAgfVxuICAgIGlmIChjYXN0bGluZ1tXSElURV0gJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgY2ZsYWdzICs9ICdRJ1xuICAgIH1cbiAgICBpZiAoY2FzdGxpbmdbQkxBQ0tdICYgQklUUy5LU0lERV9DQVNUTEUpIHtcbiAgICAgIGNmbGFncyArPSAnaydcbiAgICB9XG4gICAgaWYgKGNhc3RsaW5nW0JMQUNLXSAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICBjZmxhZ3MgKz0gJ3EnXG4gICAgfVxuXG4gICAgLyogZG8gd2UgaGF2ZSBhbiBlbXB0eSBjYXN0bGluZyBmbGFnPyAqL1xuICAgIGNmbGFncyA9IGNmbGFncyB8fCAnLSdcbiAgICB2YXIgZXBmbGFncyA9IGVwX3NxdWFyZSA9PT0gRU1QVFkgPyAnLScgOiBhbGdlYnJhaWMoZXBfc3F1YXJlKVxuXG4gICAgcmV0dXJuIFtmZW4sIHR1cm4sIGNmbGFncywgZXBmbGFncywgaGFsZl9tb3ZlcywgbW92ZV9udW1iZXJdLmpvaW4oJyAnKVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0X2hlYWRlcihhcmdzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBhcmdzW2kgKyAxXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaGVhZGVyW2FyZ3NbaV1dID0gYXJnc1tpICsgMV1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlclxuICB9XG5cbiAgLyogY2FsbGVkIHdoZW4gdGhlIGluaXRpYWwgYm9hcmQgc2V0dXAgaXMgY2hhbmdlZCB3aXRoIHB1dCgpIG9yIHJlbW92ZSgpLlxuICAgKiBtb2RpZmllcyB0aGUgU2V0VXAgYW5kIEZFTiBwcm9wZXJ0aWVzIG9mIHRoZSBoZWFkZXIgb2JqZWN0LiAgaWYgdGhlIEZFTiBpc1xuICAgKiBlcXVhbCB0byB0aGUgZGVmYXVsdCBwb3NpdGlvbiwgdGhlIFNldFVwIGFuZCBGRU4gYXJlIGRlbGV0ZWRcbiAgICogdGhlIHNldHVwIGlzIG9ubHkgdXBkYXRlZCBpZiBoaXN0b3J5Lmxlbmd0aCBpcyB6ZXJvLCBpZSBtb3ZlcyBoYXZlbid0IGJlZW5cbiAgICogbWFkZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZV9zZXR1cChmZW4pIHtcbiAgICBpZiAoaGlzdG9yeS5sZW5ndGggPiAwKSByZXR1cm5cblxuICAgIGlmIChmZW4gIT09IERFRkFVTFRfUE9TSVRJT04pIHtcbiAgICAgIGhlYWRlclsnU2V0VXAnXSA9ICcxJ1xuICAgICAgaGVhZGVyWydGRU4nXSA9IGZlblxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgaGVhZGVyWydTZXRVcCddXG4gICAgICBkZWxldGUgaGVhZGVyWydGRU4nXVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldChzcXVhcmUpIHtcbiAgICB2YXIgcGllY2UgPSBib2FyZFtTUVVBUkVTW3NxdWFyZV1dXG4gICAgcmV0dXJuIHBpZWNlID8geyB0eXBlOiBwaWVjZS50eXBlLCBjb2xvcjogcGllY2UuY29sb3IgfSA6IG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1dChwaWVjZSwgc3F1YXJlKSB7XG4gICAgLyogY2hlY2sgZm9yIHZhbGlkIHBpZWNlIG9iamVjdCAqL1xuICAgIGlmICghKCd0eXBlJyBpbiBwaWVjZSAmJiAnY29sb3InIGluIHBpZWNlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyogY2hlY2sgZm9yIHBpZWNlICovXG4gICAgaWYgKFNZTUJPTFMuaW5kZXhPZihwaWVjZS50eXBlLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyogY2hlY2sgZm9yIHZhbGlkIHNxdWFyZSAqL1xuICAgIGlmICghKHNxdWFyZSBpbiBTUVVBUkVTKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdmFyIHNxID0gU1FVQVJFU1tzcXVhcmVdXG5cbiAgICAvKiBkb24ndCBsZXQgdGhlIHVzZXIgcGxhY2UgbW9yZSB0aGFuIG9uZSBraW5nICovXG4gICAgaWYgKFxuICAgICAgcGllY2UudHlwZSA9PSBLSU5HICYmXG4gICAgICAhKGtpbmdzW3BpZWNlLmNvbG9yXSA9PSBFTVBUWSB8fCBraW5nc1twaWVjZS5jb2xvcl0gPT0gc3EpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBib2FyZFtzcV0gPSB7IHR5cGU6IHBpZWNlLnR5cGUsIGNvbG9yOiBwaWVjZS5jb2xvciB9XG4gICAgaWYgKHBpZWNlLnR5cGUgPT09IEtJTkcpIHtcbiAgICAgIGtpbmdzW3BpZWNlLmNvbG9yXSA9IHNxXG4gICAgfVxuXG4gICAgdXBkYXRlX3NldHVwKGdlbmVyYXRlX2ZlbigpKVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZShzcXVhcmUpIHtcbiAgICB2YXIgcGllY2UgPSBnZXQoc3F1YXJlKVxuICAgIGJvYXJkW1NRVUFSRVNbc3F1YXJlXV0gPSBudWxsXG4gICAgaWYgKHBpZWNlICYmIHBpZWNlLnR5cGUgPT09IEtJTkcpIHtcbiAgICAgIGtpbmdzW3BpZWNlLmNvbG9yXSA9IEVNUFRZXG4gICAgfVxuXG4gICAgdXBkYXRlX3NldHVwKGdlbmVyYXRlX2ZlbigpKVxuXG4gICAgcmV0dXJuIHBpZWNlXG4gIH1cblxuICBmdW5jdGlvbiBidWlsZF9tb3ZlKGJvYXJkLCBmcm9tLCB0bywgZmxhZ3MsIHByb21vdGlvbikge1xuICAgIHZhciBtb3ZlID0ge1xuICAgICAgY29sb3I6IHR1cm4sXG4gICAgICBmcm9tOiBmcm9tLFxuICAgICAgdG86IHRvLFxuICAgICAgZmxhZ3M6IGZsYWdzLFxuICAgICAgcGllY2U6IGJvYXJkW2Zyb21dLnR5cGUsXG4gICAgfVxuXG4gICAgaWYgKHByb21vdGlvbikge1xuICAgICAgbW92ZS5mbGFncyB8PSBCSVRTLlBST01PVElPTlxuICAgICAgbW92ZS5wcm9tb3Rpb24gPSBwcm9tb3Rpb25cbiAgICB9XG5cbiAgICBpZiAoYm9hcmRbdG9dKSB7XG4gICAgICBtb3ZlLmNhcHR1cmVkID0gYm9hcmRbdG9dLnR5cGVcbiAgICB9IGVsc2UgaWYgKGZsYWdzICYgQklUUy5FUF9DQVBUVVJFKSB7XG4gICAgICBtb3ZlLmNhcHR1cmVkID0gUEFXTlxuICAgIH1cbiAgICByZXR1cm4gbW92ZVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVfbW92ZXMob3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGFkZF9tb3ZlKGJvYXJkLCBtb3ZlcywgZnJvbSwgdG8sIGZsYWdzKSB7XG4gICAgICAvKiBpZiBwYXduIHByb21vdGlvbiAqL1xuICAgICAgaWYgKFxuICAgICAgICBib2FyZFtmcm9tXS50eXBlID09PSBQQVdOICYmXG4gICAgICAgIChyYW5rKHRvKSA9PT0gUkFOS184IHx8IHJhbmsodG8pID09PSBSQU5LXzEpXG4gICAgICApIHtcbiAgICAgICAgdmFyIHBpZWNlcyA9IFtRVUVFTiwgUk9PSywgQklTSE9QLCBLTklHSFRdXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwaWVjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBtb3Zlcy5wdXNoKGJ1aWxkX21vdmUoYm9hcmQsIGZyb20sIHRvLCBmbGFncywgcGllY2VzW2ldKSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW92ZXMucHVzaChidWlsZF9tb3ZlKGJvYXJkLCBmcm9tLCB0bywgZmxhZ3MpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtb3ZlcyA9IFtdXG4gICAgdmFyIHVzID0gdHVyblxuICAgIHZhciB0aGVtID0gc3dhcF9jb2xvcih1cylcbiAgICB2YXIgc2Vjb25kX3JhbmsgPSB7IGI6IFJBTktfNywgdzogUkFOS18yIH1cblxuICAgIHZhciBmaXJzdF9zcSA9IFNRVUFSRVMuYThcbiAgICB2YXIgbGFzdF9zcSA9IFNRVUFSRVMuaDFcbiAgICB2YXIgc2luZ2xlX3NxdWFyZSA9IGZhbHNlXG5cbiAgICAvKiBkbyB3ZSB3YW50IGxlZ2FsIG1vdmVzPyAqL1xuICAgIHZhciBsZWdhbCA9XG4gICAgICB0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2xlZ2FsJyBpbiBvcHRpb25zXG4gICAgICAgID8gb3B0aW9ucy5sZWdhbFxuICAgICAgICA6IHRydWVcblxuICAgIHZhciBwaWVjZV90eXBlID1cbiAgICAgIHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgJ3BpZWNlJyBpbiBvcHRpb25zICYmXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5waWVjZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBvcHRpb25zLnBpZWNlLnRvTG93ZXJDYXNlKClcbiAgICAgICAgOiB0cnVlXG5cbiAgICAvKiBhcmUgd2UgZ2VuZXJhdGluZyBtb3ZlcyBmb3IgYSBzaW5nbGUgc3F1YXJlPyAqL1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3NxdWFyZScgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMuc3F1YXJlIGluIFNRVUFSRVMpIHtcbiAgICAgICAgZmlyc3Rfc3EgPSBsYXN0X3NxID0gU1FVQVJFU1tvcHRpb25zLnNxdWFyZV1cbiAgICAgICAgc2luZ2xlX3NxdWFyZSA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGludmFsaWQgc3F1YXJlICovXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSBmaXJzdF9zcTsgaSA8PSBsYXN0X3NxOyBpKyspIHtcbiAgICAgIC8qIGRpZCB3ZSBydW4gb2ZmIHRoZSBlbmQgb2YgdGhlIGJvYXJkICovXG4gICAgICBpZiAoaSAmIDB4ODgpIHtcbiAgICAgICAgaSArPSA3XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciBwaWVjZSA9IGJvYXJkW2ldXG4gICAgICBpZiAocGllY2UgPT0gbnVsbCB8fCBwaWVjZS5jb2xvciAhPT0gdXMpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKHBpZWNlLnR5cGUgPT09IFBBV04gJiYgKHBpZWNlX3R5cGUgPT09IHRydWUgfHwgcGllY2VfdHlwZSA9PT0gUEFXTikpIHtcbiAgICAgICAgLyogc2luZ2xlIHNxdWFyZSwgbm9uLWNhcHR1cmluZyAqL1xuICAgICAgICB2YXIgc3F1YXJlID0gaSArIFBBV05fT0ZGU0VUU1t1c11bMF1cbiAgICAgICAgaWYgKGJvYXJkW3NxdWFyZV0gPT0gbnVsbCkge1xuICAgICAgICAgIGFkZF9tb3ZlKGJvYXJkLCBtb3ZlcywgaSwgc3F1YXJlLCBCSVRTLk5PUk1BTClcblxuICAgICAgICAgIC8qIGRvdWJsZSBzcXVhcmUgKi9cbiAgICAgICAgICB2YXIgc3F1YXJlID0gaSArIFBBV05fT0ZGU0VUU1t1c11bMV1cbiAgICAgICAgICBpZiAoc2Vjb25kX3JhbmtbdXNdID09PSByYW5rKGkpICYmIGJvYXJkW3NxdWFyZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgYWRkX21vdmUoYm9hcmQsIG1vdmVzLCBpLCBzcXVhcmUsIEJJVFMuQklHX1BBV04pXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogcGF3biBjYXB0dXJlcyAqL1xuICAgICAgICBmb3IgKGogPSAyOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgdmFyIHNxdWFyZSA9IGkgKyBQQVdOX09GRlNFVFNbdXNdW2pdXG4gICAgICAgICAgaWYgKHNxdWFyZSAmIDB4ODgpIGNvbnRpbnVlXG5cbiAgICAgICAgICBpZiAoYm9hcmRbc3F1YXJlXSAhPSBudWxsICYmIGJvYXJkW3NxdWFyZV0uY29sb3IgPT09IHRoZW0pIHtcbiAgICAgICAgICAgIGFkZF9tb3ZlKGJvYXJkLCBtb3ZlcywgaSwgc3F1YXJlLCBCSVRTLkNBUFRVUkUpXG4gICAgICAgICAgfSBlbHNlIGlmIChzcXVhcmUgPT09IGVwX3NxdWFyZSkge1xuICAgICAgICAgICAgYWRkX21vdmUoYm9hcmQsIG1vdmVzLCBpLCBlcF9zcXVhcmUsIEJJVFMuRVBfQ0FQVFVSRSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGllY2VfdHlwZSA9PT0gdHJ1ZSB8fCBwaWVjZV90eXBlID09PSBwaWVjZS50eXBlKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBQSUVDRV9PRkZTRVRTW3BpZWNlLnR5cGVdLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IFBJRUNFX09GRlNFVFNbcGllY2UudHlwZV1bal1cbiAgICAgICAgICB2YXIgc3F1YXJlID0gaVxuXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHNxdWFyZSArPSBvZmZzZXRcbiAgICAgICAgICAgIGlmIChzcXVhcmUgJiAweDg4KSBicmVha1xuXG4gICAgICAgICAgICBpZiAoYm9hcmRbc3F1YXJlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGFkZF9tb3ZlKGJvYXJkLCBtb3ZlcywgaSwgc3F1YXJlLCBCSVRTLk5PUk1BTClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChib2FyZFtzcXVhcmVdLmNvbG9yID09PSB1cykgYnJlYWtcbiAgICAgICAgICAgICAgYWRkX21vdmUoYm9hcmQsIG1vdmVzLCBpLCBzcXVhcmUsIEJJVFMuQ0FQVFVSRSlcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogYnJlYWssIGlmIGtuaWdodCBvciBraW5nICovXG4gICAgICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gJ24nIHx8IHBpZWNlLnR5cGUgPT09ICdrJykgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBjaGVjayBmb3IgY2FzdGxpbmcgaWY6IGEpIHdlJ3JlIGdlbmVyYXRpbmcgYWxsIG1vdmVzLCBvciBiKSB3ZSdyZSBkb2luZ1xuICAgICAqIHNpbmdsZSBzcXVhcmUgbW92ZSBnZW5lcmF0aW9uIG9uIHRoZSBraW5nJ3Mgc3F1YXJlXG4gICAgICovXG4gICAgaWYgKHBpZWNlX3R5cGUgPT09IHRydWUgfHwgcGllY2VfdHlwZSA9PT0gS0lORykge1xuICAgICAgaWYgKCFzaW5nbGVfc3F1YXJlIHx8IGxhc3Rfc3EgPT09IGtpbmdzW3VzXSkge1xuICAgICAgICAvKiBraW5nLXNpZGUgY2FzdGxpbmcgKi9cbiAgICAgICAgaWYgKGNhc3RsaW5nW3VzXSAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgdmFyIGNhc3RsaW5nX2Zyb20gPSBraW5nc1t1c11cbiAgICAgICAgICB2YXIgY2FzdGxpbmdfdG8gPSBjYXN0bGluZ19mcm9tICsgMlxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgYm9hcmRbY2FzdGxpbmdfZnJvbSArIDFdID09IG51bGwgJiZcbiAgICAgICAgICAgIGJvYXJkW2Nhc3RsaW5nX3RvXSA9PSBudWxsICYmXG4gICAgICAgICAgICAhYXR0YWNrZWQodGhlbSwga2luZ3NbdXNdKSAmJlxuICAgICAgICAgICAgIWF0dGFja2VkKHRoZW0sIGNhc3RsaW5nX2Zyb20gKyAxKSAmJlxuICAgICAgICAgICAgIWF0dGFja2VkKHRoZW0sIGNhc3RsaW5nX3RvKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgYWRkX21vdmUoYm9hcmQsIG1vdmVzLCBraW5nc1t1c10sIGNhc3RsaW5nX3RvLCBCSVRTLktTSURFX0NBU1RMRSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBxdWVlbi1zaWRlIGNhc3RsaW5nICovXG4gICAgICAgIGlmIChjYXN0bGluZ1t1c10gJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgICAgIHZhciBjYXN0bGluZ19mcm9tID0ga2luZ3NbdXNdXG4gICAgICAgICAgdmFyIGNhc3RsaW5nX3RvID0gY2FzdGxpbmdfZnJvbSAtIDJcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGJvYXJkW2Nhc3RsaW5nX2Zyb20gLSAxXSA9PSBudWxsICYmXG4gICAgICAgICAgICBib2FyZFtjYXN0bGluZ19mcm9tIC0gMl0gPT0gbnVsbCAmJlxuICAgICAgICAgICAgYm9hcmRbY2FzdGxpbmdfZnJvbSAtIDNdID09IG51bGwgJiZcbiAgICAgICAgICAgICFhdHRhY2tlZCh0aGVtLCBraW5nc1t1c10pICYmXG4gICAgICAgICAgICAhYXR0YWNrZWQodGhlbSwgY2FzdGxpbmdfZnJvbSAtIDEpICYmXG4gICAgICAgICAgICAhYXR0YWNrZWQodGhlbSwgY2FzdGxpbmdfdG8pXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBhZGRfbW92ZShib2FyZCwgbW92ZXMsIGtpbmdzW3VzXSwgY2FzdGxpbmdfdG8sIEJJVFMuUVNJREVfQ0FTVExFKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qIHJldHVybiBhbGwgcHNldWRvLWxlZ2FsIG1vdmVzICh0aGlzIGluY2x1ZGVzIG1vdmVzIHRoYXQgYWxsb3cgdGhlIGtpbmdcbiAgICAgKiB0byBiZSBjYXB0dXJlZClcbiAgICAgKi9cbiAgICBpZiAoIWxlZ2FsKSB7XG4gICAgICByZXR1cm4gbW92ZXNcbiAgICB9XG5cbiAgICAvKiBmaWx0ZXIgb3V0IGlsbGVnYWwgbW92ZXMgKi9cbiAgICB2YXIgbGVnYWxfbW92ZXMgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbWFrZV9tb3ZlKG1vdmVzW2ldKVxuICAgICAgaWYgKCFraW5nX2F0dGFja2VkKHVzKSkge1xuICAgICAgICBsZWdhbF9tb3Zlcy5wdXNoKG1vdmVzW2ldKVxuICAgICAgfVxuICAgICAgdW5kb19tb3ZlKClcbiAgICB9XG5cbiAgICByZXR1cm4gbGVnYWxfbW92ZXNcbiAgfVxuXG4gIC8qIGNvbnZlcnQgYSBtb3ZlIGZyb20gMHg4OCBjb29yZGluYXRlcyB0byBTdGFuZGFyZCBBbGdlYnJhaWMgTm90YXRpb25cbiAgICogKFNBTilcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBzbG9wcHkgVXNlIHRoZSBzbG9wcHkgU0FOIGdlbmVyYXRvciB0byB3b3JrIGFyb3VuZCBvdmVyXG4gICAqIGRpc2FtYmlndWF0aW9uIGJ1Z3MgaW4gRnJpdHogYW5kIENoZXNzYmFzZS4gIFNlZSBiZWxvdzpcbiAgICpcbiAgICogcjFicWtibnIvcHBwMnBwcC8ybjUvMUIxcFAzLzRQMy84L1BQUFAyUFAvUk5CUUsxTlIgYiBLUWtxIC0gMiA0XG4gICAqIDQuIC4uLiBOZ2U3IGlzIG92ZXJseSBkaXNhbWJpZ3VhdGVkIGJlY2F1c2UgdGhlIGtuaWdodCBvbiBjNiBpcyBwaW5uZWRcbiAgICogNC4gLi4uIE5lNyBpcyB0ZWNobmljYWxseSB0aGUgdmFsaWQgU0FOXG4gICAqL1xuICBmdW5jdGlvbiBtb3ZlX3RvX3Nhbihtb3ZlLCBtb3Zlcykge1xuICAgIHZhciBvdXRwdXQgPSAnJ1xuXG4gICAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgb3V0cHV0ID0gJ08tTydcbiAgICB9IGVsc2UgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgb3V0cHV0ID0gJ08tTy1PJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobW92ZS5waWVjZSAhPT0gUEFXTikge1xuICAgICAgICB2YXIgZGlzYW1iaWd1YXRvciA9IGdldF9kaXNhbWJpZ3VhdG9yKG1vdmUsIG1vdmVzKVxuICAgICAgICBvdXRwdXQgKz0gbW92ZS5waWVjZS50b1VwcGVyQ2FzZSgpICsgZGlzYW1iaWd1YXRvclxuICAgICAgfVxuXG4gICAgICBpZiAobW92ZS5mbGFncyAmIChCSVRTLkNBUFRVUkUgfCBCSVRTLkVQX0NBUFRVUkUpKSB7XG4gICAgICAgIGlmIChtb3ZlLnBpZWNlID09PSBQQVdOKSB7XG4gICAgICAgICAgb3V0cHV0ICs9IGFsZ2VicmFpYyhtb3ZlLmZyb20pWzBdXG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ICs9ICd4J1xuICAgICAgfVxuXG4gICAgICBvdXRwdXQgKz0gYWxnZWJyYWljKG1vdmUudG8pXG5cbiAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5QUk9NT1RJT04pIHtcbiAgICAgICAgb3V0cHV0ICs9ICc9JyArIG1vdmUucHJvbW90aW9uLnRvVXBwZXJDYXNlKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtYWtlX21vdmUobW92ZSlcbiAgICBpZiAoaW5fY2hlY2soKSkge1xuICAgICAgaWYgKGluX2NoZWNrbWF0ZSgpKSB7XG4gICAgICAgIG91dHB1dCArPSAnIydcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCArPSAnKydcbiAgICAgIH1cbiAgICB9XG4gICAgdW5kb19tb3ZlKClcblxuICAgIHJldHVybiBvdXRwdXRcbiAgfVxuICAvLyBwYXJzZXMgYWxsIG9mIHRoZSBkZWNvcmF0b3JzIG91dCBvZiBhIFNBTiBzdHJpbmdcbiAgZnVuY3Rpb24gc3RyaXBwZWRfc2FuKG1vdmUpIHtcbiAgICByZXR1cm4gbW92ZS5yZXBsYWNlKC89LywgJycpLnJlcGxhY2UoL1srI10/Wz8hXSokLywgJycpXG4gIH1cblxuICBmdW5jdGlvbiBhdHRhY2tlZChjb2xvciwgc3F1YXJlKSB7XG4gICAgZm9yICh2YXIgaSA9IFNRVUFSRVMuYTg7IGkgPD0gU1FVQVJFUy5oMTsgaSsrKSB7XG4gICAgICAvKiBkaWQgd2UgcnVuIG9mZiB0aGUgZW5kIG9mIHRoZSBib2FyZCAqL1xuICAgICAgaWYgKGkgJiAweDg4KSB7XG4gICAgICAgIGkgKz0gN1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvKiBpZiBlbXB0eSBzcXVhcmUgb3Igd3JvbmcgY29sb3IgKi9cbiAgICAgIGlmIChib2FyZFtpXSA9PSBudWxsIHx8IGJvYXJkW2ldLmNvbG9yICE9PSBjb2xvcikgY29udGludWVcblxuICAgICAgdmFyIHBpZWNlID0gYm9hcmRbaV1cbiAgICAgIHZhciBkaWZmZXJlbmNlID0gaSAtIHNxdWFyZVxuICAgICAgdmFyIGluZGV4ID0gZGlmZmVyZW5jZSArIDExOVxuXG4gICAgICBpZiAoQVRUQUNLU1tpbmRleF0gJiAoMSA8PCBTSElGVFNbcGllY2UudHlwZV0pKSB7XG4gICAgICAgIGlmIChwaWVjZS50eXBlID09PSBQQVdOKSB7XG4gICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPiAwKSB7XG4gICAgICAgICAgICBpZiAocGllY2UuY29sb3IgPT09IFdISVRFKSByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocGllY2UuY29sb3IgPT09IEJMQUNLKSByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLyogaWYgdGhlIHBpZWNlIGlzIGEga25pZ2h0IG9yIGEga2luZyAqL1xuICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gJ24nIHx8IHBpZWNlLnR5cGUgPT09ICdrJykgcmV0dXJuIHRydWVcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gUkFZU1tpbmRleF1cbiAgICAgICAgdmFyIGogPSBpICsgb2Zmc2V0XG5cbiAgICAgICAgdmFyIGJsb2NrZWQgPSBmYWxzZVxuICAgICAgICB3aGlsZSAoaiAhPT0gc3F1YXJlKSB7XG4gICAgICAgICAgaWYgKGJvYXJkW2pdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGJsb2NrZWQgPSB0cnVlXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBqICs9IG9mZnNldFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFibG9ja2VkKSByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24ga2luZ19hdHRhY2tlZChjb2xvcikge1xuICAgIHJldHVybiBhdHRhY2tlZChzd2FwX2NvbG9yKGNvbG9yKSwga2luZ3NbY29sb3JdKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5fY2hlY2soKSB7XG4gICAgcmV0dXJuIGtpbmdfYXR0YWNrZWQodHVybilcbiAgfVxuXG4gIGZ1bmN0aW9uIGluX2NoZWNrbWF0ZSgpIHtcbiAgICByZXR1cm4gaW5fY2hlY2soKSAmJiBnZW5lcmF0ZV9tb3ZlcygpLmxlbmd0aCA9PT0gMFxuICB9XG5cbiAgZnVuY3Rpb24gaW5fc3RhbGVtYXRlKCkge1xuICAgIHJldHVybiAhaW5fY2hlY2soKSAmJiBnZW5lcmF0ZV9tb3ZlcygpLmxlbmd0aCA9PT0gMFxuICB9XG5cbiAgZnVuY3Rpb24gaW5zdWZmaWNpZW50X21hdGVyaWFsKCkge1xuICAgIHZhciBwaWVjZXMgPSB7fVxuICAgIHZhciBiaXNob3BzID0gW11cbiAgICB2YXIgbnVtX3BpZWNlcyA9IDBcbiAgICB2YXIgc3FfY29sb3IgPSAwXG5cbiAgICBmb3IgKHZhciBpID0gU1FVQVJFUy5hODsgaSA8PSBTUVVBUkVTLmgxOyBpKyspIHtcbiAgICAgIHNxX2NvbG9yID0gKHNxX2NvbG9yICsgMSkgJSAyXG4gICAgICBpZiAoaSAmIDB4ODgpIHtcbiAgICAgICAgaSArPSA3XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciBwaWVjZSA9IGJvYXJkW2ldXG4gICAgICBpZiAocGllY2UpIHtcbiAgICAgICAgcGllY2VzW3BpZWNlLnR5cGVdID0gcGllY2UudHlwZSBpbiBwaWVjZXMgPyBwaWVjZXNbcGllY2UudHlwZV0gKyAxIDogMVxuICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gQklTSE9QKSB7XG4gICAgICAgICAgYmlzaG9wcy5wdXNoKHNxX2NvbG9yKVxuICAgICAgICB9XG4gICAgICAgIG51bV9waWVjZXMrK1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIGsgdnMuIGsgKi9cbiAgICBpZiAobnVtX3BpZWNlcyA9PT0gMikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLyogayB2cy4ga24gLi4uLiBvciAuLi4uIGsgdnMuIGtiICovXG4gICAgICBudW1fcGllY2VzID09PSAzICYmXG4gICAgICAocGllY2VzW0JJU0hPUF0gPT09IDEgfHwgcGllY2VzW0tOSUdIVF0gPT09IDEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAobnVtX3BpZWNlcyA9PT0gcGllY2VzW0JJU0hPUF0gKyAyKSB7XG4gICAgICAvKiBrYiB2cy4ga2Igd2hlcmUgYW55IG51bWJlciBvZiBiaXNob3BzIGFyZSBhbGwgb24gdGhlIHNhbWUgY29sb3IgKi9cbiAgICAgIHZhciBzdW0gPSAwXG4gICAgICB2YXIgbGVuID0gYmlzaG9wcy5sZW5ndGhcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3VtICs9IGJpc2hvcHNbaV1cbiAgICAgIH1cbiAgICAgIGlmIChzdW0gPT09IDAgfHwgc3VtID09PSBsZW4pIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIGluX3RocmVlZm9sZF9yZXBldGl0aW9uKCkge1xuICAgIC8qIFRPRE86IHdoaWxlIHRoaXMgZnVuY3Rpb24gaXMgZmluZSBmb3IgY2FzdWFsIHVzZSwgYSBiZXR0ZXJcbiAgICAgKiBpbXBsZW1lbnRhdGlvbiB3b3VsZCB1c2UgYSBab2JyaXN0IGtleSAoaW5zdGVhZCBvZiBGRU4pLiB0aGVcbiAgICAgKiBab2JyaXN0IGtleSB3b3VsZCBiZSBtYWludGFpbmVkIGluIHRoZSBtYWtlX21vdmUvdW5kb19tb3ZlIGZ1bmN0aW9ucyxcbiAgICAgKiBhdm9pZGluZyB0aGUgY29zdGx5IHRoYXQgd2UgZG8gYmVsb3cuXG4gICAgICovXG4gICAgdmFyIG1vdmVzID0gW11cbiAgICB2YXIgcG9zaXRpb25zID0ge31cbiAgICB2YXIgcmVwZXRpdGlvbiA9IGZhbHNlXG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIG1vdmUgPSB1bmRvX21vdmUoKVxuICAgICAgaWYgKCFtb3ZlKSBicmVha1xuICAgICAgbW92ZXMucHVzaChtb3ZlKVxuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvKiByZW1vdmUgdGhlIGxhc3QgdHdvIGZpZWxkcyBpbiB0aGUgRkVOIHN0cmluZywgdGhleSdyZSBub3QgbmVlZGVkXG4gICAgICAgKiB3aGVuIGNoZWNraW5nIGZvciBkcmF3IGJ5IHJlcCAqL1xuICAgICAgdmFyIGZlbiA9IGdlbmVyYXRlX2ZlbigpLnNwbGl0KCcgJykuc2xpY2UoMCwgNCkuam9pbignICcpXG5cbiAgICAgIC8qIGhhcyB0aGUgcG9zaXRpb24gb2NjdXJyZWQgdGhyZWUgb3IgbW92ZSB0aW1lcyAqL1xuICAgICAgcG9zaXRpb25zW2Zlbl0gPSBmZW4gaW4gcG9zaXRpb25zID8gcG9zaXRpb25zW2Zlbl0gKyAxIDogMVxuICAgICAgaWYgKHBvc2l0aW9uc1tmZW5dID49IDMpIHtcbiAgICAgICAgcmVwZXRpdGlvbiA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCFtb3Zlcy5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIG1ha2VfbW92ZShtb3Zlcy5wb3AoKSlcbiAgICB9XG5cbiAgICByZXR1cm4gcmVwZXRpdGlvblxuICB9XG5cbiAgZnVuY3Rpb24gcHVzaChtb3ZlKSB7XG4gICAgaGlzdG9yeS5wdXNoKHtcbiAgICAgIG1vdmU6IG1vdmUsXG4gICAgICBraW5nczogeyBiOiBraW5ncy5iLCB3OiBraW5ncy53IH0sXG4gICAgICB0dXJuOiB0dXJuLFxuICAgICAgY2FzdGxpbmc6IHsgYjogY2FzdGxpbmcuYiwgdzogY2FzdGxpbmcudyB9LFxuICAgICAgZXBfc3F1YXJlOiBlcF9zcXVhcmUsXG4gICAgICBoYWxmX21vdmVzOiBoYWxmX21vdmVzLFxuICAgICAgbW92ZV9udW1iZXI6IG1vdmVfbnVtYmVyLFxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBtYWtlX21vdmUobW92ZSkge1xuICAgIHZhciB1cyA9IHR1cm5cbiAgICB2YXIgdGhlbSA9IHN3YXBfY29sb3IodXMpXG4gICAgcHVzaChtb3ZlKVxuXG4gICAgYm9hcmRbbW92ZS50b10gPSBib2FyZFttb3ZlLmZyb21dXG4gICAgYm9hcmRbbW92ZS5mcm9tXSA9IG51bGxcblxuICAgIC8qIGlmIGVwIGNhcHR1cmUsIHJlbW92ZSB0aGUgY2FwdHVyZWQgcGF3biAqL1xuICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5FUF9DQVBUVVJFKSB7XG4gICAgICBpZiAodHVybiA9PT0gQkxBQ0spIHtcbiAgICAgICAgYm9hcmRbbW92ZS50byAtIDE2XSA9IG51bGxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvYXJkW21vdmUudG8gKyAxNl0gPSBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogaWYgcGF3biBwcm9tb3Rpb24sIHJlcGxhY2Ugd2l0aCBuZXcgcGllY2UgKi9cbiAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuUFJPTU9USU9OKSB7XG4gICAgICBib2FyZFttb3ZlLnRvXSA9IHsgdHlwZTogbW92ZS5wcm9tb3Rpb24sIGNvbG9yOiB1cyB9XG4gICAgfVxuXG4gICAgLyogaWYgd2UgbW92ZWQgdGhlIGtpbmcgKi9cbiAgICBpZiAoYm9hcmRbbW92ZS50b10udHlwZSA9PT0gS0lORykge1xuICAgICAga2luZ3NbYm9hcmRbbW92ZS50b10uY29sb3JdID0gbW92ZS50b1xuXG4gICAgICAvKiBpZiB3ZSBjYXN0bGVkLCBtb3ZlIHRoZSByb29rIG5leHQgdG8gdGhlIGtpbmcgKi9cbiAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5LU0lERV9DQVNUTEUpIHtcbiAgICAgICAgdmFyIGNhc3RsaW5nX3RvID0gbW92ZS50byAtIDFcbiAgICAgICAgdmFyIGNhc3RsaW5nX2Zyb20gPSBtb3ZlLnRvICsgMVxuICAgICAgICBib2FyZFtjYXN0bGluZ190b10gPSBib2FyZFtjYXN0bGluZ19mcm9tXVxuICAgICAgICBib2FyZFtjYXN0bGluZ19mcm9tXSA9IG51bGxcbiAgICAgIH0gZWxzZSBpZiAobW92ZS5mbGFncyAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICAgIHZhciBjYXN0bGluZ190byA9IG1vdmUudG8gKyAxXG4gICAgICAgIHZhciBjYXN0bGluZ19mcm9tID0gbW92ZS50byAtIDJcbiAgICAgICAgYm9hcmRbY2FzdGxpbmdfdG9dID0gYm9hcmRbY2FzdGxpbmdfZnJvbV1cbiAgICAgICAgYm9hcmRbY2FzdGxpbmdfZnJvbV0gPSBudWxsXG4gICAgICB9XG5cbiAgICAgIC8qIHR1cm4gb2ZmIGNhc3RsaW5nICovXG4gICAgICBjYXN0bGluZ1t1c10gPSAnJ1xuICAgIH1cblxuICAgIC8qIHR1cm4gb2ZmIGNhc3RsaW5nIGlmIHdlIG1vdmUgYSByb29rICovXG4gICAgaWYgKGNhc3RsaW5nW3VzXSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IFJPT0tTW3VzXS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbW92ZS5mcm9tID09PSBST09LU1t1c11baV0uc3F1YXJlICYmXG4gICAgICAgICAgY2FzdGxpbmdbdXNdICYgUk9PS1NbdXNdW2ldLmZsYWdcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzdGxpbmdbdXNdIF49IFJPT0tTW3VzXVtpXS5mbGFnXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qIHR1cm4gb2ZmIGNhc3RsaW5nIGlmIHdlIGNhcHR1cmUgYSByb29rICovXG4gICAgaWYgKGNhc3RsaW5nW3RoZW1dKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gUk9PS1NbdGhlbV0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1vdmUudG8gPT09IFJPT0tTW3RoZW1dW2ldLnNxdWFyZSAmJlxuICAgICAgICAgIGNhc3RsaW5nW3RoZW1dICYgUk9PS1NbdGhlbV1baV0uZmxhZ1xuICAgICAgICApIHtcbiAgICAgICAgICBjYXN0bGluZ1t0aGVtXSBePSBST09LU1t0aGVtXVtpXS5mbGFnXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qIGlmIGJpZyBwYXduIG1vdmUsIHVwZGF0ZSB0aGUgZW4gcGFzc2FudCBzcXVhcmUgKi9cbiAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuQklHX1BBV04pIHtcbiAgICAgIGlmICh0dXJuID09PSAnYicpIHtcbiAgICAgICAgZXBfc3F1YXJlID0gbW92ZS50byAtIDE2XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcF9zcXVhcmUgPSBtb3ZlLnRvICsgMTZcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXBfc3F1YXJlID0gRU1QVFlcbiAgICB9XG5cbiAgICAvKiByZXNldCB0aGUgNTAgbW92ZSBjb3VudGVyIGlmIGEgcGF3biBpcyBtb3ZlZCBvciBhIHBpZWNlIGlzIGNhcHR1cmVkICovXG4gICAgaWYgKG1vdmUucGllY2UgPT09IFBBV04pIHtcbiAgICAgIGhhbGZfbW92ZXMgPSAwXG4gICAgfSBlbHNlIGlmIChtb3ZlLmZsYWdzICYgKEJJVFMuQ0FQVFVSRSB8IEJJVFMuRVBfQ0FQVFVSRSkpIHtcbiAgICAgIGhhbGZfbW92ZXMgPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbGZfbW92ZXMrK1xuICAgIH1cblxuICAgIGlmICh0dXJuID09PSBCTEFDSykge1xuICAgICAgbW92ZV9udW1iZXIrK1xuICAgIH1cbiAgICB0dXJuID0gc3dhcF9jb2xvcih0dXJuKVxuICB9XG5cbiAgZnVuY3Rpb24gdW5kb19tb3ZlKCkge1xuICAgIHZhciBvbGQgPSBoaXN0b3J5LnBvcCgpXG4gICAgaWYgKG9sZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHZhciBtb3ZlID0gb2xkLm1vdmVcbiAgICBraW5ncyA9IG9sZC5raW5nc1xuICAgIHR1cm4gPSBvbGQudHVyblxuICAgIGNhc3RsaW5nID0gb2xkLmNhc3RsaW5nXG4gICAgZXBfc3F1YXJlID0gb2xkLmVwX3NxdWFyZVxuICAgIGhhbGZfbW92ZXMgPSBvbGQuaGFsZl9tb3Zlc1xuICAgIG1vdmVfbnVtYmVyID0gb2xkLm1vdmVfbnVtYmVyXG5cbiAgICB2YXIgdXMgPSB0dXJuXG4gICAgdmFyIHRoZW0gPSBzd2FwX2NvbG9yKHR1cm4pXG5cbiAgICBib2FyZFttb3ZlLmZyb21dID0gYm9hcmRbbW92ZS50b11cbiAgICBib2FyZFttb3ZlLmZyb21dLnR5cGUgPSBtb3ZlLnBpZWNlIC8vIHRvIHVuZG8gYW55IHByb21vdGlvbnNcbiAgICBib2FyZFttb3ZlLnRvXSA9IG51bGxcblxuICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5DQVBUVVJFKSB7XG4gICAgICBib2FyZFttb3ZlLnRvXSA9IHsgdHlwZTogbW92ZS5jYXB0dXJlZCwgY29sb3I6IHRoZW0gfVxuICAgIH0gZWxzZSBpZiAobW92ZS5mbGFncyAmIEJJVFMuRVBfQ0FQVFVSRSkge1xuICAgICAgdmFyIGluZGV4XG4gICAgICBpZiAodXMgPT09IEJMQUNLKSB7XG4gICAgICAgIGluZGV4ID0gbW92ZS50byAtIDE2XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IG1vdmUudG8gKyAxNlxuICAgICAgfVxuICAgICAgYm9hcmRbaW5kZXhdID0geyB0eXBlOiBQQVdOLCBjb2xvcjogdGhlbSB9XG4gICAgfVxuXG4gICAgaWYgKG1vdmUuZmxhZ3MgJiAoQklUUy5LU0lERV9DQVNUTEUgfCBCSVRTLlFTSURFX0NBU1RMRSkpIHtcbiAgICAgIHZhciBjYXN0bGluZ190bywgY2FzdGxpbmdfZnJvbVxuICAgICAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICBjYXN0bGluZ190byA9IG1vdmUudG8gKyAxXG4gICAgICAgIGNhc3RsaW5nX2Zyb20gPSBtb3ZlLnRvIC0gMVxuICAgICAgfSBlbHNlIGlmIChtb3ZlLmZsYWdzICYgQklUUy5RU0lERV9DQVNUTEUpIHtcbiAgICAgICAgY2FzdGxpbmdfdG8gPSBtb3ZlLnRvIC0gMlxuICAgICAgICBjYXN0bGluZ19mcm9tID0gbW92ZS50byArIDFcbiAgICAgIH1cblxuICAgICAgYm9hcmRbY2FzdGxpbmdfdG9dID0gYm9hcmRbY2FzdGxpbmdfZnJvbV1cbiAgICAgIGJvYXJkW2Nhc3RsaW5nX2Zyb21dID0gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBtb3ZlXG4gIH1cblxuICAvKiB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gdW5pcXVlbHkgaWRlbnRpZnkgYW1iaWd1b3VzIG1vdmVzICovXG4gIGZ1bmN0aW9uIGdldF9kaXNhbWJpZ3VhdG9yKG1vdmUsIG1vdmVzKSB7XG4gICAgdmFyIGZyb20gPSBtb3ZlLmZyb21cbiAgICB2YXIgdG8gPSBtb3ZlLnRvXG4gICAgdmFyIHBpZWNlID0gbW92ZS5waWVjZVxuXG4gICAgdmFyIGFtYmlndWl0aWVzID0gMFxuICAgIHZhciBzYW1lX3JhbmsgPSAwXG4gICAgdmFyIHNhbWVfZmlsZSA9IDBcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGFtYmlnX2Zyb20gPSBtb3Zlc1tpXS5mcm9tXG4gICAgICB2YXIgYW1iaWdfdG8gPSBtb3Zlc1tpXS50b1xuICAgICAgdmFyIGFtYmlnX3BpZWNlID0gbW92ZXNbaV0ucGllY2VcblxuICAgICAgLyogaWYgYSBtb3ZlIG9mIHRoZSBzYW1lIHBpZWNlIHR5cGUgZW5kcyBvbiB0aGUgc2FtZSB0byBzcXVhcmUsIHdlJ2xsXG4gICAgICAgKiBuZWVkIHRvIGFkZCBhIGRpc2FtYmlndWF0b3IgdG8gdGhlIGFsZ2VicmFpYyBub3RhdGlvblxuICAgICAgICovXG4gICAgICBpZiAocGllY2UgPT09IGFtYmlnX3BpZWNlICYmIGZyb20gIT09IGFtYmlnX2Zyb20gJiYgdG8gPT09IGFtYmlnX3RvKSB7XG4gICAgICAgIGFtYmlndWl0aWVzKytcblxuICAgICAgICBpZiAocmFuayhmcm9tKSA9PT0gcmFuayhhbWJpZ19mcm9tKSkge1xuICAgICAgICAgIHNhbWVfcmFuaysrXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsZShmcm9tKSA9PT0gZmlsZShhbWJpZ19mcm9tKSkge1xuICAgICAgICAgIHNhbWVfZmlsZSsrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYW1iaWd1aXRpZXMgPiAwKSB7XG4gICAgICAvKiBpZiB0aGVyZSBleGlzdHMgYSBzaW1pbGFyIG1vdmluZyBwaWVjZSBvbiB0aGUgc2FtZSByYW5rIGFuZCBmaWxlIGFzXG4gICAgICAgKiB0aGUgbW92ZSBpbiBxdWVzdGlvbiwgdXNlIHRoZSBzcXVhcmUgYXMgdGhlIGRpc2FtYmlndWF0b3JcbiAgICAgICAqL1xuICAgICAgaWYgKHNhbWVfcmFuayA+IDAgJiYgc2FtZV9maWxlID4gMCkge1xuICAgICAgICByZXR1cm4gYWxnZWJyYWljKGZyb20pXG4gICAgICB9IGVsc2UgaWYgKHNhbWVfZmlsZSA+IDApIHtcbiAgICAgICAgLyogaWYgdGhlIG1vdmluZyBwaWVjZSByZXN0cyBvbiB0aGUgc2FtZSBmaWxlLCB1c2UgdGhlIHJhbmsgc3ltYm9sIGFzIHRoZVxuICAgICAgICAgKiBkaXNhbWJpZ3VhdG9yXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gYWxnZWJyYWljKGZyb20pLmNoYXJBdCgxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogZWxzZSB1c2UgdGhlIGZpbGUgc3ltYm9sICovXG4gICAgICAgIHJldHVybiBhbGdlYnJhaWMoZnJvbSkuY2hhckF0KDApXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBmdW5jdGlvbiBpbmZlcl9waWVjZV90eXBlKHNhbikge1xuICAgIHZhciBwaWVjZV90eXBlID0gc2FuLmNoYXJBdCgwKVxuICAgIGlmIChwaWVjZV90eXBlID49ICdhJyAmJiBwaWVjZV90eXBlIDw9ICdoJykge1xuICAgICAgdmFyIG1hdGNoZXMgPSBzYW4ubWF0Y2goL1thLWhdXFxkLipbYS1oXVxcZC8pXG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgICByZXR1cm4gUEFXTlxuICAgIH1cbiAgICBwaWVjZV90eXBlID0gcGllY2VfdHlwZS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKHBpZWNlX3R5cGUgPT09ICdvJykge1xuICAgICAgcmV0dXJuIEtJTkdcbiAgICB9XG4gICAgcmV0dXJuIHBpZWNlX3R5cGVcbiAgfVxuICBmdW5jdGlvbiBhc2NpaSgpIHtcbiAgICB2YXIgcyA9ICcgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xcbidcbiAgICBmb3IgKHZhciBpID0gU1FVQVJFUy5hODsgaSA8PSBTUVVBUkVTLmgxOyBpKyspIHtcbiAgICAgIC8qIGRpc3BsYXkgdGhlIHJhbmsgKi9cbiAgICAgIGlmIChmaWxlKGkpID09PSAwKSB7XG4gICAgICAgIHMgKz0gJyAnICsgJzg3NjU0MzIxJ1tyYW5rKGkpXSArICcgfCdcbiAgICAgIH1cblxuICAgICAgLyogZW1wdHkgcGllY2UgKi9cbiAgICAgIGlmIChib2FyZFtpXSA9PSBudWxsKSB7XG4gICAgICAgIHMgKz0gJyAuICdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwaWVjZSA9IGJvYXJkW2ldLnR5cGVcbiAgICAgICAgdmFyIGNvbG9yID0gYm9hcmRbaV0uY29sb3JcbiAgICAgICAgdmFyIHN5bWJvbCA9IGNvbG9yID09PSBXSElURSA/IHBpZWNlLnRvVXBwZXJDYXNlKCkgOiBwaWVjZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIHMgKz0gJyAnICsgc3ltYm9sICsgJyAnXG4gICAgICB9XG5cbiAgICAgIGlmICgoaSArIDEpICYgMHg4OCkge1xuICAgICAgICBzICs9ICd8XFxuJ1xuICAgICAgICBpICs9IDhcbiAgICAgIH1cbiAgICB9XG4gICAgcyArPSAnICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcXG4nXG4gICAgcyArPSAnICAgICBhICBiICBjICBkICBlICBmICBnICBoXFxuJ1xuXG4gICAgcmV0dXJuIHNcbiAgfVxuXG4gIC8vIGNvbnZlcnQgYSBtb3ZlIGZyb20gU3RhbmRhcmQgQWxnZWJyYWljIE5vdGF0aW9uIChTQU4pIHRvIDB4ODggY29vcmRpbmF0ZXNcbiAgZnVuY3Rpb24gbW92ZV9mcm9tX3Nhbihtb3ZlLCBzbG9wcHkpIHtcbiAgICAvLyBzdHJpcCBvZmYgYW55IG1vdmUgZGVjb3JhdGlvbnM6IGUuZyBOZjMrPyFcbiAgICB2YXIgY2xlYW5fbW92ZSA9IHN0cmlwcGVkX3Nhbihtb3ZlKVxuXG4gICAgLy8gaWYgd2UncmUgdXNpbmcgdGhlIHNsb3BweSBwYXJzZXIgcnVuIGEgcmVnZXggdG8gZ3JhYiBwaWVjZSwgdG8sIGFuZCBmcm9tXG4gICAgLy8gdGhpcyBzaG91bGQgcGFyc2UgaW52YWxpZCBTQU4gbGlrZTogUGUyLWU0LCBSYzFjNCwgUWYzeGY3XG4gICAgaWYgKHNsb3BweSkge1xuICAgICAgdmFyIG1hdGNoZXMgPSBjbGVhbl9tb3ZlLm1hdGNoKFxuICAgICAgICAvKFtwbmJycWtQTkJSUUtdKT8oW2EtaF1bMS04XSl4Py0/KFthLWhdWzEtOF0pKFtxcmJuUVJCTl0pPy9cbiAgICAgIClcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHZhciBwaWVjZSA9IG1hdGNoZXNbMV1cbiAgICAgICAgdmFyIGZyb20gPSBtYXRjaGVzWzJdXG4gICAgICAgIHZhciB0byA9IG1hdGNoZXNbM11cbiAgICAgICAgdmFyIHByb21vdGlvbiA9IG1hdGNoZXNbNF1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHBpZWNlX3R5cGUgPSBpbmZlcl9waWVjZV90eXBlKGNsZWFuX21vdmUpXG4gICAgdmFyIG1vdmVzID0gbnVsbFxuICAgIHZhciBsZWdhbE1vdmVzID0gZ2VuZXJhdGVfbW92ZXMoe1xuICAgICAgbGVnYWw6IHRydWUsXG4gICAgICBwaWVjZTogcGllY2UgPyBwaWVjZSA6IHBpZWNlX3R5cGUsXG4gICAgfSlcbiAgICBtb3ZlcyA9IGxlZ2FsTW92ZXNcbiAgICBpZiAoc2xvcHB5KSB7XG4gICAgICB2YXIgaWxsZWdhbE1vdmVzID0gZ2VuZXJhdGVfbW92ZXMoe1xuICAgICAgICBsZWdhbDogZmFsc2UsXG4gICAgICAgIHBpZWNlOiBwaWVjZSA/IHBpZWNlIDogcGllY2VfdHlwZSxcbiAgICAgIH0pXG4gICAgICBtb3ZlcyA9IGlsbGVnYWxNb3Zlc1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gdHJ5IHRoZSBzdHJpY3QgcGFyc2VyIGZpcnN0LCB0aGVuIHRoZSBzbG9wcHkgcGFyc2VyIGlmIHJlcXVlc3RlZFxuICAgICAgLy8gYnkgdGhlIHVzZXJcbiAgICAgIGlmIChcbiAgICAgICAgY2xlYW5fbW92ZSA9PT0gc3RyaXBwZWRfc2FuKG1vdmVfdG9fc2FuKG1vdmVzW2ldLCBsZWdhbE1vdmVzKSkgfHxcbiAgICAgICAgKHNsb3BweSAmJlxuICAgICAgICAgIGNsZWFuX21vdmUgPT09IHN0cmlwcGVkX3Nhbihtb3ZlX3RvX3Nhbihtb3Zlc1tpXSwgaWxsZWdhbE1vdmVzKSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG1vdmVzW2ldXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbWF0Y2hlcyAmJlxuICAgICAgICAgICghcGllY2UgfHwgcGllY2UudG9Mb3dlckNhc2UoKSA9PSBtb3Zlc1tpXS5waWVjZSkgJiZcbiAgICAgICAgICBTUVVBUkVTW2Zyb21dID09IG1vdmVzW2ldLmZyb20gJiZcbiAgICAgICAgICBTUVVBUkVTW3RvXSA9PSBtb3Zlc1tpXS50byAmJlxuICAgICAgICAgICghcHJvbW90aW9uIHx8IHByb21vdGlvbi50b0xvd2VyQ2FzZSgpID09IG1vdmVzW2ldLnByb21vdGlvbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIG1vdmVzW2ldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIFVUSUxJVFkgRlVOQ1RJT05TXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICBmdW5jdGlvbiByYW5rKGkpIHtcbiAgICByZXR1cm4gaSA+PiA0XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlKGkpIHtcbiAgICByZXR1cm4gaSAmIDE1XG4gIH1cblxuICBmdW5jdGlvbiBhbGdlYnJhaWMoaSkge1xuICAgIHZhciBmID0gZmlsZShpKSxcbiAgICAgIHIgPSByYW5rKGkpXG4gICAgcmV0dXJuICdhYmNkZWZnaCcuc3Vic3RyaW5nKGYsIGYgKyAxKSArICc4NzY1NDMyMScuc3Vic3RyaW5nKHIsIHIgKyAxKVxuICB9XG5cbiAgZnVuY3Rpb24gc3dhcF9jb2xvcihjKSB7XG4gICAgcmV0dXJuIGMgPT09IFdISVRFID8gQkxBQ0sgOiBXSElURVxuICB9XG5cbiAgZnVuY3Rpb24gaXNfZGlnaXQoYykge1xuICAgIHJldHVybiAnMDEyMzQ1Njc4OScuaW5kZXhPZihjKSAhPT0gLTFcbiAgfVxuXG4gIC8qIHByZXR0eSA9IGV4dGVybmFsIG1vdmUgb2JqZWN0ICovXG4gIGZ1bmN0aW9uIG1ha2VfcHJldHR5KHVnbHlfbW92ZSkge1xuICAgIHZhciBtb3ZlID0gY2xvbmUodWdseV9tb3ZlKVxuICAgIG1vdmUuc2FuID0gbW92ZV90b19zYW4obW92ZSwgZ2VuZXJhdGVfbW92ZXMoeyBsZWdhbDogdHJ1ZSB9KSlcbiAgICBtb3ZlLnRvID0gYWxnZWJyYWljKG1vdmUudG8pXG4gICAgbW92ZS5mcm9tID0gYWxnZWJyYWljKG1vdmUuZnJvbSlcblxuICAgIHZhciBmbGFncyA9ICcnXG5cbiAgICBmb3IgKHZhciBmbGFnIGluIEJJVFMpIHtcbiAgICAgIGlmIChCSVRTW2ZsYWddICYgbW92ZS5mbGFncykge1xuICAgICAgICBmbGFncyArPSBGTEFHU1tmbGFnXVxuICAgICAgfVxuICAgIH1cbiAgICBtb3ZlLmZsYWdzID0gZmxhZ3NcblxuICAgIHJldHVybiBtb3ZlXG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICB2YXIgZHVwZSA9IG9iaiBpbnN0YW5jZW9mIEFycmF5ID8gW10gOiB7fVxuXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBkdXBlW3Byb3BlcnR5XSA9IGNsb25lKG9ialtwcm9wZXJ0eV0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkdXBlW3Byb3BlcnR5XSA9IG9ialtwcm9wZXJ0eV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZHVwZVxuICB9XG5cbiAgZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxuICB9XG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIERFQlVHR0lORyBVVElMSVRJRVNcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIGZ1bmN0aW9uIHBlcmZ0KGRlcHRoKSB7XG4gICAgdmFyIG1vdmVzID0gZ2VuZXJhdGVfbW92ZXMoeyBsZWdhbDogZmFsc2UgfSlcbiAgICB2YXIgbm9kZXMgPSAwXG4gICAgdmFyIGNvbG9yID0gdHVyblxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtYWtlX21vdmUobW92ZXNbaV0pXG4gICAgICBpZiAoIWtpbmdfYXR0YWNrZWQoY29sb3IpKSB7XG4gICAgICAgIGlmIChkZXB0aCAtIDEgPiAwKSB7XG4gICAgICAgICAgdmFyIGNoaWxkX25vZGVzID0gcGVyZnQoZGVwdGggLSAxKVxuICAgICAgICAgIG5vZGVzICs9IGNoaWxkX25vZGVzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZXMrK1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1bmRvX21vdmUoKVxuICAgIH1cblxuICAgIHJldHVybiBub2Rlc1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogUFVCTElDIENPTlNUQU5UUyAoaXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXM/KVxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICBXSElURTogV0hJVEUsXG4gICAgQkxBQ0s6IEJMQUNLLFxuICAgIFBBV046IFBBV04sXG4gICAgS05JR0hUOiBLTklHSFQsXG4gICAgQklTSE9QOiBCSVNIT1AsXG4gICAgUk9PSzogUk9PSyxcbiAgICBRVUVFTjogUVVFRU4sXG4gICAgS0lORzogS0lORyxcbiAgICBTUVVBUkVTOiAoZnVuY3Rpb24gKCkge1xuICAgICAgLyogZnJvbSB0aGUgRUNNQS0yNjIgc3BlYyAoc2VjdGlvbiAxMi42LjQpOlxuICAgICAgICogXCJUaGUgbWVjaGFuaWNzIG9mIGVudW1lcmF0aW5nIHRoZSBwcm9wZXJ0aWVzIC4uLiBpc1xuICAgICAgICogaW1wbGVtZW50YXRpb24gZGVwZW5kZW50XCJcbiAgICAgICAqIHNvOiBmb3IgKHZhciBzcSBpbiBTUVVBUkVTKSB7IGtleXMucHVzaChzcSk7IH0gbWlnaHQgbm90IGJlXG4gICAgICAgKiBvcmRlcmVkIGNvcnJlY3RseVxuICAgICAgICovXG4gICAgICB2YXIga2V5cyA9IFtdXG4gICAgICBmb3IgKHZhciBpID0gU1FVQVJFUy5hODsgaSA8PSBTUVVBUkVTLmgxOyBpKyspIHtcbiAgICAgICAgaWYgKGkgJiAweDg4KSB7XG4gICAgICAgICAgaSArPSA3XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBrZXlzLnB1c2goYWxnZWJyYWljKGkpKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGtleXNcbiAgICB9KSgpLFxuICAgIEZMQUdTOiBGTEFHUyxcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBQVUJMSUMgQVBJXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIGxvYWQ6IGZ1bmN0aW9uIChmZW4pIHtcbiAgICAgIHJldHVybiBsb2FkKGZlbilcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXNldCgpXG4gICAgfSxcblxuICAgIG1vdmVzOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgLyogVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgY2hlc3MgbW92ZSBpcyBpbiAweDg4IGZvcm1hdCwgYW5kXG4gICAgICAgKiBub3QgbWVhbnQgdG8gYmUgaHVtYW4tcmVhZGFibGUuICBUaGUgY29kZSBiZWxvdyBjb252ZXJ0cyB0aGUgMHg4OFxuICAgICAgICogc3F1YXJlIGNvb3JkaW5hdGVzIHRvIGFsZ2VicmFpYyBjb29yZGluYXRlcy4gIEl0IGFsc28gcHJ1bmVzIGFuXG4gICAgICAgKiB1bm5lY2Vzc2FyeSBtb3ZlIGtleXMgcmVzdWx0aW5nIGZyb20gYSB2ZXJib3NlIGNhbGwuXG4gICAgICAgKi9cblxuICAgICAgdmFyIHVnbHlfbW92ZXMgPSBnZW5lcmF0ZV9tb3ZlcyhvcHRpb25zKVxuICAgICAgdmFyIG1vdmVzID0gW11cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHVnbHlfbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLyogZG9lcyB0aGUgdXNlciB3YW50IGEgZnVsbCBtb3ZlIG9iamVjdCAobW9zdCBsaWtlbHkgbm90KSwgb3IganVzdFxuICAgICAgICAgKiBTQU5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAndmVyYm9zZScgaW4gb3B0aW9ucyAmJlxuICAgICAgICAgIG9wdGlvbnMudmVyYm9zZVxuICAgICAgICApIHtcbiAgICAgICAgICBtb3Zlcy5wdXNoKG1ha2VfcHJldHR5KHVnbHlfbW92ZXNbaV0pKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vdmVzLnB1c2goXG4gICAgICAgICAgICBtb3ZlX3RvX3Nhbih1Z2x5X21vdmVzW2ldLCBnZW5lcmF0ZV9tb3Zlcyh7IGxlZ2FsOiB0cnVlIH0pKVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW92ZXNcbiAgICB9LFxuXG4gICAgaW5fY2hlY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbl9jaGVjaygpXG4gICAgfSxcblxuICAgIGluX2NoZWNrbWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGluX2NoZWNrbWF0ZSgpXG4gICAgfSxcblxuICAgIGluX3N0YWxlbWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGluX3N0YWxlbWF0ZSgpXG4gICAgfSxcblxuICAgIGluX2RyYXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGhhbGZfbW92ZXMgPj0gMTAwIHx8XG4gICAgICAgIGluX3N0YWxlbWF0ZSgpIHx8XG4gICAgICAgIGluc3VmZmljaWVudF9tYXRlcmlhbCgpIHx8XG4gICAgICAgIGluX3RocmVlZm9sZF9yZXBldGl0aW9uKClcbiAgICAgIClcbiAgICB9LFxuXG4gICAgaW5zdWZmaWNpZW50X21hdGVyaWFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaW5zdWZmaWNpZW50X21hdGVyaWFsKClcbiAgICB9LFxuXG4gICAgaW5fdGhyZWVmb2xkX3JlcGV0aXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbl90aHJlZWZvbGRfcmVwZXRpdGlvbigpXG4gICAgfSxcblxuICAgIGdhbWVfb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaGFsZl9tb3ZlcyA+PSAxMDAgfHxcbiAgICAgICAgaW5fY2hlY2ttYXRlKCkgfHxcbiAgICAgICAgaW5fc3RhbGVtYXRlKCkgfHxcbiAgICAgICAgaW5zdWZmaWNpZW50X21hdGVyaWFsKCkgfHxcbiAgICAgICAgaW5fdGhyZWVmb2xkX3JlcGV0aXRpb24oKVxuICAgICAgKVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZV9mZW46IGZ1bmN0aW9uIChmZW4pIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZV9mZW4oZmVuKVxuICAgIH0sXG5cbiAgICBmZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZW5lcmF0ZV9mZW4oKVxuICAgIH0sXG5cbiAgICBib2FyZDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgICByb3cgPSBbXVxuXG4gICAgICBmb3IgKHZhciBpID0gU1FVQVJFUy5hODsgaSA8PSBTUVVBUkVTLmgxOyBpKyspIHtcbiAgICAgICAgaWYgKGJvYXJkW2ldID09IG51bGwpIHtcbiAgICAgICAgICByb3cucHVzaChudWxsKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdy5wdXNoKHsgdHlwZTogYm9hcmRbaV0udHlwZSwgY29sb3I6IGJvYXJkW2ldLmNvbG9yIH0pXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChpICsgMSkgJiAweDg4KSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2gocm93KVxuICAgICAgICAgIHJvdyA9IFtdXG4gICAgICAgICAgaSArPSA4XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dFxuICAgIH0sXG5cbiAgICBwZ246IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAvKiB1c2luZyB0aGUgc3BlY2lmaWNhdGlvbiBmcm9tIGh0dHA6Ly93d3cuY2hlc3NjbHViLmNvbS9oZWxwL1BHTi1zcGVjXG4gICAgICAgKiBleGFtcGxlIGZvciBodG1sIHVzYWdlOiAucGduKHsgbWF4X3dpZHRoOiA3MiwgbmV3bGluZV9jaGFyOiBcIjxiciAvPlwiIH0pXG4gICAgICAgKi9cbiAgICAgIHZhciBuZXdsaW5lID1cbiAgICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcHRpb25zLm5ld2xpbmVfY2hhciA9PT0gJ3N0cmluZydcbiAgICAgICAgICA/IG9wdGlvbnMubmV3bGluZV9jaGFyXG4gICAgICAgICAgOiAnXFxuJ1xuICAgICAgdmFyIG1heF93aWR0aCA9XG4gICAgICAgIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhfd2lkdGggPT09ICdudW1iZXInXG4gICAgICAgICAgPyBvcHRpb25zLm1heF93aWR0aFxuICAgICAgICAgIDogMFxuICAgICAgdmFyIHJlc3VsdCA9IFtdXG4gICAgICB2YXIgaGVhZGVyX2V4aXN0cyA9IGZhbHNlXG5cbiAgICAgIC8qIGFkZCB0aGUgUEdOIGhlYWRlciBoZWFkZXJybWF0aW9uICovXG4gICAgICBmb3IgKHZhciBpIGluIGhlYWRlcikge1xuICAgICAgICAvKiBUT0RPOiBvcmRlciBvZiBlbnVtZXJhdGVkIHByb3BlcnRpZXMgaW4gaGVhZGVyIG9iamVjdCBpcyBub3RcbiAgICAgICAgICogZ3VhcmFudGVlZCwgc2VlIEVDTUEtMjYyIHNwZWMgKHNlY3Rpb24gMTIuNi40KVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzdWx0LnB1c2goJ1snICsgaSArICcgXCInICsgaGVhZGVyW2ldICsgJ1wiXScgKyBuZXdsaW5lKVxuICAgICAgICBoZWFkZXJfZXhpc3RzID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoaGVhZGVyX2V4aXN0cyAmJiBoaXN0b3J5Lmxlbmd0aCkge1xuICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKVxuICAgICAgfVxuXG4gICAgICB2YXIgYXBwZW5kX2NvbW1lbnQgPSBmdW5jdGlvbiAobW92ZV9zdHJpbmcpIHtcbiAgICAgICAgdmFyIGNvbW1lbnQgPSBjb21tZW50c1tnZW5lcmF0ZV9mZW4oKV1cbiAgICAgICAgaWYgKHR5cGVvZiBjb21tZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHZhciBkZWxpbWl0ZXIgPSBtb3ZlX3N0cmluZy5sZW5ndGggPiAwID8gJyAnIDogJydcbiAgICAgICAgICBtb3ZlX3N0cmluZyA9IGAke21vdmVfc3RyaW5nfSR7ZGVsaW1pdGVyfXske2NvbW1lbnR9fWBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW92ZV9zdHJpbmdcbiAgICAgIH1cblxuICAgICAgLyogcG9wIGFsbCBvZiBoaXN0b3J5IG9udG8gcmV2ZXJzZWRfaGlzdG9yeSAqL1xuICAgICAgdmFyIHJldmVyc2VkX2hpc3RvcnkgPSBbXVxuICAgICAgd2hpbGUgKGhpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICByZXZlcnNlZF9oaXN0b3J5LnB1c2godW5kb19tb3ZlKCkpXG4gICAgICB9XG5cbiAgICAgIHZhciBtb3ZlcyA9IFtdXG4gICAgICB2YXIgbW92ZV9zdHJpbmcgPSAnJ1xuXG4gICAgICAvKiBzcGVjaWFsIGNhc2Ugb2YgYSBjb21tZW50ZWQgc3RhcnRpbmcgcG9zaXRpb24gd2l0aCBubyBtb3ZlcyAqL1xuICAgICAgaWYgKHJldmVyc2VkX2hpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG1vdmVzLnB1c2goYXBwZW5kX2NvbW1lbnQoJycpKVxuICAgICAgfVxuXG4gICAgICAvKiBidWlsZCB0aGUgbGlzdCBvZiBtb3Zlcy4gIGEgbW92ZV9zdHJpbmcgbG9va3MgbGlrZTogXCIzLiBlMyBlNlwiICovXG4gICAgICB3aGlsZSAocmV2ZXJzZWRfaGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1vdmVfc3RyaW5nID0gYXBwZW5kX2NvbW1lbnQobW92ZV9zdHJpbmcpXG4gICAgICAgIHZhciBtb3ZlID0gcmV2ZXJzZWRfaGlzdG9yeS5wb3AoKVxuXG4gICAgICAgIC8qIGlmIHRoZSBwb3NpdGlvbiBzdGFydGVkIHdpdGggYmxhY2sgdG8gbW92ZSwgc3RhcnQgUEdOIHdpdGggMS4gLi4uICovXG4gICAgICAgIGlmICghaGlzdG9yeS5sZW5ndGggJiYgbW92ZS5jb2xvciA9PT0gJ2InKSB7XG4gICAgICAgICAgbW92ZV9zdHJpbmcgPSBtb3ZlX251bWJlciArICcuIC4uLidcbiAgICAgICAgfSBlbHNlIGlmIChtb3ZlLmNvbG9yID09PSAndycpIHtcbiAgICAgICAgICAvKiBzdG9yZSB0aGUgcHJldmlvdXMgZ2VuZXJhdGVkIG1vdmVfc3RyaW5nIGlmIHdlIGhhdmUgb25lICovXG4gICAgICAgICAgaWYgKG1vdmVfc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgbW92ZXMucHVzaChtb3ZlX3N0cmluZylcbiAgICAgICAgICB9XG4gICAgICAgICAgbW92ZV9zdHJpbmcgPSBtb3ZlX251bWJlciArICcuJ1xuICAgICAgICB9XG5cbiAgICAgICAgbW92ZV9zdHJpbmcgPVxuICAgICAgICAgIG1vdmVfc3RyaW5nICtcbiAgICAgICAgICAnICcgK1xuICAgICAgICAgIG1vdmVfdG9fc2FuKG1vdmUsIGdlbmVyYXRlX21vdmVzKHsgbGVnYWw6IGZhbHNlIH0pKVxuICAgICAgICBtYWtlX21vdmUobW92ZSlcbiAgICAgIH1cblxuICAgICAgLyogYXJlIHRoZXJlIGFueSBvdGhlciBsZWZ0b3ZlciBtb3Zlcz8gKi9cbiAgICAgIGlmIChtb3ZlX3N0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgbW92ZXMucHVzaChhcHBlbmRfY29tbWVudChtb3ZlX3N0cmluZykpXG4gICAgICB9XG5cbiAgICAgIC8qIGlzIHRoZXJlIGEgcmVzdWx0PyAqL1xuICAgICAgaWYgKHR5cGVvZiBoZWFkZXIuUmVzdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtb3Zlcy5wdXNoKGhlYWRlci5SZXN1bHQpXG4gICAgICB9XG5cbiAgICAgIC8qIGhpc3Rvcnkgc2hvdWxkIGJlIGJhY2sgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHdlIHN0YXJ0ZWQgZ2VuZXJhdGluZyBQR04sXG4gICAgICAgKiBzbyBqb2luIHRvZ2V0aGVyIG1vdmVzXG4gICAgICAgKi9cbiAgICAgIGlmIChtYXhfd2lkdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKSArIG1vdmVzLmpvaW4oJyAnKVxuICAgICAgfVxuXG4gICAgICB2YXIgc3RyaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICByZXN1bHQucG9wKClcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICAvKiBOQjogdGhpcyBkb2VzIG5vdCBwcmVzZXJ2ZSBjb21tZW50IHdoaXRlc3BhY2UuICovXG4gICAgICB2YXIgd3JhcF9jb21tZW50ID0gZnVuY3Rpb24gKHdpZHRoLCBtb3ZlKSB7XG4gICAgICAgIGZvciAodmFyIHRva2VuIG9mIG1vdmUuc3BsaXQoJyAnKSkge1xuICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCArIHRva2VuLmxlbmd0aCA+IG1heF93aWR0aCkge1xuICAgICAgICAgICAgd2hpbGUgKHN0cmlwKCkpIHtcbiAgICAgICAgICAgICAgd2lkdGgtLVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSlcbiAgICAgICAgICAgIHdpZHRoID0gMFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh0b2tlbilcbiAgICAgICAgICB3aWR0aCArPSB0b2tlbi5sZW5ndGhcbiAgICAgICAgICByZXN1bHQucHVzaCgnICcpXG4gICAgICAgICAgd2lkdGgrK1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpcCgpKSB7XG4gICAgICAgICAgd2lkdGgtLVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aWR0aFxuICAgICAgfVxuXG4gICAgICAvKiB3cmFwIHRoZSBQR04gb3V0cHV0IGF0IG1heF93aWR0aCAqL1xuICAgICAgdmFyIGN1cnJlbnRfd2lkdGggPSAwXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjdXJyZW50X3dpZHRoICsgbW92ZXNbaV0ubGVuZ3RoID4gbWF4X3dpZHRoKSB7XG4gICAgICAgICAgaWYgKG1vdmVzW2ldLmluY2x1ZGVzKCd7JykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRfd2lkdGggPSB3cmFwX2NvbW1lbnQoY3VycmVudF93aWR0aCwgbW92ZXNbaV0pXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBpZiB0aGUgY3VycmVudCBtb3ZlIHdpbGwgcHVzaCBwYXN0IG1heF93aWR0aCAqL1xuICAgICAgICBpZiAoY3VycmVudF93aWR0aCArIG1vdmVzW2ldLmxlbmd0aCA+IG1heF93aWR0aCAmJiBpICE9PSAwKSB7XG4gICAgICAgICAgLyogZG9uJ3QgZW5kIHRoZSBsaW5lIHdpdGggd2hpdGVzcGFjZSAqL1xuICAgICAgICAgIGlmIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wb3AoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpXG4gICAgICAgICAgY3VycmVudF93aWR0aCA9IDBcbiAgICAgICAgfSBlbHNlIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goJyAnKVxuICAgICAgICAgIGN1cnJlbnRfd2lkdGgrK1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKG1vdmVzW2ldKVxuICAgICAgICBjdXJyZW50X3dpZHRoICs9IG1vdmVzW2ldLmxlbmd0aFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpXG4gICAgfSxcblxuICAgIGxvYWRfcGduOiBmdW5jdGlvbiAocGduLCBvcHRpb25zKSB7XG4gICAgICAvLyBhbGxvdyB0aGUgdXNlciB0byBzcGVjaWZ5IHRoZSBzbG9wcHkgbW92ZSBwYXJzZXIgdG8gd29yayBhcm91bmQgb3ZlclxuICAgICAgLy8gZGlzYW1iaWd1YXRpb24gYnVncyBpbiBGcml0eiBhbmQgQ2hlc3NiYXNlXG4gICAgICB2YXIgc2xvcHB5ID1cbiAgICAgICAgdHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnICYmICdzbG9wcHknIGluIG9wdGlvbnNcbiAgICAgICAgICA/IG9wdGlvbnMuc2xvcHB5XG4gICAgICAgICAgOiBmYWxzZVxuXG4gICAgICBmdW5jdGlvbiBtYXNrKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFwnKVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYXNfa2V5cyhvYmplY3QpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3Bnbl9oZWFkZXIoaGVhZGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBuZXdsaW5lX2NoYXIgPVxuICAgICAgICAgIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIHR5cGVvZiBvcHRpb25zLm5ld2xpbmVfY2hhciA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gb3B0aW9ucy5uZXdsaW5lX2NoYXJcbiAgICAgICAgICAgIDogJ1xccj9cXG4nXG4gICAgICAgIHZhciBoZWFkZXJfb2JqID0ge31cbiAgICAgICAgdmFyIGhlYWRlcnMgPSBoZWFkZXIuc3BsaXQobmV3IFJlZ0V4cChtYXNrKG5ld2xpbmVfY2hhcikpKVxuICAgICAgICB2YXIga2V5ID0gJydcbiAgICAgICAgdmFyIHZhbHVlID0gJydcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBoZWFkZXJzW2ldLnJlcGxhY2UoL15cXFsoW0EtWl1bQS1aYS16XSopXFxzLipcXF0kLywgJyQxJylcbiAgICAgICAgICB2YWx1ZSA9IGhlYWRlcnNbaV0ucmVwbGFjZSgvXlxcW1tBLVphLXpdK1xcc1wiKC4qKVwiXFwgKlxcXSQvLCAnJDEnKVxuICAgICAgICAgIGlmICh0cmltKGtleSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaGVhZGVyX29ialtrZXldID0gdmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGVhZGVyX29ialxuICAgICAgfVxuXG4gICAgICB2YXIgbmV3bGluZV9jaGFyID1cbiAgICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcHRpb25zLm5ld2xpbmVfY2hhciA9PT0gJ3N0cmluZydcbiAgICAgICAgICA/IG9wdGlvbnMubmV3bGluZV9jaGFyXG4gICAgICAgICAgOiAnXFxyP1xcbidcblxuICAgICAgLy8gUmVnRXhwIHRvIHNwbGl0IGhlYWRlci4gVGFrZXMgYWR2YW50YWdlIG9mIHRoZSBmYWN0IHRoYXQgaGVhZGVyIGFuZCBtb3ZldGV4dFxuICAgICAgLy8gd2lsbCBhbHdheXMgaGF2ZSBhIGJsYW5rIGxpbmUgYmV0d2VlbiB0aGVtIChpZSwgdHdvIG5ld2xpbmVfY2hhcidzKS5cbiAgICAgIC8vIFdpdGggZGVmYXVsdCBuZXdsaW5lX2NoYXIsIHdpbGwgZXF1YWw6IC9eKFxcWygoPzpcXHI/XFxuKXwuKSpcXF0pKD86XFxyP1xcbil7Mn0vXG4gICAgICB2YXIgaGVhZGVyX3JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgJ14oXFxcXFsoKD86JyArXG4gICAgICAgICAgbWFzayhuZXdsaW5lX2NoYXIpICtcbiAgICAgICAgICAnKXwuKSpcXFxcXSknICtcbiAgICAgICAgICAnKD86JyArXG4gICAgICAgICAgbWFzayhuZXdsaW5lX2NoYXIpICtcbiAgICAgICAgICAnKXsyfSdcbiAgICAgIClcblxuICAgICAgLy8gSWYgbm8gaGVhZGVyIGdpdmVuLCBiZWdpbiB3aXRoIG1vdmVzLlxuICAgICAgdmFyIGhlYWRlcl9zdHJpbmcgPSBoZWFkZXJfcmVnZXgudGVzdChwZ24pXG4gICAgICAgID8gaGVhZGVyX3JlZ2V4LmV4ZWMocGduKVsxXVxuICAgICAgICA6ICcnXG5cbiAgICAgIC8vIFB1dCB0aGUgYm9hcmQgaW4gdGhlIHN0YXJ0aW5nIHBvc2l0aW9uXG4gICAgICByZXNldCgpXG5cbiAgICAgIC8qIHBhcnNlIFBHTiBoZWFkZXIgKi9cbiAgICAgIHZhciBoZWFkZXJzID0gcGFyc2VfcGduX2hlYWRlcihoZWFkZXJfc3RyaW5nLCBvcHRpb25zKVxuICAgICAgZm9yICh2YXIga2V5IGluIGhlYWRlcnMpIHtcbiAgICAgICAgc2V0X2hlYWRlcihba2V5LCBoZWFkZXJzW2tleV1dKVxuICAgICAgfVxuXG4gICAgICAvKiBsb2FkIHRoZSBzdGFydGluZyBwb3NpdGlvbiBpbmRpY2F0ZWQgYnkgW1NldHVwICcxJ10gYW5kXG4gICAgICAgKiBbRkVOIHBvc2l0aW9uXSAqL1xuICAgICAgaWYgKGhlYWRlcnNbJ1NldFVwJ10gPT09ICcxJykge1xuICAgICAgICBpZiAoISgnRkVOJyBpbiBoZWFkZXJzICYmIGxvYWQoaGVhZGVyc1snRkVOJ10sIHRydWUpKSkge1xuICAgICAgICAgIC8vIHNlY29uZCBhcmd1bWVudCB0byBsb2FkOiBkb24ndCBjbGVhciB0aGUgaGVhZGVyc1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qIE5COiB0aGUgcmVnZXhlcyBiZWxvdyB0aGF0IGRlbGV0ZSBtb3ZlIG51bWJlcnMsIHJlY3Vyc2l2ZVxuICAgICAgICogYW5ub3RhdGlvbnMsIGFuZCBudW1lcmljIGFubm90YXRpb24gZ2x5cGhzIG1heSBhbHNvIG1hdGNoXG4gICAgICAgKiB0ZXh0IGluIGNvbW1lbnRzLiBUbyBwcmV2ZW50IHRoaXMsIHdlIHRyYW5zZm9ybSBjb21tZW50c1xuICAgICAgICogYnkgaGV4LWVuY29kaW5nIHRoZW0gaW4gcGxhY2UgYW5kIGRlY29kaW5nIHRoZW0gYWdhaW4gYWZ0ZXJcbiAgICAgICAqIHRoZSBvdGhlciB0b2tlbnMgaGF2ZSBiZWVuIGRlbGV0ZWQuXG4gICAgICAgKlxuICAgICAgICogV2hpbGUgdGhlIHNwZWMgc3RhdGVzIHRoYXQgUEdOIGZpbGVzIHNob3VsZCBiZSBBU0NJSSBlbmNvZGVkLFxuICAgICAgICogd2UgdXNlIHtlbixkZX1jb2RlVVJJQ29tcG9uZW50IGhlcmUgdG8gc3VwcG9ydCBhcmJpdHJhcnkgVVRGOFxuICAgICAgICogYXMgYSBjb252ZW5pZW5jZSBmb3IgbW9kZXJuIHVzZXJzICovXG5cbiAgICAgIHZhciB0b19oZXggPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHN0cmluZylcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAvKiBlbmNvZGVVUkkgZG9lc24ndCB0cmFuc2Zvcm0gbW9zdCBBU0NJSSBjaGFyYWN0ZXJzLFxuICAgICAgICAgICAgICogc28gd2UgaGFuZGxlIHRoZXNlIG91cnNlbHZlcyAqL1xuICAgICAgICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKSA8IDEyOFxuICAgICAgICAgICAgICA/IGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNilcbiAgICAgICAgICAgICAgOiBlbmNvZGVVUklDb21wb25lbnQoYykucmVwbGFjZSgvXFwlL2csICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuam9pbignJylcbiAgICAgIH1cblxuICAgICAgdmFyIGZyb21faGV4ID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aCA9PSAwXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogZGVjb2RlVVJJQ29tcG9uZW50KCclJyArIHN0cmluZy5tYXRjaCgvLnsxLDJ9L2cpLmpvaW4oJyUnKSlcbiAgICAgIH1cblxuICAgICAgdmFyIGVuY29kZV9jb21tZW50ID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShuZXcgUmVnRXhwKG1hc2sobmV3bGluZV9jaGFyKSwgJ2cnKSwgJyAnKVxuICAgICAgICByZXR1cm4gYHske3RvX2hleChzdHJpbmcuc2xpY2UoMSwgc3RyaW5nLmxlbmd0aCAtIDEpKX19YFxuICAgICAgfVxuXG4gICAgICB2YXIgZGVjb2RlX2NvbW1lbnQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIGlmIChzdHJpbmcuc3RhcnRzV2l0aCgneycpICYmIHN0cmluZy5lbmRzV2l0aCgnfScpKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21faGV4KHN0cmluZy5zbGljZSgxLCBzdHJpbmcubGVuZ3RoIC0gMSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogZGVsZXRlIGhlYWRlciB0byBnZXQgdGhlIG1vdmVzICovXG4gICAgICB2YXIgbXMgPSBwZ25cbiAgICAgICAgLnJlcGxhY2UoaGVhZGVyX3N0cmluZywgJycpXG4gICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgIC8qIGVuY29kZSBjb21tZW50cyBzbyB0aGV5IGRvbid0IGdldCBkZWxldGVkIGJlbG93ICovXG4gICAgICAgICAgbmV3IFJlZ0V4cChgKFxce1tefV0qXFx9KSs/fDsoW14ke21hc2sobmV3bGluZV9jaGFyKX1dKilgLCAnZycpLFxuICAgICAgICAgIGZ1bmN0aW9uIChtYXRjaCwgYnJhY2tldCwgc2VtaWNvbG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYnJhY2tldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gZW5jb2RlX2NvbW1lbnQoYnJhY2tldClcbiAgICAgICAgICAgICAgOiAnICcgKyBlbmNvZGVfY29tbWVudChgeyR7c2VtaWNvbG9uLnNsaWNlKDEpfX1gKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKG1hc2sobmV3bGluZV9jaGFyKSwgJ2cnKSwgJyAnKVxuXG4gICAgICAvKiBkZWxldGUgcmVjdXJzaXZlIGFubm90YXRpb24gdmFyaWF0aW9ucyAqL1xuICAgICAgdmFyIHJhdl9yZWdleCA9IC8oXFwoW15cXChcXCldK1xcKSkrPy9nXG4gICAgICB3aGlsZSAocmF2X3JlZ2V4LnRlc3QobXMpKSB7XG4gICAgICAgIG1zID0gbXMucmVwbGFjZShyYXZfcmVnZXgsICcnKVxuICAgICAgfVxuXG4gICAgICAvKiBkZWxldGUgbW92ZSBudW1iZXJzICovXG4gICAgICBtcyA9IG1zLnJlcGxhY2UoL1xcZCtcXC4oXFwuXFwuKT8vZywgJycpXG5cbiAgICAgIC8qIGRlbGV0ZSAuLi4gaW5kaWNhdGluZyBibGFjayB0byBtb3ZlICovXG4gICAgICBtcyA9IG1zLnJlcGxhY2UoL1xcLlxcLlxcLi9nLCAnJylcblxuICAgICAgLyogZGVsZXRlIG51bWVyaWMgYW5ub3RhdGlvbiBnbHlwaHMgKi9cbiAgICAgIG1zID0gbXMucmVwbGFjZSgvXFwkXFxkKy9nLCAnJylcblxuICAgICAgLyogdHJpbSBhbmQgZ2V0IGFycmF5IG9mIG1vdmVzICovXG4gICAgICB2YXIgbW92ZXMgPSB0cmltKG1zKS5zcGxpdChuZXcgUmVnRXhwKC9cXHMrLykpXG5cbiAgICAgIC8qIGRlbGV0ZSBlbXB0eSBlbnRyaWVzICovXG4gICAgICBtb3ZlcyA9IG1vdmVzLmpvaW4oJywnKS5yZXBsYWNlKC8sLCsvZywgJywnKS5zcGxpdCgnLCcpXG4gICAgICB2YXIgbW92ZSA9ICcnXG5cbiAgICAgIGZvciAodmFyIGhhbGZfbW92ZSA9IDA7IGhhbGZfbW92ZSA8IG1vdmVzLmxlbmd0aCAtIDE7IGhhbGZfbW92ZSsrKSB7XG4gICAgICAgIHZhciBjb21tZW50ID0gZGVjb2RlX2NvbW1lbnQobW92ZXNbaGFsZl9tb3ZlXSlcbiAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbW1lbnRzW2dlbmVyYXRlX2ZlbigpXSA9IGNvbW1lbnRcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIG1vdmUgPSBtb3ZlX2Zyb21fc2FuKG1vdmVzW2hhbGZfbW92ZV0sIHNsb3BweSlcblxuICAgICAgICAvKiBtb3ZlIG5vdCBwb3NzaWJsZSEgKGRvbid0IGNsZWFyIHRoZSBib2FyZCB0byBleGFtaW5lIHRvIHNob3cgdGhlXG4gICAgICAgICAqIGxhdGVzdCB2YWxpZCBwb3NpdGlvbilcbiAgICAgICAgICovXG4gICAgICAgIGlmIChtb3ZlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYWtlX21vdmUobW92ZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb21tZW50ID0gZGVjb2RlX2NvbW1lbnQobW92ZXNbbW92ZXMubGVuZ3RoIC0gMV0pXG4gICAgICBpZiAoY29tbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbW1lbnRzW2dlbmVyYXRlX2ZlbigpXSA9IGNvbW1lbnRcbiAgICAgICAgbW92ZXMucG9wKClcbiAgICAgIH1cblxuICAgICAgLyogZXhhbWluZSBsYXN0IG1vdmUgKi9cbiAgICAgIG1vdmUgPSBtb3Zlc1ttb3Zlcy5sZW5ndGggLSAxXVxuICAgICAgaWYgKFBPU1NJQkxFX1JFU1VMVFMuaW5kZXhPZihtb3ZlKSA+IC0xKSB7XG4gICAgICAgIGlmIChoYXNfa2V5cyhoZWFkZXIpICYmIHR5cGVvZiBoZWFkZXIuUmVzdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHNldF9oZWFkZXIoWydSZXN1bHQnLCBtb3ZlXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW92ZSA9IG1vdmVfZnJvbV9zYW4obW92ZSwgc2xvcHB5KVxuICAgICAgICBpZiAobW92ZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFrZV9tb3ZlKG1vdmUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSxcblxuICAgIGhlYWRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNldF9oZWFkZXIoYXJndW1lbnRzKVxuICAgIH0sXG5cbiAgICBhc2NpaTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFzY2lpKClcbiAgICB9LFxuXG4gICAgdHVybjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHR1cm5cbiAgICB9LFxuXG4gICAgbW92ZTogZnVuY3Rpb24gKG1vdmUsIG9wdGlvbnMpIHtcbiAgICAgIC8qIFRoZSBtb3ZlIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgd2l0aCBpbiB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgICAgKlxuICAgICAgICogLm1vdmUoJ054YjcnKSAgICAgIDwtIHdoZXJlICdtb3ZlJyBpcyBhIGNhc2Utc2Vuc2l0aXZlIFNBTiBzdHJpbmdcbiAgICAgICAqXG4gICAgICAgKiAubW92ZSh7IGZyb206ICdoNycsIDwtIHdoZXJlIHRoZSAnbW92ZScgaXMgYSBtb3ZlIG9iamVjdCAoYWRkaXRpb25hbFxuICAgICAgICogICAgICAgICB0byA6J2g4JywgICAgICBmaWVsZHMgYXJlIGlnbm9yZWQpXG4gICAgICAgKiAgICAgICAgIHByb21vdGlvbjogJ3EnLFxuICAgICAgICogICAgICB9KVxuICAgICAgICovXG5cbiAgICAgIC8vIGFsbG93IHRoZSB1c2VyIHRvIHNwZWNpZnkgdGhlIHNsb3BweSBtb3ZlIHBhcnNlciB0byB3b3JrIGFyb3VuZCBvdmVyXG4gICAgICAvLyBkaXNhbWJpZ3VhdGlvbiBidWdzIGluIEZyaXR6IGFuZCBDaGVzc2Jhc2VcbiAgICAgIHZhciBzbG9wcHkgPVxuICAgICAgICB0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3Nsb3BweScgaW4gb3B0aW9uc1xuICAgICAgICAgID8gb3B0aW9ucy5zbG9wcHlcbiAgICAgICAgICA6IGZhbHNlXG5cbiAgICAgIHZhciBtb3ZlX29iaiA9IG51bGxcblxuICAgICAgaWYgKHR5cGVvZiBtb3ZlID09PSAnc3RyaW5nJykge1xuICAgICAgICBtb3ZlX29iaiA9IG1vdmVfZnJvbV9zYW4obW92ZSwgc2xvcHB5KVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbW92ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIG1vdmVzID0gZ2VuZXJhdGVfbW92ZXMoKVxuXG4gICAgICAgIC8qIGNvbnZlcnQgdGhlIHByZXR0eSBtb3ZlIG9iamVjdCB0byBhbiB1Z2x5IG1vdmUgb2JqZWN0ICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG1vdmUuZnJvbSA9PT0gYWxnZWJyYWljKG1vdmVzW2ldLmZyb20pICYmXG4gICAgICAgICAgICBtb3ZlLnRvID09PSBhbGdlYnJhaWMobW92ZXNbaV0udG8pICYmXG4gICAgICAgICAgICAoISgncHJvbW90aW9uJyBpbiBtb3Zlc1tpXSkgfHxcbiAgICAgICAgICAgICAgbW92ZS5wcm9tb3Rpb24gPT09IG1vdmVzW2ldLnByb21vdGlvbilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG1vdmVfb2JqID0gbW92ZXNbaV1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qIGZhaWxlZCB0byBmaW5kIG1vdmUgKi9cbiAgICAgIGlmICghbW92ZV9vYmopIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgLyogbmVlZCB0byBtYWtlIGEgY29weSBvZiBtb3ZlIGJlY2F1c2Ugd2UgY2FuJ3QgZ2VuZXJhdGUgU0FOIGFmdGVyIHRoZVxuICAgICAgICogbW92ZSBpcyBtYWRlXG4gICAgICAgKi9cbiAgICAgIHZhciBwcmV0dHlfbW92ZSA9IG1ha2VfcHJldHR5KG1vdmVfb2JqKVxuXG4gICAgICBtYWtlX21vdmUobW92ZV9vYmopXG5cbiAgICAgIHJldHVybiBwcmV0dHlfbW92ZVxuICAgIH0sXG5cbiAgICB1bmRvOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbW92ZSA9IHVuZG9fbW92ZSgpXG4gICAgICByZXR1cm4gbW92ZSA/IG1ha2VfcHJldHR5KG1vdmUpIDogbnVsbFxuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNsZWFyKClcbiAgICB9LFxuXG4gICAgcHV0OiBmdW5jdGlvbiAocGllY2UsIHNxdWFyZSkge1xuICAgICAgcmV0dXJuIHB1dChwaWVjZSwgc3F1YXJlKVxuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uIChzcXVhcmUpIHtcbiAgICAgIHJldHVybiBnZXQoc3F1YXJlKVxuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uIChzcXVhcmUpIHtcbiAgICAgIHJldHVybiByZW1vdmUoc3F1YXJlKVxuICAgIH0sXG5cbiAgICBwZXJmdDogZnVuY3Rpb24gKGRlcHRoKSB7XG4gICAgICByZXR1cm4gcGVyZnQoZGVwdGgpXG4gICAgfSxcblxuICAgIHNxdWFyZV9jb2xvcjogZnVuY3Rpb24gKHNxdWFyZSkge1xuICAgICAgaWYgKHNxdWFyZSBpbiBTUVVBUkVTKSB7XG4gICAgICAgIHZhciBzcV8weDg4ID0gU1FVQVJFU1tzcXVhcmVdXG4gICAgICAgIHJldHVybiAocmFuayhzcV8weDg4KSArIGZpbGUoc3FfMHg4OCkpICUgMiA9PT0gMCA/ICdsaWdodCcgOiAnZGFyaydcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9LFxuXG4gICAgaGlzdG9yeTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZXZlcnNlZF9oaXN0b3J5ID0gW11cbiAgICAgIHZhciBtb3ZlX2hpc3RvcnkgPSBbXVxuICAgICAgdmFyIHZlcmJvc2UgPVxuICAgICAgICB0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgJ3ZlcmJvc2UnIGluIG9wdGlvbnMgJiZcbiAgICAgICAgb3B0aW9ucy52ZXJib3NlXG5cbiAgICAgIHdoaWxlIChoaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV2ZXJzZWRfaGlzdG9yeS5wdXNoKHVuZG9fbW92ZSgpKVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAocmV2ZXJzZWRfaGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBtb3ZlID0gcmV2ZXJzZWRfaGlzdG9yeS5wb3AoKVxuICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgIG1vdmVfaGlzdG9yeS5wdXNoKG1ha2VfcHJldHR5KG1vdmUpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vdmVfaGlzdG9yeS5wdXNoKG1vdmVfdG9fc2FuKG1vdmUsIGdlbmVyYXRlX21vdmVzKHsgbGVnYWw6IHRydWUgfSkpKVxuICAgICAgICB9XG4gICAgICAgIG1ha2VfbW92ZShtb3ZlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW92ZV9oaXN0b3J5XG4gICAgfSxcblxuICAgIGdldF9jb21tZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY29tbWVudHNbZ2VuZXJhdGVfZmVuKCldXG4gICAgfSxcblxuICAgIHNldF9jb21tZW50OiBmdW5jdGlvbiAoY29tbWVudCkge1xuICAgICAgY29tbWVudHNbZ2VuZXJhdGVfZmVuKCldID0gY29tbWVudC5yZXBsYWNlKCd7JywgJ1snKS5yZXBsYWNlKCd9JywgJ10nKVxuICAgIH0sXG5cbiAgICBkZWxldGVfY29tbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbW1lbnQgPSBjb21tZW50c1tnZW5lcmF0ZV9mZW4oKV1cbiAgICAgIGRlbGV0ZSBjb21tZW50c1tnZW5lcmF0ZV9mZW4oKV1cbiAgICAgIHJldHVybiBjb21tZW50XG4gICAgfSxcblxuICAgIGdldF9jb21tZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgcHJ1bmVfY29tbWVudHMoKVxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbW1lbnRzKS5tYXAoZnVuY3Rpb24gKGZlbikge1xuICAgICAgICByZXR1cm4geyBmZW46IGZlbiwgY29tbWVudDogY29tbWVudHNbZmVuXSB9XG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBkZWxldGVfY29tbWVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHBydW5lX2NvbW1lbnRzKClcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjb21tZW50cykubWFwKGZ1bmN0aW9uIChmZW4pIHtcbiAgICAgICAgdmFyIGNvbW1lbnQgPSBjb21tZW50c1tmZW5dXG4gICAgICAgIGRlbGV0ZSBjb21tZW50c1tmZW5dXG4gICAgICAgIHJldHVybiB7IGZlbjogZmVuLCBjb21tZW50OiBjb21tZW50IH1cbiAgICAgIH0pXG4gICAgfSxcbiAgfVxufVxuXG4vKiBleHBvcnQgQ2hlc3Mgb2JqZWN0IGlmIHVzaW5nIG5vZGUgb3IgYW55IG90aGVyIENvbW1vbkpTIGNvbXBhdGlibGVcbiAqIGVudmlyb25tZW50ICovXG5pZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSBleHBvcnRzLkNoZXNzID0gQ2hlc3Ncbi8qIGV4cG9ydCBDaGVzcyBvYmplY3QgZm9yIGFueSBSZXF1aXJlSlMgY29tcGF0aWJsZSBlbnZpcm9ubWVudCAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnKVxuICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBDaGVzc1xuICB9KVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/chess.js/chess.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! ../../compiled/process */ \"(app-client)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvcHJvY2Vzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EscUNBQXFDLHFCQUFNLGlGQUFpRixxQkFBTSxrRUFBa0UscUJBQU0sV0FBVyxtQkFBTyxDQUFDLGlHQUF3Qjs7QUFFclAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvcHJvY2Vzcy5qcz83MTAyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9nbG9iYWxfcHJvY2VzcywgX2dsb2JhbF9wcm9jZXNzMTtcbm1vZHVsZS5leHBvcnRzID0gKChfZ2xvYmFsX3Byb2Nlc3MgPSBnbG9iYWwucHJvY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxfcHJvY2Vzcy5lbnYpICYmIHR5cGVvZiAoKF9nbG9iYWxfcHJvY2VzczEgPSBnbG9iYWwucHJvY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxfcHJvY2VzczEuZW52KSA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbC5wcm9jZXNzIDogcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVkL3Byb2Nlc3NcIik7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2Nlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=D%3A%5Cpersonal%20projects%5C7.%20chess%20chain%5Cchess-chain%5Cfrontend%5Csrc%5Ccomponents%5CChessBoard.tsx&server=false!":
/*!****************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=D%3A%5Cpersonal%20projects%5C7.%20chess%20chain%5Cchess-chain%5Cfrontend%5Csrc%5Ccomponents%5CChessBoard.tsx&server=false! ***!
  \****************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/ChessBoard.tsx */ \"(app-client)/./src/components/ChessBoard.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1mbGlnaHQtY2xpZW50LWVudHJ5LWxvYWRlci5qcz9tb2R1bGVzPUQlM0ElNUNwZXJzb25hbCUyMHByb2plY3RzJTVDNy4lMjBjaGVzcyUyMGNoYWluJTVDY2hlc3MtY2hhaW4lNUNmcm9udGVuZCU1Q3NyYyU1Q2NvbXBvbmVudHMlNUNDaGVzc0JvYXJkLnRzeCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/MzMzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXHBlcnNvbmFsIHByb2plY3RzXFxcXDcuIGNoZXNzIGNoYWluXFxcXGNoZXNzLWNoYWluXFxcXGZyb250ZW5kXFxcXHNyY1xcXFxjb21wb25lbnRzXFxcXENoZXNzQm9hcmQudHN4XCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=D%3A%5Cpersonal%20projects%5C7.%20chess%20chain%5Cchess-chain%5Cfrontend%5Csrc%5Ccomponents%5CChessBoard.tsx&server=false!\n"));

/***/ }),

/***/ "(app-client)/./src/components/ChessBoard.tsx":
/*!***************************************!*\
  !*** ./src/components/ChessBoard.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var chess_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! chess.js */ \"(app-client)/./node_modules/chess.js/chess.js\");\n/* harmony import */ var chess_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(chess_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_chessboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-chessboard */ \"(app-client)/./node_modules/react-chessboard/dist/index.esm.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction ChessBoard() {\n    _s();\n    // @ts-ignore: someting in chess libarray\n    const [game, setGame] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new (chess_js__WEBPACK_IMPORTED_MODULE_2___default())());\n    const [gameHistroy, setGameHistroy] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    function makeAMove(move) {\n        const gameCopy = {\n            ...game\n        };\n        const result = gameCopy.move(move);\n        setGame(gameCopy);\n        return result; // null if the move was illegal, the move object if the move was legal\n    }\n    function makeRandomMove() {\n        const possibleMoves = game.moves();\n        if (game.game_over() || game.in_draw() || possibleMoves.length === 0) return; // exit if the game is over\n        const randomIndex = Math.floor(Math.random() * possibleMoves.length);\n        makeAMove(possibleMoves[randomIndex]);\n    }\n    function onDrop(sourceSquare, targetSquare) {\n        const move = makeAMove({\n            from: sourceSquare,\n            to: targetSquare,\n            promotion: \"q\"\n        });\n        // illegal move\n        if (move === null) return false;\n        setTimeout(makeRandomMove, 200);\n        return true;\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setGameHistroy(game.history());\n        console.log(\"==============\");\n        console.log(game.turn());\n        console.log(game.pgn({\n            max_width: 1\n        }));\n        console.log(typeof game.pgn({\n            newline: \"\\n\"\n        }));\n    // console.log(\"in_check\",game.in_check());\n    // console.log(\"in_checkmate\",game.in_checkmate());\n    // console.log(\"in_stalemate\",game.in_stalemate());\n    // console.log(\"in_draw\",game.in_draw());\n    // // Returns true if the game has ended via checkmate, stalemate, draw, threefold repetition, or insufficient material. Otherwise, returns false.\n    // console.log(\"gameover\",game.game_over());\n    }, [\n        game\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-[30rem] flex\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_chessboard__WEBPACK_IMPORTED_MODULE_3__.Chessboard, {\n                position: game.fen(),\n                onPieceDrop: onDrop\n            }, void 0, false, {\n                fileName: \"D:\\\\personal projects\\\\7. chess chain\\\\chess-chain\\\\frontend\\\\src\\\\components\\\\ChessBoard.tsx\",\n                lineNumber: 63,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col\",\n                children: gameHistroy && gameHistroy.map((item, key)=>{\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        children: item\n                    }, void 0, false, {\n                        fileName: \"D:\\\\personal projects\\\\7. chess chain\\\\chess-chain\\\\frontend\\\\src\\\\components\\\\ChessBoard.tsx\",\n                        lineNumber: 68,\n                        columnNumber: 25\n                    }, this);\n                })\n            }, void 0, false, {\n                fileName: \"D:\\\\personal projects\\\\7. chess chain\\\\chess-chain\\\\frontend\\\\src\\\\components\\\\ChessBoard.tsx\",\n                lineNumber: 65,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\personal projects\\\\7. chess chain\\\\chess-chain\\\\frontend\\\\src\\\\components\\\\ChessBoard.tsx\",\n        lineNumber: 62,\n        columnNumber: 9\n    }, this);\n}\n_s(ChessBoard, \"YpecHEU7at79UIWh+048XZVNt8w=\");\n_c = ChessBoard;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ChessBoard);\nvar _c;\n$RefreshReg$(_c, \"ChessBoard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vc3JjL2NvbXBvbmVudHMvQ2hlc3NCb2FyZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQ2tEO0FBQ3JCO0FBQ2lCO0FBRzlDLFNBQVNLOztJQUNMLHlDQUF5QztJQUN6QyxNQUFNLENBQUNDLE1BQU1DLFFBQVEsR0FBR0wsK0NBQVFBLENBQUMsSUFBSUMsaURBQUtBO0lBQzFDLE1BQU0sQ0FBQ0ssYUFBYUMsZUFBZSxHQUFHUCwrQ0FBUUEsQ0FBQyxFQUFFO0lBRWpELFNBQVNRLFVBQVVDLElBQWdEO1FBQy9ELE1BQU1DLFdBQVc7WUFBRSxHQUFHTixJQUFJO1FBQUM7UUFDM0IsTUFBTU8sU0FBU0QsU0FBU0QsS0FBS0E7UUFDN0JKLFFBQVFLO1FBQ1IsT0FBT0MsUUFBUSxzRUFBc0U7SUFDekY7SUFFQSxTQUFTQztRQUNMLE1BQU1DLGdCQUFnQlQsS0FBS1U7UUFDM0IsSUFBSVYsS0FBS1csZUFBZVgsS0FBS1ksYUFBYUgsY0FBY0ksV0FBVyxHQUMvRCxRQUFRLDJCQUEyQjtRQUN2QyxNQUFNQyxjQUFjQyxLQUFLQyxNQUFNRCxLQUFLRSxXQUFXUixjQUFjSTtRQUM3RFQsVUFBVUssYUFBYSxDQUFDSyxZQUFZO0lBQ3hDO0lBRUEsU0FBU0ksT0FBT0MsWUFBaUIsRUFBRUMsWUFBaUI7UUFDaEQsTUFBTWYsT0FBT0QsVUFBVTtZQUNuQmlCLE1BQU1GO1lBQ05HLElBQUlGO1lBQ0pHLFdBQVc7UUFDZjtRQUVBLGVBQWU7UUFDZixJQUFJbEIsU0FBUyxNQUFNLE9BQU87UUFDMUJtQixXQUFXaEIsZ0JBQWdCO1FBQzNCLE9BQU87SUFDWDtJQUVBYixnREFBU0EsQ0FBQztRQUNOUSxlQUFlSCxLQUFLeUI7UUFFcEJDLFFBQVFDLElBQUk7UUFDWkQsUUFBUUMsSUFBSTNCLEtBQUs0QjtRQUNqQkYsUUFBUUMsSUFBSzNCLEtBQUs2QixJQUFJO1lBQUVDLFdBQVc7UUFBRTtRQUNyQ0osUUFBUUMsSUFBSyxPQUFPM0IsS0FBSzZCLElBQUk7WUFBRUUsU0FBUztRQUFLO0lBRTdDLDJDQUEyQztJQUMzQyxtREFBbUQ7SUFDbkQsbURBQW1EO0lBQ25ELHlDQUF5QztJQUV6QyxrSkFBa0o7SUFDbEosNENBQTRDO0lBSWhELEdBQUc7UUFBQy9CO0tBQUs7SUFHVCxxQkFDSSw4REFBQ2dDO1FBQUlDLFdBQVU7OzBCQUNYLDhEQUFDbkMsd0RBQVVBO2dCQUFDb0MsVUFBVWxDLEtBQUttQztnQkFBT0MsYUFBYWxCOzs7Ozs7MEJBRS9DLDhEQUFDYztnQkFBSUMsV0FBVTswQkFDVi9CLGVBQWVBLFlBQVltQyxJQUFJLENBQUNDLE1BQU1DO29CQUNuQyxxQkFDSSw4REFBQ0M7a0NBQU1GOzs7Ozs7Z0JBRWY7Ozs7Ozs7Ozs7OztBQUloQjtHQW5FU3ZDO0tBQUFBO0FBcUVULCtEQUFlQSxVQUFVQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0NoZXNzQm9hcmQudHN4P2VmOTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcclxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IENoZXNzIGZyb20gXCJjaGVzcy5qc1wiO1xyXG5pbXBvcnQgeyBDaGVzc2JvYXJkIH0gZnJvbSBcInJlYWN0LWNoZXNzYm9hcmRcIjtcclxuXHJcblxyXG5mdW5jdGlvbiBDaGVzc0JvYXJkKCkge1xyXG4gICAgLy8gQHRzLWlnbm9yZTogc29tZXRpbmcgaW4gY2hlc3MgbGliYXJyYXlcclxuICAgIGNvbnN0IFtnYW1lLCBzZXRHYW1lXSA9IHVzZVN0YXRlKG5ldyBDaGVzcygpKTtcclxuICAgIGNvbnN0IFtnYW1lSGlzdHJveSwgc2V0R2FtZUhpc3Ryb3ldID0gdXNlU3RhdGUoW10pXHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIG1ha2VBTW92ZShtb3ZlOiB7IGZyb206IGFueTsgdG86IGFueTsgcHJvbW90aW9uOiBzdHJpbmc7IH0pIHtcclxuICAgICAgICBjb25zdCBnYW1lQ29weSA9IHsgLi4uZ2FtZSB9O1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGdhbWVDb3B5Lm1vdmUobW92ZSk7XHJcbiAgICAgICAgc2V0R2FtZShnYW1lQ29weSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDsgLy8gbnVsbCBpZiB0aGUgbW92ZSB3YXMgaWxsZWdhbCwgdGhlIG1vdmUgb2JqZWN0IGlmIHRoZSBtb3ZlIHdhcyBsZWdhbFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VSYW5kb21Nb3ZlKCkge1xyXG4gICAgICAgIGNvbnN0IHBvc3NpYmxlTW92ZXMgPSBnYW1lLm1vdmVzKCk7XHJcbiAgICAgICAgaWYgKGdhbWUuZ2FtZV9vdmVyKCkgfHwgZ2FtZS5pbl9kcmF3KCkgfHwgcG9zc2libGVNb3Zlcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gZXhpdCBpZiB0aGUgZ2FtZSBpcyBvdmVyXHJcbiAgICAgICAgY29uc3QgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3NzaWJsZU1vdmVzLmxlbmd0aCk7XHJcbiAgICAgICAgbWFrZUFNb3ZlKHBvc3NpYmxlTW92ZXNbcmFuZG9tSW5kZXhdKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbkRyb3Aoc291cmNlU3F1YXJlOiBhbnksIHRhcmdldFNxdWFyZTogYW55KSB7XHJcbiAgICAgICAgY29uc3QgbW92ZSA9IG1ha2VBTW92ZSh7XHJcbiAgICAgICAgICAgIGZyb206IHNvdXJjZVNxdWFyZSxcclxuICAgICAgICAgICAgdG86IHRhcmdldFNxdWFyZSxcclxuICAgICAgICAgICAgcHJvbW90aW9uOiBcInFcIiwgLy8gYWx3YXlzIHByb21vdGUgdG8gYSBxdWVlbiBmb3IgZXhhbXBsZSBzaW1wbGljaXR5XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGlsbGVnYWwgbW92ZVxyXG4gICAgICAgIGlmIChtb3ZlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgc2V0VGltZW91dChtYWtlUmFuZG9tTW92ZSwgMjAwKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNldEdhbWVIaXN0cm95KGdhbWUuaGlzdG9yeSgpKVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PT09PT09XCIpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGdhbWUudHVybigpKTtcclxuICAgICAgICBjb25zb2xlLmxvZyggZ2FtZS5wZ24oeyBtYXhfd2lkdGg6IDEgfSkpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCB0eXBlb2YgZ2FtZS5wZ24oeyBuZXdsaW5lOiAnXFxuJyB9KSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJpbl9jaGVja1wiLGdhbWUuaW5fY2hlY2soKSk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJpbl9jaGVja21hdGVcIixnYW1lLmluX2NoZWNrbWF0ZSgpKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImluX3N0YWxlbWF0ZVwiLGdhbWUuaW5fc3RhbGVtYXRlKCkpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiaW5fZHJhd1wiLGdhbWUuaW5fZHJhdygpKTtcclxuXHJcbiAgICAgICAgLy8gLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBnYW1lIGhhcyBlbmRlZCB2aWEgY2hlY2ttYXRlLCBzdGFsZW1hdGUsIGRyYXcsIHRocmVlZm9sZCByZXBldGl0aW9uLCBvciBpbnN1ZmZpY2llbnQgbWF0ZXJpYWwuIE90aGVyd2lzZSwgcmV0dXJucyBmYWxzZS5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImdhbWVvdmVyXCIsZ2FtZS5nYW1lX292ZXIoKSk7XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIFxyXG4gICAgfSwgW2dhbWVdKVxyXG4gICAgXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctWzMwcmVtXSBmbGV4XCI+XHJcbiAgICAgICAgICAgIDxDaGVzc2JvYXJkIHBvc2l0aW9uPXtnYW1lLmZlbigpfSBvblBpZWNlRHJvcD17b25Ecm9wfVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2xcIj5cclxuICAgICAgICAgICAgICAgIHtnYW1lSGlzdHJveSAmJiBnYW1lSGlzdHJveS5tYXAoKGl0ZW0sIGtleSk9PntcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj57aXRlbX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDaGVzc0JvYXJkIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJDaGVzcyIsIkNoZXNzYm9hcmQiLCJDaGVzc0JvYXJkIiwiZ2FtZSIsInNldEdhbWUiLCJnYW1lSGlzdHJveSIsInNldEdhbWVIaXN0cm95IiwibWFrZUFNb3ZlIiwibW92ZSIsImdhbWVDb3B5IiwicmVzdWx0IiwibWFrZVJhbmRvbU1vdmUiLCJwb3NzaWJsZU1vdmVzIiwibW92ZXMiLCJnYW1lX292ZXIiLCJpbl9kcmF3IiwibGVuZ3RoIiwicmFuZG9tSW5kZXgiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJvbkRyb3AiLCJzb3VyY2VTcXVhcmUiLCJ0YXJnZXRTcXVhcmUiLCJmcm9tIiwidG8iLCJwcm9tb3Rpb24iLCJzZXRUaW1lb3V0IiwiaGlzdG9yeSIsImNvbnNvbGUiLCJsb2ciLCJ0dXJuIiwicGduIiwibWF4X3dpZHRoIiwibmV3bGluZSIsImRpdiIsImNsYXNzTmFtZSIsInBvc2l0aW9uIiwiZmVuIiwib25QaWVjZURyb3AiLCJtYXAiLCJpdGVtIiwia2V5Iiwic3BhbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./src/components/ChessBoard.tsx\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBLFlBQVksT0FBTyxnQkFBZ0IsbUJBQW1CLE1BQU0sTUFBTSw0QkFBNEIsbURBQW1ELCtCQUErQixxREFBcUQsWUFBWSxJQUFJLG1DQUFtQyxhQUFhLEtBQUssb0JBQW9CLFNBQVMsbUJBQW1CLElBQUkscUNBQXFDLGVBQWUsS0FBSyx1QkFBdUIsU0FBUyx1QkFBdUIsSUFBSSx1QkFBdUIsbUJBQW1CLHVCQUF1QiwyQ0FBMkMsYUFBYSx1QkFBdUIsSUFBSSxjQUFjLFNBQVMsSUFBSSx3QkFBd0IsU0FBUywwQkFBMEIsNEJBQTRCLHFCQUFxQix1QkFBdUIsZ0RBQWdELGVBQWUsdUJBQXVCLElBQUksWUFBWSxTQUFTLElBQUksc0JBQXNCLFNBQVMsd0JBQXdCLFNBQVMsWUFBWSxNQUFNLFNBQVMsMkJBQTJCLFdBQVcsT0FBTyxRQUFRLGFBQWEsY0FBYyxLQUFLLEtBQUssYUFBYSxjQUFjLHNCQUFzQixNQUFNLE9BQU8sa0NBQWtDLE9BQU8sZUFBZSxTQUFTLElBQUksS0FBSyxhQUFhLE1BQU0sWUFBWSxLQUFLLFdBQVcsT0FBTyxRQUFRLG1CQUFtQix1QkFBdUIsb0NBQW9DLHVCQUF1QixZQUFZLG1CQUFtQixLQUFLLHFCQUFxQixzQkFBc0IscUJBQXFCLHlCQUF5QixtQkFBbUIsV0FBVyxhQUFhLDhCQUE4QixpQ0FBaUMsa0JBQWtCLGVBQWUsU0FBUyxVQUFVLGFBQWEsY0FBYyxpQkFBaUIsVUFBVSxtQkFBbUIsWUFBWSxXQUFXLHNCQUFzQiwwQkFBMEIsWUFBWSx1QkFBdUIsMkJBQTJCLHdCQUF3QixVQUFVLHNCQUFzQixxREFBcUQsaUJBQWlCLFdBQVcsb0JBQW9CLG1EQUFtRCxtQkFBbUIsWUFBWSxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSywrQkFBK0IsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzPzdiOWIiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezIyOTpmdW5jdGlvbihlKXt2YXIgdD1lLmV4cG9ydHM9e307dmFyIHI7dmFyIG47ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe3I9c2V0VGltZW91dH1lbHNle3I9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7cj1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtuPWNsZWFyVGltZW91dH1lbHNle249ZGVmYXVsdENsZWFyVGltZW91dH19Y2F0Y2goZSl7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChlKXtpZihyPT09c2V0VGltZW91dCl7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX1pZigocj09PWRlZmF1bHRTZXRUaW1vdXR8fCFyKSYmc2V0VGltZW91dCl7cj1zZXRUaW1lb3V0O3JldHVybiBzZXRUaW1lb3V0KGUsMCl9dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KGUpe2lmKG49PT1jbGVhclRpbWVvdXQpe3JldHVybiBjbGVhclRpbWVvdXQoZSl9aWYoKG49PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhbikmJmNsZWFyVGltZW91dCl7bj1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChlKX10cnl7cmV0dXJuIG4oZSl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gbi5jYWxsKHRoaXMsZSl9fX12YXIgaT1bXTt2YXIgbz1mYWxzZTt2YXIgdTt2YXIgYT0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighb3x8IXUpe3JldHVybn1vPWZhbHNlO2lmKHUubGVuZ3RoKXtpPXUuY29uY2F0KGkpfWVsc2V7YT0tMX1pZihpLmxlbmd0aCl7ZHJhaW5RdWV1ZSgpfX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYobyl7cmV0dXJufXZhciBlPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtvPXRydWU7dmFyIHQ9aS5sZW5ndGg7d2hpbGUodCl7dT1pO2k9W107d2hpbGUoKythPHQpe2lmKHUpe3VbYV0ucnVuKCl9fWE9LTE7dD1pLmxlbmd0aH11PW51bGw7bz1mYWxzZTtydW5DbGVhclRpbWVvdXQoZSl9dC5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3Rbci0xXT1hcmd1bWVudHNbcl19fWkucHVzaChuZXcgSXRlbShlLHQpKTtpZihpLmxlbmd0aD09PTEmJiFvKXtydW5UaW1lb3V0KGRyYWluUXVldWUpfX07ZnVuY3Rpb24gSXRlbShlLHQpe3RoaXMuZnVuPWU7dGhpcy5hcnJheT10fUl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O3QudGl0bGU9XCJicm93c2VyXCI7dC5icm93c2VyPXRydWU7dC5lbnY9e307dC5hcmd2PVtdO3QudmVyc2lvbj1cIlwiO3QudmVyc2lvbnM9e307ZnVuY3Rpb24gbm9vcCgpe310Lm9uPW5vb3A7dC5hZGRMaXN0ZW5lcj1ub29wO3Qub25jZT1ub29wO3Qub2ZmPW5vb3A7dC5yZW1vdmVMaXN0ZW5lcj1ub29wO3QucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7dC5lbWl0PW5vb3A7dC5wcmVwZW5kTGlzdGVuZXI9bm9vcDt0LnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcDt0Lmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX07dC5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifTt0LmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX07dC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXRbcl09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2Vbcl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIHRbcl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXygyMjkpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      case REACT_SERVER_CONTEXT_TYPE:\n        {\n          var context2 = type;\n          return (context2.displayName || context2._globalName) + '.Provider';\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe[prop-missing]\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      } // TODO(luna): This will currently only throw if the function component\n      // tries to access React/ReactDOM/props. We should probably make this throw\n      // in simple components too\n\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV = jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLCtGQUEwQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGVBQWU7QUFDaEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUixrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0EscUNBQXFDOztBQUVyQyxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJIO0FBQzNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0VBQW9FOztBQUVwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7O0FBRWxHO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFD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O0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4Q0FBOEMsZ0RBQWdELE1BQU0sYUFBYTs7QUFFakg7QUFDQSwrQ0FBK0Msa0NBQWtDLE9BQU87O0FBRXhGLHVHQUF1RyxjQUFjLFVBQVUsZ0dBQWdHLGtCQUFrQixVQUFVLFVBQVU7O0FBRXJRO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzPzZjODgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2VydmVyX2NvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgICBjYXNlIFJFQUNUX0NBQ0hFX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiAnQ2FjaGUnO1xuICAgICAgfVxuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbnRleHQyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gKGNvbnRleHQyLmRpc3BsYXlOYW1lIHx8IGNvbnRleHQyLl9nbG9iYWxOYW1lKSArICcuUHJvdmlkZXInO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIFJlYWN0L1JlYWN0RE9NL3Byb3BzLiBXZSBzaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIHRocm93XG4gICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      case REACT_SERVER_CONTEXT_TYPE:\n        {\n          var context2 = type;\n          return (context2.displayName || context2._globalName) + '.Provider';\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe[prop-missing]\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      } // TODO(luna): This will currently only throw if the function component\n      // tries to access React/ReactDOM/props. We should probably make this throw\n      // in simple components too\n\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\n\nfunction jsxWithValidationStatic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, true);\n  }\n}\nfunction jsxWithValidationDynamic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, false);\n  }\n}\n\nvar jsx = jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\n\nvar jsxs = jsxWithValidationStatic ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsx;\nexports.jsxs = jsxs;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsK0ZBQTBCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7O0FBR2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySEFBMkg7QUFDM0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvRUFBb0U7O0FBRXBFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRzs7QUFFbEc7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FB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QSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QyxnREFBZ0QsTUFBTSxhQUFhOztBQUVqSDtBQUNBLCtDQUErQyxrQ0FBa0MsT0FBTzs7QUFFeEYsdUdBQXVHLGNBQWMsVUFBVSxnR0FBZ0csa0JBQWtCLFVBQVUsVUFBVTs7QUFFclE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUE7O0FBRUEsZ0JBQWdCO0FBQ2hCLFdBQVc7QUFDWCxZQUFZO0FBQ1osR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzP2E3M2IiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zZXJ2ZXJfY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29udGV4dDIgPSB0eXBlO1xuICAgICAgICAgIHJldHVybiAoY29udGV4dDIuZGlzcGxheU5hbWUgfHwgY29udGV4dDIuX2dsb2JhbE5hbWUpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9IC8vIFRPRE8obHVuYSk6IFRoaXMgd2lsbCBjdXJyZW50bHkgb25seSB0aHJvdyBpZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ2tleScpKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcbi8vIGV2ZW4gd2l0aCB0aGUgcHJvZCB0cmFuc2Zvcm0uIFRoaXMgbWVhbnMgdGhhdCBqc3hERVYgaXMgcHVyZWx5XG4vLyBvcHQtaW4gYmVoYXZpb3IgZm9yIGJldHRlciBtZXNzYWdlcyBidXQgdGhhdCB3ZSB3b24ndCBzdG9wXG4vLyBnaXZpbmcgeW91IHdhcm5pbmdzIGlmIHlvdSB1c2UgcHJvZHVjdGlvbiBhcGlzLlxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHtcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHtcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgZmFsc2UpO1xuICB9XG59XG5cbnZhciBqc3ggPSBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWMgOyAvLyB3ZSBtYXkgd2FudCB0byBzcGVjaWFsIGNhc2UganN4cyBpbnRlcm5hbGx5IHRvIHRha2UgYWR2YW50YWdlIG9mIHN0YXRpYyBjaGlsZHJlbi5cbi8vIGZvciBub3cgd2UgY2FuIHNoaXAgaWRlbnRpY2FsIHByb2QgZnVuY3Rpb25zXG5cbnZhciBqc3hzID0ganN4V2l0aFZhbGlkYXRpb25TdGF0aWMgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4ID0ganN4O1xuZXhwb3J0cy5qc3hzID0ganN4cztcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-client)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHVMQUFzRTtBQUN4RSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz82MjM5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/compiled/react/jsx-runtime.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-runtime.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"(app-client)/./node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsK0tBQWtFO0FBQ3BFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LXJ1bnRpbWUuanM/Mjk3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/compiled/react/jsx-runtime.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/react-chessboard/dist/index.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-chessboard/dist/index.esm.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chessboard: function() { return /* binding */ br; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-client)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-client)/./node_modules/next/dist/build/polyfills/process.js\");\nconst m=(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({dragDropManager:void 0});function y(e){return\"Minified Redux error #\"+e+\"; visit https://redux.js.org/Errors?code=\"+e+\" for the full message or use the non-minified dev environment for full errors. \"}var b=\"function\"==typeof Symbol&&Symbol.observable||\"@@observable\",O=function(){return Math.random().toString(36).substring(7).split(\"\").join(\".\")},w={INIT:\"@@redux/INIT\"+O(),REPLACE:\"@@redux/REPLACE\"+O(),PROBE_UNKNOWN_ACTION:function(){return\"@@redux/PROBE_UNKNOWN_ACTION\"+O()}};function S(e){if(void 0===e)return\"undefined\";if(null===e)return\"null\";var t=typeof e;switch(t){case\"boolean\":case\"string\":case\"number\":case\"symbol\":case\"function\":return t}if(Array.isArray(e))return\"array\";if(function(e){return e instanceof Date||\"function\"==typeof e.toDateString&&\"function\"==typeof e.getDate&&\"function\"==typeof e.setDate}(e))return\"date\";if(function(e){return e instanceof Error||\"string\"==typeof e.message&&e.constructor&&\"number\"==typeof e.constructor.stackTraceLimit}(e))return\"error\";var r=function(e){return\"function\"==typeof e.constructor?e.constructor.name:null}(e);switch(r){case\"Symbol\":case\"Promise\":case\"WeakMap\":case\"WeakSet\":case\"Map\":case\"Set\":return r}return t.slice(8,-1).toLowerCase().replace(/\\s/g,\"\")}function D(e){var t=typeof e;return true&&(t=S(e)),t}function C(e,t,r){var n;if(\"function\"==typeof t&&\"function\"==typeof r||\"function\"==typeof r&&\"function\"==typeof arguments[3])throw new Error( false?0:\"It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.\");if(\"function\"==typeof t&&void 0===r&&(r=t,t=void 0),void 0!==r){if(\"function\"!=typeof r)throw new Error( false?0:\"Expected the enhancer to be a function. Instead, received: '\"+D(r)+\"'\");return r(C)(e,t)}if(\"function\"!=typeof e)throw new Error( false?0:\"Expected the root reducer to be a function. Instead, received: '\"+D(e)+\"'\");var o=e,i=t,s=[],a=s,c=!1;function u(){a===s&&(a=s.slice())}function l(){if(c)throw new Error( false?0:\"You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.\");return i}function d(e){if(\"function\"!=typeof e)throw new Error( false?0:\"Expected the listener to be a function. Instead, received: '\"+D(e)+\"'\");if(c)throw new Error( false?0:\"You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.\");var t=!0;return u(),a.push(e),function(){if(t){if(c)throw new Error( false?0:\"You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.\");t=!1,u();var r=a.indexOf(e);a.splice(r,1),s=null}}}function h(e){if(!function(e){if(\"object\"!=typeof e||null===e)return!1;for(var t=e;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}(e))throw new Error( false?0:\"Actions must be plain objects. Instead, the actual type was: '\"+D(e)+\"'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.\");if(void 0===e.type)throw new Error( false?0:'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');if(c)throw new Error( false?0:\"Reducers may not dispatch actions.\");try{c=!0,i=o(i,e)}finally{c=!1}for(var t=s=a,r=0;r<t.length;r++){(0,t[r])()}return e}return h({type:w.INIT}),(n={dispatch:h,subscribe:d,getState:l,replaceReducer:function(e){if(\"function\"!=typeof e)throw new Error( false?0:\"Expected the nextReducer to be a function. Instead, received: '\"+D(e));o=e,h({type:w.REPLACE})}})[b]=function(){var e,t=d;return(e={subscribe:function(e){if(\"object\"!=typeof e||null===e)throw new Error( false?0:\"Expected the observer to be an object. Instead, received: '\"+D(e)+\"'\");function r(){e.next&&e.next(l())}return r(),{unsubscribe:t(r)}}})[b]=function(){return this},e},n}function T(){}function E(e,t,...r){if(\"undefined\"!=typeof process&&\"production\"===\"development\"&&0){}if(!e){let e;if(void 0===t)e=new Error(\"Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.\");else{let n=0;e=new Error(t.replace(/%s/g,(function(){return r[n++]}))),e.name=\"Invariant Violation\"}throw e.framesToPop=1,e}}function I(e){return\"object\"==typeof e} true&&\"string\"==typeof T.name&&\"isCrushed\"!==T.name&&function(e){\"undefined\"!=typeof console&&\"function\"==typeof console.error&&console.error(e);try{throw new Error(e)}catch(e){}}('You are currently using minified code outside of NODE_ENV === \"production\". This means that you are running a slower development build of Redux. You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) to ensure you have the correct code for your production build.');const k=\"dnd-core/INIT_COORDS\",L=\"dnd-core/BEGIN_DRAG\",P=\"dnd-core/PUBLISH_DRAG_SOURCE\",x=\"dnd-core/HOVER\",M=\"dnd-core/DROP\",N=\"dnd-core/END_DRAG\";function j(e,t){return{type:k,payload:{sourceClientOffset:t||null,clientOffset:e||null}}}const R={type:k,payload:{clientOffset:null,sourceClientOffset:null}};function A(e){return function(t=[],r={publishSource:!0}){const{publishSource:n=!0,clientOffset:o,getSourceClientOffset:i}=r,s=e.getMonitor(),a=e.getRegistry();e.dispatch(j(o)),function(e,t,r){E(!t.isDragging(),\"Cannot call beginDrag while dragging.\"),e.forEach((function(e){E(r.getSource(e),\"Expected sourceIds to be registered.\")}))}(t,s,a);const c=function(e,t){let r=null;for(let n=e.length-1;n>=0;n--)if(t.canDragSource(e[n])){r=e[n];break}return r}(t,s);if(null==c)return void e.dispatch(R);let u=null;if(o){if(!i)throw new Error(\"getSourceClientOffset must be defined\");!function(e){E(\"function\"==typeof e,\"When clientOffset is provided, getSourceClientOffset must be a function.\")}(i),u=i(c)}e.dispatch(j(o,u));const l=a.getSource(c).beginDrag(s,c);if(null==l)return;!function(e){E(I(e),\"Item must be an object.\")}(l),a.pinSource(c);const d=a.getSourceType(c);return{type:L,payload:{itemType:d,item:l,sourceId:c,clientOffset:o||null,sourceClientOffset:u||null,isSourcePublic:!!n}}}}function q(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function _(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},n=Object.keys(r);\"function\"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter((function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable})))),n.forEach((function(t){q(e,t,r[t])}))}return e}function z(e){return function(t={}){const r=e.getMonitor(),n=e.getRegistry();!function(e){E(e.isDragging(),\"Cannot call drop while not dragging.\"),E(!e.didDrop(),\"Cannot call drop twice during one drag operation.\")}(r);const o=function(e){const t=e.getTargetIds().filter(e.canDropOnTarget,e);return t.reverse(),t}(r);o.forEach(((o,i)=>{const s=function(e,t,r,n){const o=r.getTarget(e);let i=o?o.drop(n,e):void 0;(function(e){E(void 0===e||I(e),\"Drop result must either be an object or undefined.\")})(i),void 0===i&&(i=0===t?{}:n.getDropResult());return i}(o,i,n,r),a={type:M,payload:{dropResult:_({},t,s)}};e.dispatch(a)}))}}function H(e){return function(){const t=e.getMonitor(),r=e.getRegistry();!function(e){E(e.isDragging(),\"Cannot call endDrag while not dragging.\")}(t);const n=t.getSourceId();if(null!=n){r.getSource(n,!0).endDrag(t,n),r.unpinSource()}return{type:N}}}function B(e,t){return null===t?null===e:Array.isArray(e)?e.some((e=>e===t)):e===t}function W(e){return function(t,{clientOffset:r}={}){!function(e){E(Array.isArray(e),\"Expected targetIds to be an array.\")}(t);const n=t.slice(0),o=e.getMonitor(),i=e.getRegistry();return function(e,t,r){for(let n=e.length-1;n>=0;n--){const o=e[n];B(t.getTargetType(o),r)||e.splice(n,1)}}(n,i,o.getItemType()),function(e,t,r){E(t.isDragging(),\"Cannot call hover while not dragging.\"),E(!t.didDrop(),\"Cannot call hover after drop.\");for(let t=0;t<e.length;t++){const n=e[t];E(e.lastIndexOf(n)===t,\"Expected targetIds to be unique in the passed array.\");E(r.getTarget(n),\"Expected targetIds to be registered.\")}}(n,o,i),function(e,t,r){e.forEach((function(e){r.getTarget(e).hover(t,e)}))}(n,o,i),{type:x,payload:{targetIds:n,clientOffset:r||null}}}}function U(e){return function(){if(e.getMonitor().isDragging())return{type:P}}}class F{receiveBackend(e){this.backend=e}getMonitor(){return this.monitor}getBackend(){return this.backend}getRegistry(){return this.monitor.registry}getActions(){const e=this,{dispatch:t}=this.store;const r=function(e){return{beginDrag:A(e),publishDragSource:U(e),hover:W(e),drop:z(e),endDrag:H(e)}}(this);return Object.keys(r).reduce(((n,o)=>{const i=r[o];var s;return n[o]=(s=i,(...r)=>{const n=s.apply(e,r);void 0!==n&&t(n)}),n}),{})}dispatch(e){this.store.dispatch(e)}constructor(e,t){this.isSetUp=!1,this.handleRefCountChange=()=>{const e=this.store.getState().refCount>0;this.backend&&(e&&!this.isSetUp?(this.backend.setup(),this.isSetUp=!0):!e&&this.isSetUp&&(this.backend.teardown(),this.isSetUp=!1))},this.store=e,this.monitor=t,e.subscribe(this.handleRefCountChange)}}function $(e,t){return{x:e.x-t.x,y:e.y-t.y}}const V=[],Y=[];V.__IS_NONE__=!0,Y.__IS_ALL__=!0;class K{subscribeToStateChange(e,t={}){const{handlerIds:r}=t;E(\"function\"==typeof e,\"listener must be a function.\"),E(void 0===r||Array.isArray(r),\"handlerIds, when specified, must be an array of strings.\");let n=this.store.getState().stateId;return this.store.subscribe((()=>{const t=this.store.getState(),o=t.stateId;try{const i=o===n||o===n+1&&!function(e,t){return e!==V&&(e===Y||void 0===t||(r=e,t.filter((e=>r.indexOf(e)>-1))).length>0);var r}(t.dirtyHandlerIds,r);i||e()}finally{n=o}}))}subscribeToOffsetChange(e){E(\"function\"==typeof e,\"listener must be a function.\");let t=this.store.getState().dragOffset;return this.store.subscribe((()=>{const r=this.store.getState().dragOffset;r!==t&&(t=r,e())}))}canDragSource(e){if(!e)return!1;const t=this.registry.getSource(e);return E(t,`Expected to find a valid source. sourceId=${e}`),!this.isDragging()&&t.canDrag(this,e)}canDropOnTarget(e){if(!e)return!1;const t=this.registry.getTarget(e);if(E(t,`Expected to find a valid target. targetId=${e}`),!this.isDragging()||this.didDrop())return!1;return B(this.registry.getTargetType(e),this.getItemType())&&t.canDrop(this,e)}isDragging(){return Boolean(this.getItemType())}isDraggingSource(e){if(!e)return!1;const t=this.registry.getSource(e,!0);if(E(t,`Expected to find a valid source. sourceId=${e}`),!this.isDragging()||!this.isSourcePublic())return!1;return this.registry.getSourceType(e)===this.getItemType()&&t.isDragging(this,e)}isOverTarget(e,t={shallow:!1}){if(!e)return!1;const{shallow:r}=t;if(!this.isDragging())return!1;const n=this.registry.getTargetType(e),o=this.getItemType();if(o&&!B(n,o))return!1;const i=this.getTargetIds();if(!i.length)return!1;const s=i.indexOf(e);return r?s===i.length-1:s>-1}getItemType(){return this.store.getState().dragOperation.itemType}getItem(){return this.store.getState().dragOperation.item}getSourceId(){return this.store.getState().dragOperation.sourceId}getTargetIds(){return this.store.getState().dragOperation.targetIds}getDropResult(){return this.store.getState().dragOperation.dropResult}didDrop(){return this.store.getState().dragOperation.didDrop}isSourcePublic(){return Boolean(this.store.getState().dragOperation.isSourcePublic)}getInitialClientOffset(){return this.store.getState().dragOffset.initialClientOffset}getInitialSourceClientOffset(){return this.store.getState().dragOffset.initialSourceClientOffset}getClientOffset(){return this.store.getState().dragOffset.clientOffset}getSourceClientOffset(){return function(e){const{clientOffset:t,initialClientOffset:r,initialSourceClientOffset:n}=e;return t&&r&&n?$((i=n,{x:(o=t).x+i.x,y:o.y+i.y}),r):null;var o,i}(this.store.getState().dragOffset)}getDifferenceFromInitialOffset(){return function(e){const{clientOffset:t,initialClientOffset:r}=e;return t&&r?$(t,r):null}(this.store.getState().dragOffset)}constructor(e,t){this.store=e,this.registry=t}}const X=\"undefined\"!=typeof __webpack_require__.g?__webpack_require__.g:self,G=X.MutationObserver||X.WebKitMutationObserver;function Q(e){return function(){const t=setTimeout(n,0),r=setInterval(n,50);function n(){clearTimeout(t),clearInterval(r),e()}}}const J=\"function\"==typeof G?function(e){let t=1;const r=new G(e),n=document.createTextNode(\"\");return r.observe(n,{characterData:!0}),function(){t=-t,n.data=t}}:Q;class Z{call(){try{this.task&&this.task()}catch(e){this.onError(e)}finally{this.task=null,this.release(this)}}constructor(e,t){this.onError=e,this.release=t,this.task=null}}const ee=new class{enqueueTask(e){const{queue:t,requestFlush:r}=this;t.length||(r(),this.flushing=!0),t[t.length]=e}constructor(){this.queue=[],this.pendingErrors=[],this.flushing=!1,this.index=0,this.capacity=1024,this.flush=()=>{const{queue:e}=this;for(;this.index<e.length;){const t=this.index;if(this.index++,e[t].call(),this.index>this.capacity){for(let t=0,r=e.length-this.index;t<r;t++)e[t]=e[t+this.index];e.length-=this.index,this.index=0}}e.length=0,this.index=0,this.flushing=!1},this.registerPendingError=e=>{this.pendingErrors.push(e),this.requestErrorThrow()},this.requestFlush=J(this.flush),this.requestErrorThrow=Q((()=>{if(this.pendingErrors.length)throw this.pendingErrors.shift()}))}},te=new class{create(e){const t=this.freeTasks,r=t.length?t.pop():new Z(this.onError,(e=>t[t.length]=e));return r.task=e,r}constructor(e){this.onError=e,this.freeTasks=[]}}(ee.registerPendingError);const re=\"dnd-core/ADD_SOURCE\",ne=\"dnd-core/ADD_TARGET\",oe=\"dnd-core/REMOVE_SOURCE\",ie=\"dnd-core/REMOVE_TARGET\";function se(e,t){t&&Array.isArray(e)?e.forEach((e=>se(e,!1))):E(\"string\"==typeof e||\"symbol\"==typeof e,t?\"Type can only be a string, a symbol, or an array of either.\":\"Type can only be a string or a symbol.\")}var ae;!function(e){e.SOURCE=\"SOURCE\",e.TARGET=\"TARGET\"}(ae||(ae={}));let ce=0;function ue(e){const t=(ce++).toString();switch(e){case ae.SOURCE:return`S${t}`;case ae.TARGET:return`T${t}`;default:throw new Error(`Unknown Handler Role: ${e}`)}}function le(e){switch(e[0]){case\"S\":return ae.SOURCE;case\"T\":return ae.TARGET;default:throw new Error(`Cannot parse handler ID: ${e}`)}}function de(e,t){const r=e.entries();let n=!1;do{const{done:e,value:[,o]}=r.next();if(o===t)return!0;n=!!e}while(!n);return!1}class he{addSource(e,t){se(e),function(e){E(\"function\"==typeof e.canDrag,\"Expected canDrag to be a function.\"),E(\"function\"==typeof e.beginDrag,\"Expected beginDrag to be a function.\"),E(\"function\"==typeof e.endDrag,\"Expected endDrag to be a function.\")}(t);const r=this.addHandler(ae.SOURCE,e,t);return this.store.dispatch(function(e){return{type:re,payload:{sourceId:e}}}(r)),r}addTarget(e,t){se(e,!0),function(e){E(\"function\"==typeof e.canDrop,\"Expected canDrop to be a function.\"),E(\"function\"==typeof e.hover,\"Expected hover to be a function.\"),E(\"function\"==typeof e.drop,\"Expected beginDrag to be a function.\")}(t);const r=this.addHandler(ae.TARGET,e,t);return this.store.dispatch(function(e){return{type:ne,payload:{targetId:e}}}(r)),r}containsHandler(e){return de(this.dragSources,e)||de(this.dropTargets,e)}getSource(e,t=!1){E(this.isSourceId(e),\"Expected a valid source ID.\");return t&&e===this.pinnedSourceId?this.pinnedSource:this.dragSources.get(e)}getTarget(e){return E(this.isTargetId(e),\"Expected a valid target ID.\"),this.dropTargets.get(e)}getSourceType(e){return E(this.isSourceId(e),\"Expected a valid source ID.\"),this.types.get(e)}getTargetType(e){return E(this.isTargetId(e),\"Expected a valid target ID.\"),this.types.get(e)}isSourceId(e){return le(e)===ae.SOURCE}isTargetId(e){return le(e)===ae.TARGET}removeSource(e){var t;E(this.getSource(e),\"Expected an existing source.\"),this.store.dispatch(function(e){return{type:oe,payload:{sourceId:e}}}(e)),t=()=>{this.dragSources.delete(e),this.types.delete(e)},ee.enqueueTask(te.create(t))}removeTarget(e){E(this.getTarget(e),\"Expected an existing target.\"),this.store.dispatch(function(e){return{type:ie,payload:{targetId:e}}}(e)),this.dropTargets.delete(e),this.types.delete(e)}pinSource(e){const t=this.getSource(e);E(t,\"Expected an existing source.\"),this.pinnedSourceId=e,this.pinnedSource=t}unpinSource(){E(this.pinnedSource,\"No source is pinned at the time.\"),this.pinnedSourceId=null,this.pinnedSource=null}addHandler(e,t,r){const n=ue(e);return this.types.set(n,t),e===ae.SOURCE?this.dragSources.set(n,r):e===ae.TARGET&&this.dropTargets.set(n,r),n}constructor(e){this.types=new Map,this.dragSources=new Map,this.dropTargets=new Map,this.pinnedSourceId=null,this.pinnedSource=null,this.store=e}}const ge=(e,t)=>e===t;function fe(e=V,t){switch(t.type){case x:break;case re:case ne:case ie:case oe:return V;default:return Y}const{targetIds:r=[],prevTargetIds:n=[]}=t.payload,o=function(e,t){const r=new Map,n=e=>{r.set(e,r.has(e)?r.get(e)+1:1)};e.forEach(n),t.forEach(n);const o=[];return r.forEach(((e,t)=>{1===e&&o.push(t)})),o}(r,n);if(!(o.length>0||!function(e,t,r=ge){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!r(e[n],t[n]))return!1;return!0}(r,n)))return V;const i=n[n.length-1],s=r[r.length-1];return i!==s&&(i&&o.push(i),s&&o.push(s)),o}function pe(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}const ve={initialSourceClientOffset:null,initialClientOffset:null,clientOffset:null};function me(e=ve,t){const{payload:r}=t;switch(t.type){case k:case L:return{initialSourceClientOffset:r.sourceClientOffset,initialClientOffset:r.clientOffset,clientOffset:r.clientOffset};case x:return n=e.clientOffset,o=r.clientOffset,!n&&!o||n&&o&&n.x===o.x&&n.y===o.y?e:function(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},n=Object.keys(r);\"function\"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter((function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable})))),n.forEach((function(t){pe(e,t,r[t])}))}return e}({},e,{clientOffset:r.clientOffset});case N:case M:return ve;default:return e}var n,o}function ye(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function be(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},n=Object.keys(r);\"function\"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter((function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable})))),n.forEach((function(t){ye(e,t,r[t])}))}return e}const Oe={itemType:null,item:null,sourceId:null,targetIds:[],dropResult:null,didDrop:!1,isSourcePublic:null};function we(e=Oe,t){const{payload:r}=t;switch(t.type){case L:return be({},e,{itemType:r.itemType,item:r.item,sourceId:r.sourceId,isSourcePublic:r.isSourcePublic,dropResult:null,didDrop:!1});case P:return be({},e,{isSourcePublic:!0});case x:return be({},e,{targetIds:r.targetIds});case ie:return-1===e.targetIds.indexOf(r.targetId)?e:be({},e,{targetIds:(n=e.targetIds,o=r.targetId,n.filter((e=>e!==o)))});case M:return be({},e,{dropResult:r.dropResult,didDrop:!0,targetIds:[]});case N:return be({},e,{itemType:null,item:null,sourceId:null,dropResult:null,didDrop:!1,isSourcePublic:null,targetIds:[]});default:return e}var n,o}function Se(e=0,t){switch(t.type){case re:case ne:return e+1;case oe:case ie:return e-1;default:return e}}function De(e=0){return e+1}function Ce(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function Te(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},n=Object.keys(r);\"function\"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter((function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable})))),n.forEach((function(t){Ce(e,t,r[t])}))}return e}function Ee(e={},t){return{dirtyHandlerIds:fe(e.dirtyHandlerIds,{type:t.type,payload:Te({},t.payload,{prevTargetIds:(r=e,n=\"dragOperation.targetIds\",o=[],n.split(\".\").reduce(((e,t)=>e&&e[t]?e[t]:o||null),r))})}),dragOffset:me(e.dragOffset,t),refCount:Se(e.refCount,t),dragOperation:we(e.dragOperation,t),stateId:De(e.stateId)};var r,n,o}function Ie(e,t=void 0,r={},n=!1){const o=function(e){const t=\"undefined\"!=typeof window&&window.__REDUX_DEVTOOLS_EXTENSION__;return C(Ee,e&&t&&t({name:\"dnd-core\",instanceId:\"dnd-core\"}))}(n),i=new K(o,new he(o)),s=new F(o,i),a=e(s,t,r);return s.receiveBackend(a),s}function ke(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}let Le=0;const Pe=Symbol.for(\"__REACT_DND_CONTEXT_INSTANCE__\");var xe=(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)((function(t){var{children:r}=t,n=ke(t,[\"children\"]);const[o,s]=function(e){if(\"manager\"in e){return[{dragDropManager:e.manager},!1]}const t=function(e,t=Me(),r,n){const o=t;o[Pe]||(o[Pe]={dragDropManager:Ie(e,t,r,n)});return o[Pe]}(e.backend,e.context,e.options,e.debugMode),r=!e.context;return[t,r]}(n);return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{if(s){const e=Me();return++Le,()=>{0==--Le&&(e[Pe]=null)}}}),[]),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(m.Provider,{value:o,children:r})}));function Me(){return\"undefined\"!=typeof __webpack_require__.g?__webpack_require__.g:window}var Ne=function e(t,r){if(t===r)return!0;if(t&&r&&\"object\"==typeof t&&\"object\"==typeof r){if(t.constructor!==r.constructor)return!1;var n,o,i;if(Array.isArray(t)){if((n=t.length)!=r.length)return!1;for(o=n;0!=o--;)if(!e(t[o],r[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===r.source&&t.flags===r.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===r.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===r.toString();if((n=(i=Object.keys(t)).length)!==Object.keys(r).length)return!1;for(o=n;0!=o--;)if(!Object.prototype.hasOwnProperty.call(r,i[o]))return!1;for(o=n;0!=o--;){var s=i[o];if(!e(t[s],r[s]))return!1}return!0}return t!=t&&r!=r};const je=\"undefined\"!=typeof window?react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect:react__WEBPACK_IMPORTED_MODULE_1__.useEffect;function Re(e,t,r){const[n,o]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)((()=>t(e))),i=(0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((()=>{const i=t(e);Ne(n,i)||(o(i),r&&r())}),[n,e,r]);return je(i),[n,i]}function Ae(e,t,r){return function(e,t,r){const[n,o]=Re(e,t,r);return je((function(){const t=e.getHandlerId();if(null!=t)return e.subscribeToStateChange(o,{handlerIds:[t]})}),[e,o]),n}(t,e||(()=>({})),(()=>r.reconnect()))}function qe(e,t){const r=[...t||[]];return null==t&&\"function\"!=typeof e&&r.push(e),(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)((()=>\"function\"==typeof e?e():e),r)}function _e(e){return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)((()=>e.hooks.dragSource()),[e])}function ze(e){return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)((()=>e.hooks.dragPreview()),[e])}let He=!1,Be=!1;class We{receiveHandlerId(e){this.sourceId=e}getHandlerId(){return this.sourceId}canDrag(){E(!He,\"You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor\");try{return He=!0,this.internalMonitor.canDragSource(this.sourceId)}finally{He=!1}}isDragging(){if(!this.sourceId)return!1;E(!Be,\"You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor\");try{return Be=!0,this.internalMonitor.isDraggingSource(this.sourceId)}finally{Be=!1}}subscribeToStateChange(e,t){return this.internalMonitor.subscribeToStateChange(e,t)}isDraggingSource(e){return this.internalMonitor.isDraggingSource(e)}isOverTarget(e,t){return this.internalMonitor.isOverTarget(e,t)}getTargetIds(){return this.internalMonitor.getTargetIds()}isSourcePublic(){return this.internalMonitor.isSourcePublic()}getSourceId(){return this.internalMonitor.getSourceId()}subscribeToOffsetChange(e){return this.internalMonitor.subscribeToOffsetChange(e)}canDragSource(e){return this.internalMonitor.canDragSource(e)}canDropOnTarget(e){return this.internalMonitor.canDropOnTarget(e)}getItemType(){return this.internalMonitor.getItemType()}getItem(){return this.internalMonitor.getItem()}getDropResult(){return this.internalMonitor.getDropResult()}didDrop(){return this.internalMonitor.didDrop()}getInitialClientOffset(){return this.internalMonitor.getInitialClientOffset()}getInitialSourceClientOffset(){return this.internalMonitor.getInitialSourceClientOffset()}getSourceClientOffset(){return this.internalMonitor.getSourceClientOffset()}getClientOffset(){return this.internalMonitor.getClientOffset()}getDifferenceFromInitialOffset(){return this.internalMonitor.getDifferenceFromInitialOffset()}constructor(e){this.sourceId=null,this.internalMonitor=e.getMonitor()}}let Ue=!1;class Fe{receiveHandlerId(e){this.targetId=e}getHandlerId(){return this.targetId}subscribeToStateChange(e,t){return this.internalMonitor.subscribeToStateChange(e,t)}canDrop(){if(!this.targetId)return!1;E(!Ue,\"You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor\");try{return Ue=!0,this.internalMonitor.canDropOnTarget(this.targetId)}finally{Ue=!1}}isOver(e){return!!this.targetId&&this.internalMonitor.isOverTarget(this.targetId,e)}getItemType(){return this.internalMonitor.getItemType()}getItem(){return this.internalMonitor.getItem()}getDropResult(){return this.internalMonitor.getDropResult()}didDrop(){return this.internalMonitor.didDrop()}getInitialClientOffset(){return this.internalMonitor.getInitialClientOffset()}getInitialSourceClientOffset(){return this.internalMonitor.getInitialSourceClientOffset()}getSourceClientOffset(){return this.internalMonitor.getSourceClientOffset()}getClientOffset(){return this.internalMonitor.getClientOffset()}getDifferenceFromInitialOffset(){return this.internalMonitor.getDifferenceFromInitialOffset()}constructor(e){this.targetId=null,this.internalMonitor=e.getMonitor()}}function $e(e,t,r,n){let o=r?r.call(n,e,t):void 0;if(void 0!==o)return!!o;if(e===t)return!0;if(\"object\"!=typeof e||!e||\"object\"!=typeof t||!t)return!1;const i=Object.keys(e),s=Object.keys(t);if(i.length!==s.length)return!1;const a=Object.prototype.hasOwnProperty.bind(t);for(let s=0;s<i.length;s++){const c=i[s];if(!a(c))return!1;const u=e[c],l=t[c];if(o=r?r.call(n,u,l,c):void 0,!1===o||void 0===o&&u!==l)return!1}return!0}function Ve(e){return null!==e&&\"object\"==typeof e&&Object.prototype.hasOwnProperty.call(e,\"current\")}function Ye(e){return(t=null,r=null)=>{if(!(0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(t)){const n=t;return e(n,r),n}const n=t;!function(e){if(\"string\"==typeof e.type)return;const t=e.type.displayName||e.type.name||\"the component\";throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${t} into a <div>, or turn it into a drag source or a drop target itself.`)}(n);return function(e,t){const r=e.ref;return E(\"string\"!=typeof r,\"Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs\"),(0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(e,r?{ref:e=>{Xe(r,e),Xe(t,e)}}:{ref:t})}(n,r?t=>e(t,r):e)}}function Ke(e){const t={};return Object.keys(e).forEach((r=>{const n=e[r];if(r.endsWith(\"Ref\"))t[r]=e[r];else{const e=Ye(n);t[r]=()=>e}})),t}function Xe(e,t){\"function\"==typeof e?e(t):e.current=t}class Ge{receiveHandlerId(e){this.handlerId!==e&&(this.handlerId=e,this.reconnect())}get connectTarget(){return this.dragSource}get dragSourceOptions(){return this.dragSourceOptionsInternal}set dragSourceOptions(e){this.dragSourceOptionsInternal=e}get dragPreviewOptions(){return this.dragPreviewOptionsInternal}set dragPreviewOptions(e){this.dragPreviewOptionsInternal=e}reconnect(){const e=this.reconnectDragSource();this.reconnectDragPreview(e)}reconnectDragSource(){const e=this.dragSource,t=this.didHandlerIdChange()||this.didConnectedDragSourceChange()||this.didDragSourceOptionsChange();return t&&this.disconnectDragSource(),this.handlerId?e?(t&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDragSource=e,this.lastConnectedDragSourceOptions=this.dragSourceOptions,this.dragSourceUnsubscribe=this.backend.connectDragSource(this.handlerId,e,this.dragSourceOptions)),t):(this.lastConnectedDragSource=e,t):t}reconnectDragPreview(e=!1){const t=this.dragPreview,r=e||this.didHandlerIdChange()||this.didConnectedDragPreviewChange()||this.didDragPreviewOptionsChange();r&&this.disconnectDragPreview(),this.handlerId&&(t?r&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDragPreview=t,this.lastConnectedDragPreviewOptions=this.dragPreviewOptions,this.dragPreviewUnsubscribe=this.backend.connectDragPreview(this.handlerId,t,this.dragPreviewOptions)):this.lastConnectedDragPreview=t)}didHandlerIdChange(){return this.lastConnectedHandlerId!==this.handlerId}didConnectedDragSourceChange(){return this.lastConnectedDragSource!==this.dragSource}didConnectedDragPreviewChange(){return this.lastConnectedDragPreview!==this.dragPreview}didDragSourceOptionsChange(){return!$e(this.lastConnectedDragSourceOptions,this.dragSourceOptions)}didDragPreviewOptionsChange(){return!$e(this.lastConnectedDragPreviewOptions,this.dragPreviewOptions)}disconnectDragSource(){this.dragSourceUnsubscribe&&(this.dragSourceUnsubscribe(),this.dragSourceUnsubscribe=void 0)}disconnectDragPreview(){this.dragPreviewUnsubscribe&&(this.dragPreviewUnsubscribe(),this.dragPreviewUnsubscribe=void 0,this.dragPreviewNode=null,this.dragPreviewRef=null)}get dragSource(){return this.dragSourceNode||this.dragSourceRef&&this.dragSourceRef.current}get dragPreview(){return this.dragPreviewNode||this.dragPreviewRef&&this.dragPreviewRef.current}clearDragSource(){this.dragSourceNode=null,this.dragSourceRef=null}clearDragPreview(){this.dragPreviewNode=null,this.dragPreviewRef=null}constructor(e){this.hooks=Ke({dragSource:(e,t)=>{this.clearDragSource(),this.dragSourceOptions=t||null,Ve(e)?this.dragSourceRef=e:this.dragSourceNode=e,this.reconnectDragSource()},dragPreview:(e,t)=>{this.clearDragPreview(),this.dragPreviewOptions=t||null,Ve(e)?this.dragPreviewRef=e:this.dragPreviewNode=e,this.reconnectDragPreview()}}),this.handlerId=null,this.dragSourceRef=null,this.dragSourceOptionsInternal=null,this.dragPreviewRef=null,this.dragPreviewOptionsInternal=null,this.lastConnectedHandlerId=null,this.lastConnectedDragSource=null,this.lastConnectedDragSourceOptions=null,this.lastConnectedDragPreview=null,this.lastConnectedDragPreviewOptions=null,this.backend=e}}class Qe{get connectTarget(){return this.dropTarget}reconnect(){const e=this.didHandlerIdChange()||this.didDropTargetChange()||this.didOptionsChange();e&&this.disconnectDropTarget();const t=this.dropTarget;this.handlerId&&(t?e&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDropTarget=t,this.lastConnectedDropTargetOptions=this.dropTargetOptions,this.unsubscribeDropTarget=this.backend.connectDropTarget(this.handlerId,t,this.dropTargetOptions)):this.lastConnectedDropTarget=t)}receiveHandlerId(e){e!==this.handlerId&&(this.handlerId=e,this.reconnect())}get dropTargetOptions(){return this.dropTargetOptionsInternal}set dropTargetOptions(e){this.dropTargetOptionsInternal=e}didHandlerIdChange(){return this.lastConnectedHandlerId!==this.handlerId}didDropTargetChange(){return this.lastConnectedDropTarget!==this.dropTarget}didOptionsChange(){return!$e(this.lastConnectedDropTargetOptions,this.dropTargetOptions)}disconnectDropTarget(){this.unsubscribeDropTarget&&(this.unsubscribeDropTarget(),this.unsubscribeDropTarget=void 0)}get dropTarget(){return this.dropTargetNode||this.dropTargetRef&&this.dropTargetRef.current}clearDropTarget(){this.dropTargetRef=null,this.dropTargetNode=null}constructor(e){this.hooks=Ke({dropTarget:(e,t)=>{this.clearDropTarget(),this.dropTargetOptions=t,Ve(e)?this.dropTargetRef=e:this.dropTargetNode=e,this.reconnect()}}),this.handlerId=null,this.dropTargetRef=null,this.dropTargetOptionsInternal=null,this.lastConnectedHandlerId=null,this.lastConnectedDropTarget=null,this.lastConnectedDropTargetOptions=null,this.backend=e}}function Je(){const{dragDropManager:e}=(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(m);return E(null!=e,\"Expected drag drop context\"),e}class Ze{beginDrag(){const e=this.spec,t=this.monitor;let r=null;return r=\"object\"==typeof e.item?e.item:\"function\"==typeof e.item?e.item(t):{},null!=r?r:null}canDrag(){const e=this.spec,t=this.monitor;return\"boolean\"==typeof e.canDrag?e.canDrag:\"function\"!=typeof e.canDrag||e.canDrag(t)}isDragging(e,t){const r=this.spec,n=this.monitor,{isDragging:o}=r;return o?o(n):t===e.getSourceId()}endDrag(){const e=this.spec,t=this.monitor,r=this.connector,{end:n}=e;n&&n(t.getItem(),t),r.reconnect()}constructor(e,t,r){this.spec=e,this.monitor=t,this.connector=r}}function et(e,t,r){const n=Je(),o=function(e,t,r){const n=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)((()=>new Ze(e,t,r)),[t,r]);return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{n.spec=e}),[e]),n}(e,t,r),s=function(e){return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)((()=>{const t=e.type;return E(null!=t,\"spec.type must be defined\"),t}),[e])}(e);je((function(){if(null!=s){const[e,i]=function(e,t,r){const n=r.getRegistry(),o=n.addSource(e,t);return[o,()=>n.removeSource(o)]}(s,o,n);return t.receiveHandlerId(e),r.receiveHandlerId(e),i}}),[n,t,r,o,s])}function tt(e,t){const r=qe(e,t);E(!r.begin,\"useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)\");const n=function(){const e=Je();return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)((()=>new We(e)),[e])}(),o=function(e,t){const r=Je(),n=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)((()=>new Ge(r.getBackend())),[r]);return je((()=>(n.dragSourceOptions=e||null,n.reconnect(),()=>n.disconnectDragSource())),[n,e]),je((()=>(n.dragPreviewOptions=t||null,n.reconnect(),()=>n.disconnectDragPreview())),[n,t]),n}(r.options,r.previewOptions);return et(r,n,o),[Ae(r.collect,n,o),_e(o),ze(o)]}function rt(e){return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)((()=>e.hooks.dropTarget()),[e])}class nt{canDrop(){const e=this.spec,t=this.monitor;return!e.canDrop||e.canDrop(t.getItem(),t)}hover(){const e=this.spec,t=this.monitor;e.hover&&e.hover(t.getItem(),t)}drop(){const e=this.spec,t=this.monitor;if(e.drop)return e.drop(t.getItem(),t)}constructor(e,t){this.spec=e,this.monitor=t}}function ot(e,t,r){const n=Je(),o=function(e,t){const r=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)((()=>new nt(e,t)),[t]);return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{r.spec=e}),[e]),r}(e,t),s=function(e){const{accept:t}=e;return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)((()=>(E(null!=e.accept,\"accept must be defined\"),Array.isArray(t)?t:[t])),[t])}(e);je((function(){const[e,i]=function(e,t,r){const n=r.getRegistry(),o=n.addTarget(e,t);return[o,()=>n.removeTarget(o)]}(s,o,n);return t.receiveHandlerId(e),r.receiveHandlerId(e),i}),[n,t,o,r,s.map((e=>e.toString())).join(\"|\")])}function it(e,t){const r=qe(e,t),n=function(){const e=Je();return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)((()=>new Fe(e)),[e])}(),o=function(e){const t=Je(),r=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)((()=>new Qe(t.getBackend())),[t]);return je((()=>(r.dropTargetOptions=e||null,r.reconnect(),()=>r.disconnectDropTarget())),[e]),r}(r.options);return ot(r,n,o),[Ae(r.collect,n,o),rt(o)]}function st(e){let t=null;return()=>(null==t&&(t=e()),t)}class at{enter(e){const t=this.entered.length;return this.entered=function(e,t){const r=new Set,n=e=>r.add(e);e.forEach(n),t.forEach(n);const o=[];return r.forEach((e=>o.push(e))),o}(this.entered.filter((t=>this.isNodeInDocument(t)&&(!t.contains||t.contains(e)))),[e]),0===t&&this.entered.length>0}leave(e){const t=this.entered.length;var r,n;return this.entered=(r=this.entered.filter(this.isNodeInDocument),n=e,r.filter((e=>e!==n))),t>0&&0===this.entered.length}reset(){this.entered=[]}constructor(e){this.entered=[],this.isNodeInDocument=e}}class ct{initializeExposedProperties(){Object.keys(this.config.exposeProperties).forEach((e=>{Object.defineProperty(this.item,e,{configurable:!0,enumerable:!0,get:()=>(console.warn(`Browser doesn't allow reading \"${e}\" until the drop event.`),null)})}))}loadDataTransfer(e){if(e){const t={};Object.keys(this.config.exposeProperties).forEach((r=>{const n=this.config.exposeProperties[r];null!=n&&(t[r]={value:n(e,this.config.matchesTypes),configurable:!0,enumerable:!0})})),Object.defineProperties(this.item,t)}}canDrag(){return!0}beginDrag(){return this.item}isDragging(e,t){return t===e.getSourceId()}endDrag(){}constructor(e){this.config=e,this.item={},this.initializeExposedProperties()}}const ut=\"__NATIVE_FILE__\",lt=\"__NATIVE_URL__\",dt=\"__NATIVE_TEXT__\",ht=\"__NATIVE_HTML__\";var gt=Object.freeze({__proto__:null,FILE:ut,HTML:ht,TEXT:dt,URL:lt});function ft(e,t,r){const n=t.reduce(((t,r)=>t||e.getData(r)),\"\");return null!=n?n:r}const pt={[ut]:{exposeProperties:{files:e=>Array.prototype.slice.call(e.files),items:e=>e.items,dataTransfer:e=>e},matchesTypes:[\"Files\"]},[ht]:{exposeProperties:{html:(e,t)=>ft(e,t,\"\"),dataTransfer:e=>e},matchesTypes:[\"Html\",\"text/html\"]},[lt]:{exposeProperties:{urls:(e,t)=>ft(e,t,\"\").split(\"\\n\"),dataTransfer:e=>e},matchesTypes:[\"Url\",\"text/uri-list\"]},[dt]:{exposeProperties:{text:(e,t)=>ft(e,t,\"\"),dataTransfer:e=>e},matchesTypes:[\"Text\",\"text/plain\"]}};function vt(e){if(!e)return null;const t=Array.prototype.slice.call(e.types||[]);return Object.keys(pt).filter((e=>{const r=pt[e];return!!(null==r?void 0:r.matchesTypes)&&r.matchesTypes.some((e=>t.indexOf(e)>-1))}))[0]||null}const mt=st((()=>/firefox/i.test(navigator.userAgent))),yt=st((()=>Boolean(window.safari)));class bt{interpolate(e){const{xs:t,ys:r,c1s:n,c2s:o,c3s:i}=this;let s=t.length-1;if(e===t[s])return r[s];let a,c=0,u=i.length-1;for(;c<=u;){a=Math.floor(.5*(c+u));const n=t[a];if(n<e)c=a+1;else{if(!(n>e))return r[a];u=a-1}}s=Math.max(0,u);const l=e-t[s],d=l*l;return r[s]+n[s]*l+o[s]*d+i[s]*l*d}constructor(e,t){const{length:r}=e,n=[];for(let e=0;e<r;e++)n.push(e);n.sort(((t,r)=>e[t]<e[r]?-1:1));const o=[],i=[];let s,a;for(let n=0;n<r-1;n++)s=e[n+1]-e[n],a=t[n+1]-t[n],o.push(s),i.push(a/s);const c=[i[0]];for(let e=0;e<o.length-1;e++){const t=i[e],r=i[e+1];if(t*r<=0)c.push(0);else{s=o[e];const n=o[e+1],i=s+n;c.push(3*i/((i+n)/t+(i+s)/r))}}c.push(i[i.length-1]);const u=[],l=[];let d;for(let e=0;e<c.length-1;e++){d=i[e];const t=c[e],r=1/o[e],n=t+c[e+1]-d-d;u.push((d-t-n)*r),l.push(n*r*r)}this.xs=e,this.ys=t,this.c1s=c,this.c2s=u,this.c3s=l}}const Ot=1;function wt(e){const t=e.nodeType===Ot?e:e.parentElement;if(!t)return null;const{top:r,left:n}=t.getBoundingClientRect();return{x:n,y:r}}function St(e){return{x:e.clientX,y:e.clientY}}function Dt(e,t,r,n,o){const i=\"IMG\"===(s=t).nodeName&&(mt()||!(null===(a=document.documentElement)||void 0===a?void 0:a.contains(s)));var s,a;const c=wt(i?e:t),u={x:r.x-c.x,y:r.y-c.y},{offsetWidth:l,offsetHeight:d}=e,{anchorX:h,anchorY:g}=n,{dragPreviewWidth:f,dragPreviewHeight:p}=function(e,t,r,n){let o=e?t.width:r,i=e?t.height:n;return yt()&&e&&(i/=window.devicePixelRatio,o/=window.devicePixelRatio),{dragPreviewWidth:o,dragPreviewHeight:i}}(i,t,l,d),{offsetX:v,offsetY:m}=o,y=0===m||m;return{x:0===v||v?v:new bt([0,.5,1],[u.x,u.x/l*f,u.x+f-l]).interpolate(h),y:y?m:(()=>{let e=new bt([0,.5,1],[u.y,u.y/d*p,u.y+p-d]).interpolate(g);return yt()&&i&&(e+=(window.devicePixelRatio-1)*p),e})()}}let Ct;function Tt(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function Et(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},n=Object.keys(r);\"function\"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter((function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable})))),n.forEach((function(t){Tt(e,t,r[t])}))}return e}class It{profile(){var e,t;return{sourcePreviewNodes:this.sourcePreviewNodes.size,sourcePreviewNodeOptions:this.sourcePreviewNodeOptions.size,sourceNodeOptions:this.sourceNodeOptions.size,sourceNodes:this.sourceNodes.size,dragStartSourceIds:(null===(e=this.dragStartSourceIds)||void 0===e?void 0:e.length)||0,dropTargetIds:this.dropTargetIds.length,dragEnterTargetIds:this.dragEnterTargetIds.length,dragOverTargetIds:(null===(t=this.dragOverTargetIds)||void 0===t?void 0:t.length)||0}}get window(){return this.options.window}get document(){return this.options.document}get rootElement(){return this.options.rootElement}setup(){const e=this.rootElement;if(void 0!==e){if(e.__isReactDndBackendSetUp)throw new Error(\"Cannot have two HTML5 backends at the same time.\");e.__isReactDndBackendSetUp=!0,this.addEventListeners(e)}}teardown(){const e=this.rootElement;var t;void 0!==e&&(e.__isReactDndBackendSetUp=!1,this.removeEventListeners(this.rootElement),this.clearCurrentDragSourceNode(),this.asyncEndDragFrameId&&(null===(t=this.window)||void 0===t||t.cancelAnimationFrame(this.asyncEndDragFrameId)))}connectDragPreview(e,t,r){return this.sourcePreviewNodeOptions.set(e,r),this.sourcePreviewNodes.set(e,t),()=>{this.sourcePreviewNodes.delete(e),this.sourcePreviewNodeOptions.delete(e)}}connectDragSource(e,t,r){this.sourceNodes.set(e,t),this.sourceNodeOptions.set(e,r);const n=t=>this.handleDragStart(t,e),o=e=>this.handleSelectStart(e);return t.setAttribute(\"draggable\",\"true\"),t.addEventListener(\"dragstart\",n),t.addEventListener(\"selectstart\",o),()=>{this.sourceNodes.delete(e),this.sourceNodeOptions.delete(e),t.removeEventListener(\"dragstart\",n),t.removeEventListener(\"selectstart\",o),t.setAttribute(\"draggable\",\"false\")}}connectDropTarget(e,t){const r=t=>this.handleDragEnter(t,e),n=t=>this.handleDragOver(t,e),o=t=>this.handleDrop(t,e);return t.addEventListener(\"dragenter\",r),t.addEventListener(\"dragover\",n),t.addEventListener(\"drop\",o),()=>{t.removeEventListener(\"dragenter\",r),t.removeEventListener(\"dragover\",n),t.removeEventListener(\"drop\",o)}}addEventListeners(e){e.addEventListener&&(e.addEventListener(\"dragstart\",this.handleTopDragStart),e.addEventListener(\"dragstart\",this.handleTopDragStartCapture,!0),e.addEventListener(\"dragend\",this.handleTopDragEndCapture,!0),e.addEventListener(\"dragenter\",this.handleTopDragEnter),e.addEventListener(\"dragenter\",this.handleTopDragEnterCapture,!0),e.addEventListener(\"dragleave\",this.handleTopDragLeaveCapture,!0),e.addEventListener(\"dragover\",this.handleTopDragOver),e.addEventListener(\"dragover\",this.handleTopDragOverCapture,!0),e.addEventListener(\"drop\",this.handleTopDrop),e.addEventListener(\"drop\",this.handleTopDropCapture,!0))}removeEventListeners(e){e.removeEventListener&&(e.removeEventListener(\"dragstart\",this.handleTopDragStart),e.removeEventListener(\"dragstart\",this.handleTopDragStartCapture,!0),e.removeEventListener(\"dragend\",this.handleTopDragEndCapture,!0),e.removeEventListener(\"dragenter\",this.handleTopDragEnter),e.removeEventListener(\"dragenter\",this.handleTopDragEnterCapture,!0),e.removeEventListener(\"dragleave\",this.handleTopDragLeaveCapture,!0),e.removeEventListener(\"dragover\",this.handleTopDragOver),e.removeEventListener(\"dragover\",this.handleTopDragOverCapture,!0),e.removeEventListener(\"drop\",this.handleTopDrop),e.removeEventListener(\"drop\",this.handleTopDropCapture,!0))}getCurrentSourceNodeOptions(){const e=this.monitor.getSourceId(),t=this.sourceNodeOptions.get(e);return Et({dropEffect:this.altKeyPressed?\"copy\":\"move\"},t||{})}getCurrentDropEffect(){return this.isDraggingNativeItem()?\"copy\":this.getCurrentSourceNodeOptions().dropEffect}getCurrentSourcePreviewNodeOptions(){const e=this.monitor.getSourceId();return Et({anchorX:.5,anchorY:.5,captureDraggingState:!1},this.sourcePreviewNodeOptions.get(e)||{})}isDraggingNativeItem(){const e=this.monitor.getItemType();return Object.keys(gt).some((t=>gt[t]===e))}beginDragNativeItem(e,t){this.clearCurrentDragSourceNode(),this.currentNativeSource=function(e,t){const r=pt[e];if(!r)throw new Error(`native type ${e} has no configuration`);const n=new ct(r);return n.loadDataTransfer(t),n}(e,t),this.currentNativeHandle=this.registry.addSource(e,this.currentNativeSource),this.actions.beginDrag([this.currentNativeHandle])}setCurrentDragSourceNode(e){this.clearCurrentDragSourceNode(),this.currentDragSourceNode=e;this.mouseMoveTimeoutTimer=setTimeout((()=>{var e;return null===(e=this.rootElement)||void 0===e?void 0:e.addEventListener(\"mousemove\",this.endDragIfSourceWasRemovedFromDOM,!0)}),1e3)}clearCurrentDragSourceNode(){if(this.currentDragSourceNode){var e;if(this.currentDragSourceNode=null,this.rootElement)null===(e=this.window)||void 0===e||e.clearTimeout(this.mouseMoveTimeoutTimer||void 0),this.rootElement.removeEventListener(\"mousemove\",this.endDragIfSourceWasRemovedFromDOM,!0);return this.mouseMoveTimeoutTimer=null,!0}return!1}handleDragStart(e,t){e.defaultPrevented||(this.dragStartSourceIds||(this.dragStartSourceIds=[]),this.dragStartSourceIds.unshift(t))}handleDragEnter(e,t){this.dragEnterTargetIds.unshift(t)}handleDragOver(e,t){null===this.dragOverTargetIds&&(this.dragOverTargetIds=[]),this.dragOverTargetIds.unshift(t)}handleDrop(e,t){this.dropTargetIds.unshift(t)}constructor(e,t,r){this.sourcePreviewNodes=new Map,this.sourcePreviewNodeOptions=new Map,this.sourceNodes=new Map,this.sourceNodeOptions=new Map,this.dragStartSourceIds=null,this.dropTargetIds=[],this.dragEnterTargetIds=[],this.currentNativeSource=null,this.currentNativeHandle=null,this.currentDragSourceNode=null,this.altKeyPressed=!1,this.mouseMoveTimeoutTimer=null,this.asyncEndDragFrameId=null,this.dragOverTargetIds=null,this.lastClientOffset=null,this.hoverRafId=null,this.getSourceClientOffset=e=>{const t=this.sourceNodes.get(e);return t&&wt(t)||null},this.endDragNativeItem=()=>{this.isDraggingNativeItem()&&(this.actions.endDrag(),this.currentNativeHandle&&this.registry.removeSource(this.currentNativeHandle),this.currentNativeHandle=null,this.currentNativeSource=null)},this.isNodeInDocument=e=>Boolean(e&&this.document&&this.document.body&&this.document.body.contains(e)),this.endDragIfSourceWasRemovedFromDOM=()=>{const e=this.currentDragSourceNode;null==e||this.isNodeInDocument(e)||(this.clearCurrentDragSourceNode()&&this.monitor.isDragging()&&this.actions.endDrag(),this.cancelHover())},this.scheduleHover=e=>{null===this.hoverRafId&&\"undefined\"!=typeof requestAnimationFrame&&(this.hoverRafId=requestAnimationFrame((()=>{this.monitor.isDragging()&&this.actions.hover(e||[],{clientOffset:this.lastClientOffset}),this.hoverRafId=null})))},this.cancelHover=()=>{null!==this.hoverRafId&&\"undefined\"!=typeof cancelAnimationFrame&&(cancelAnimationFrame(this.hoverRafId),this.hoverRafId=null)},this.handleTopDragStartCapture=()=>{this.clearCurrentDragSourceNode(),this.dragStartSourceIds=[]},this.handleTopDragStart=e=>{if(e.defaultPrevented)return;const{dragStartSourceIds:t}=this;this.dragStartSourceIds=null;const r=St(e);this.monitor.isDragging()&&(this.actions.endDrag(),this.cancelHover()),this.actions.beginDrag(t||[],{publishSource:!1,getSourceClientOffset:this.getSourceClientOffset,clientOffset:r});const{dataTransfer:n}=e,o=vt(n);if(this.monitor.isDragging()){if(n&&\"function\"==typeof n.setDragImage){const e=this.monitor.getSourceId(),t=this.sourceNodes.get(e),o=this.sourcePreviewNodes.get(e)||t;if(o){const{anchorX:e,anchorY:i,offsetX:s,offsetY:a}=this.getCurrentSourcePreviewNodeOptions(),c=Dt(t,o,r,{anchorX:e,anchorY:i},{offsetX:s,offsetY:a});n.setDragImage(o,c.x,c.y)}}try{null==n||n.setData(\"application/json\",{})}catch(e){}this.setCurrentDragSourceNode(e.target);const{captureDraggingState:t}=this.getCurrentSourcePreviewNodeOptions();t?this.actions.publishDragSource():setTimeout((()=>this.actions.publishDragSource()),0)}else if(o)this.beginDragNativeItem(o);else{if(n&&!n.types&&(e.target&&!e.target.hasAttribute||!e.target.hasAttribute(\"draggable\")))return;e.preventDefault()}},this.handleTopDragEndCapture=()=>{this.clearCurrentDragSourceNode()&&this.monitor.isDragging()&&this.actions.endDrag(),this.cancelHover()},this.handleTopDragEnterCapture=e=>{var t;(this.dragEnterTargetIds=[],this.isDraggingNativeItem())&&(null===(t=this.currentNativeSource)||void 0===t||t.loadDataTransfer(e.dataTransfer));if(!this.enterLeaveCounter.enter(e.target)||this.monitor.isDragging())return;const{dataTransfer:r}=e,n=vt(r);n&&this.beginDragNativeItem(n,r)},this.handleTopDragEnter=e=>{const{dragEnterTargetIds:t}=this;if(this.dragEnterTargetIds=[],!this.monitor.isDragging())return;this.altKeyPressed=e.altKey,t.length>0&&this.actions.hover(t,{clientOffset:St(e)});t.some((e=>this.monitor.canDropOnTarget(e)))&&(e.preventDefault(),e.dataTransfer&&(e.dataTransfer.dropEffect=this.getCurrentDropEffect()))},this.handleTopDragOverCapture=e=>{var t;(this.dragOverTargetIds=[],this.isDraggingNativeItem())&&(null===(t=this.currentNativeSource)||void 0===t||t.loadDataTransfer(e.dataTransfer))},this.handleTopDragOver=e=>{const{dragOverTargetIds:t}=this;if(this.dragOverTargetIds=[],!this.monitor.isDragging())return e.preventDefault(),void(e.dataTransfer&&(e.dataTransfer.dropEffect=\"none\"));this.altKeyPressed=e.altKey,this.lastClientOffset=St(e),this.scheduleHover(t);(t||[]).some((e=>this.monitor.canDropOnTarget(e)))?(e.preventDefault(),e.dataTransfer&&(e.dataTransfer.dropEffect=this.getCurrentDropEffect())):this.isDraggingNativeItem()?e.preventDefault():(e.preventDefault(),e.dataTransfer&&(e.dataTransfer.dropEffect=\"none\"))},this.handleTopDragLeaveCapture=e=>{this.isDraggingNativeItem()&&e.preventDefault();this.enterLeaveCounter.leave(e.target)&&(this.isDraggingNativeItem()&&setTimeout((()=>this.endDragNativeItem()),0),this.cancelHover())},this.handleTopDropCapture=e=>{var t;(this.dropTargetIds=[],this.isDraggingNativeItem())?(e.preventDefault(),null===(t=this.currentNativeSource)||void 0===t||t.loadDataTransfer(e.dataTransfer)):vt(e.dataTransfer)&&e.preventDefault();this.enterLeaveCounter.reset()},this.handleTopDrop=e=>{const{dropTargetIds:t}=this;this.dropTargetIds=[],this.actions.hover(t,{clientOffset:St(e)}),this.actions.drop({dropEffect:this.getCurrentDropEffect()}),this.isDraggingNativeItem()?this.endDragNativeItem():this.monitor.isDragging()&&this.actions.endDrag(),this.cancelHover()},this.handleSelectStart=e=>{const t=e.target;\"function\"==typeof t.dragDrop&&(\"INPUT\"===t.tagName||\"SELECT\"===t.tagName||\"TEXTAREA\"===t.tagName||t.isContentEditable||(e.preventDefault(),t.dragDrop()))},this.options=new class{get window(){return this.globalContext?this.globalContext:\"undefined\"!=typeof window?window:void 0}get document(){var e;return(null===(e=this.globalContext)||void 0===e?void 0:e.document)?this.globalContext.document:this.window?this.window.document:void 0}get rootElement(){var e;return(null===(e=this.optionsArgs)||void 0===e?void 0:e.rootElement)||this.window}constructor(e,t){this.ownerDocument=null,this.globalContext=e,this.optionsArgs=t}}(t,r),this.actions=e.getActions(),this.monitor=e.getMonitor(),this.registry=e.getRegistry(),this.enterLeaveCounter=new at(this.isNodeInDocument)}}const kt=function(e,t,r){return new It(e,t,r)};var Lt;!function(e){e.mouse=\"mouse\",e.touch=\"touch\",e.keyboard=\"keyboard\"}(Lt||(Lt={}));class Pt{get delay(){var e;return null!==(e=this.args.delay)&&void 0!==e?e:0}get scrollAngleRanges(){return this.args.scrollAngleRanges}get getDropTargetElementsAtPoint(){return this.args.getDropTargetElementsAtPoint}get ignoreContextMenu(){var e;return null!==(e=this.args.ignoreContextMenu)&&void 0!==e&&e}get enableHoverOutsideTarget(){var e;return null!==(e=this.args.enableHoverOutsideTarget)&&void 0!==e&&e}get enableKeyboardEvents(){var e;return null!==(e=this.args.enableKeyboardEvents)&&void 0!==e&&e}get enableMouseEvents(){var e;return null!==(e=this.args.enableMouseEvents)&&void 0!==e&&e}get enableTouchEvents(){var e;return null===(e=this.args.enableTouchEvents)||void 0===e||e}get touchSlop(){return this.args.touchSlop||0}get delayTouchStart(){var e,t,r,n;return null!==(n=null!==(r=null===(e=this.args)||void 0===e?void 0:e.delayTouchStart)&&void 0!==r?r:null===(t=this.args)||void 0===t?void 0:t.delay)&&void 0!==n?n:0}get delayMouseStart(){var e,t,r,n;return null!==(n=null!==(r=null===(e=this.args)||void 0===e?void 0:e.delayMouseStart)&&void 0!==r?r:null===(t=this.args)||void 0===t?void 0:t.delay)&&void 0!==n?n:0}get window(){return this.context&&this.context.window?this.context.window:\"undefined\"!=typeof window?window:void 0}get document(){var e;return(null===(e=this.context)||void 0===e?void 0:e.document)?this.context.document:this.window?this.window.document:void 0}get rootElement(){var e;return(null===(e=this.args)||void 0===e?void 0:e.rootElement)||this.document}constructor(e,t){this.args=e,this.context=t}}const xt=1,Mt=0;function Nt(e){return void 0===e.button||e.button===Mt}function jt(e){return!!e.targetTouches}function Rt(e,t){return jt(e)?function(e,t){return 1===e.targetTouches.length?Rt(e.targetTouches[0]):t&&1===e.touches.length&&e.touches[0].target===t.target?Rt(e.touches[0]):void 0}(e,t):{x:e.clientX,y:e.clientY}}const At=(()=>{let e=!1;try{addEventListener(\"test\",(()=>{}),Object.defineProperty({},\"passive\",{get:()=>(e=!0,!0)}))}catch(e){}return e})(),qt={[Lt.mouse]:{start:\"mousedown\",move:\"mousemove\",end:\"mouseup\",contextmenu:\"contextmenu\"},[Lt.touch]:{start:\"touchstart\",move:\"touchmove\",end:\"touchend\"},[Lt.keyboard]:{keydown:\"keydown\"}};class _t{profile(){var e;return{sourceNodes:this.sourceNodes.size,sourcePreviewNodes:this.sourcePreviewNodes.size,sourcePreviewNodeOptions:this.sourcePreviewNodeOptions.size,targetNodes:this.targetNodes.size,dragOverTargetIds:(null===(e=this.dragOverTargetIds)||void 0===e?void 0:e.length)||0}}get document(){return this.options.document}setup(){const e=this.options.rootElement;e&&(E(!_t.isSetUp,\"Cannot have two Touch backends at the same time.\"),_t.isSetUp=!0,this.addEventListener(e,\"start\",this.getTopMoveStartHandler()),this.addEventListener(e,\"start\",this.handleTopMoveStartCapture,!0),this.addEventListener(e,\"move\",this.handleTopMove),this.addEventListener(e,\"move\",this.handleTopMoveCapture,!0),this.addEventListener(e,\"end\",this.handleTopMoveEndCapture,!0),this.options.enableMouseEvents&&!this.options.ignoreContextMenu&&this.addEventListener(e,\"contextmenu\",this.handleTopMoveEndCapture),this.options.enableKeyboardEvents&&this.addEventListener(e,\"keydown\",this.handleCancelOnEscape,!0))}teardown(){const e=this.options.rootElement;e&&(_t.isSetUp=!1,this._mouseClientOffset={},this.removeEventListener(e,\"start\",this.handleTopMoveStartCapture,!0),this.removeEventListener(e,\"start\",this.handleTopMoveStart),this.removeEventListener(e,\"move\",this.handleTopMoveCapture,!0),this.removeEventListener(e,\"move\",this.handleTopMove),this.removeEventListener(e,\"end\",this.handleTopMoveEndCapture,!0),this.options.enableMouseEvents&&!this.options.ignoreContextMenu&&this.removeEventListener(e,\"contextmenu\",this.handleTopMoveEndCapture),this.options.enableKeyboardEvents&&this.removeEventListener(e,\"keydown\",this.handleCancelOnEscape,!0),this.uninstallSourceNodeRemovalObserver())}addEventListener(e,t,r,n=!1){const o=At?{capture:n,passive:!1}:n;this.listenerTypes.forEach((function(n){const i=qt[n][t];i&&e.addEventListener(i,r,o)}))}removeEventListener(e,t,r,n=!1){const o=At?{capture:n,passive:!1}:n;this.listenerTypes.forEach((function(n){const i=qt[n][t];i&&e.removeEventListener(i,r,o)}))}connectDragSource(e,t){const r=this.handleMoveStart.bind(this,e);return this.sourceNodes.set(e,t),this.addEventListener(t,\"start\",r),()=>{this.sourceNodes.delete(e),this.removeEventListener(t,\"start\",r)}}connectDragPreview(e,t,r){return this.sourcePreviewNodeOptions.set(e,r),this.sourcePreviewNodes.set(e,t),()=>{this.sourcePreviewNodes.delete(e),this.sourcePreviewNodeOptions.delete(e)}}connectDropTarget(e,t){const r=this.options.rootElement;if(!this.document||!r)return()=>{};const n=n=>{if(!this.document||!r||!this.monitor.isDragging())return;let o;switch(n.type){case qt.mouse.move:o={x:n.clientX,y:n.clientY};break;case qt.touch.move:var i,s;o={x:(null===(i=n.touches[0])||void 0===i?void 0:i.clientX)||0,y:(null===(s=n.touches[0])||void 0===s?void 0:s.clientY)||0}}const a=null!=o?this.document.elementFromPoint(o.x,o.y):void 0,c=a&&t.contains(a);return a===t||c?this.handleMove(n,e):void 0};return this.addEventListener(this.document.body,\"move\",n),this.targetNodes.set(e,t),()=>{this.document&&(this.targetNodes.delete(e),this.removeEventListener(this.document.body,\"move\",n))}}getTopMoveStartHandler(){return this.options.delayTouchStart||this.options.delayMouseStart?this.handleTopMoveStartDelay:this.handleTopMoveStart}installSourceNodeRemovalObserver(e){this.uninstallSourceNodeRemovalObserver(),this.draggedSourceNode=e,this.draggedSourceNodeRemovalObserver=new MutationObserver((()=>{e&&!e.parentElement&&(this.resurrectSourceNode(),this.uninstallSourceNodeRemovalObserver())})),e&&e.parentElement&&this.draggedSourceNodeRemovalObserver.observe(e.parentElement,{childList:!0})}resurrectSourceNode(){this.document&&this.draggedSourceNode&&(this.draggedSourceNode.style.display=\"none\",this.draggedSourceNode.removeAttribute(\"data-reactid\"),this.document.body.appendChild(this.draggedSourceNode))}uninstallSourceNodeRemovalObserver(){this.draggedSourceNodeRemovalObserver&&this.draggedSourceNodeRemovalObserver.disconnect(),this.draggedSourceNodeRemovalObserver=void 0,this.draggedSourceNode=void 0}constructor(e,t,r){this.getSourceClientOffset=e=>{const t=this.sourceNodes.get(e);return t&&function(e){const t=1===e.nodeType?e:e.parentElement;if(!t)return;const{top:r,left:n}=t.getBoundingClientRect();return{x:n,y:r}}(t)},this.handleTopMoveStartCapture=e=>{Nt(e)&&(this.moveStartSourceIds=[])},this.handleMoveStart=e=>{Array.isArray(this.moveStartSourceIds)&&this.moveStartSourceIds.unshift(e)},this.handleTopMoveStart=e=>{if(!Nt(e))return;const t=Rt(e);t&&(jt(e)&&(this.lastTargetTouchFallback=e.targetTouches[0]),this._mouseClientOffset=t),this.waitingForDelay=!1},this.handleTopMoveStartDelay=e=>{if(!Nt(e))return;const t=e.type===qt.touch.start?this.options.delayTouchStart:this.options.delayMouseStart;this.timeout=setTimeout(this.handleTopMoveStart.bind(this,e),t),this.waitingForDelay=!0},this.handleTopMoveCapture=()=>{this.dragOverTargetIds=[]},this.handleMove=(e,t)=>{this.dragOverTargetIds&&this.dragOverTargetIds.unshift(t)},this.handleTopMove=e=>{if(this.timeout&&clearTimeout(this.timeout),!this.document||this.waitingForDelay)return;const{moveStartSourceIds:t,dragOverTargetIds:r}=this,n=this.options.enableHoverOutsideTarget,o=Rt(e,this.lastTargetTouchFallback);if(!o)return;if(this._isScrolling||!this.monitor.isDragging()&&function(e,t,r,n,o){if(!o)return!1;const i=180*Math.atan2(n-t,r-e)/Math.PI+180;for(let e=0;e<o.length;++e){const t=o[e];if(t&&(null==t.start||i>=t.start)&&(null==t.end||i<=t.end))return!0}return!1}(this._mouseClientOffset.x||0,this._mouseClientOffset.y||0,o.x,o.y,this.options.scrollAngleRanges))return void(this._isScrolling=!0);var i,s,a,c;if(!this.monitor.isDragging()&&this._mouseClientOffset.hasOwnProperty(\"x\")&&t&&(i=this._mouseClientOffset.x||0,s=this._mouseClientOffset.y||0,a=o.x,c=o.y,Math.sqrt(Math.pow(Math.abs(a-i),2)+Math.pow(Math.abs(c-s),2))>(this.options.touchSlop?this.options.touchSlop:0))&&(this.moveStartSourceIds=void 0,this.actions.beginDrag(t,{clientOffset:this._mouseClientOffset,getSourceClientOffset:this.getSourceClientOffset,publishSource:!1})),!this.monitor.isDragging())return;const u=this.sourceNodes.get(this.monitor.getSourceId());this.installSourceNodeRemovalObserver(u),this.actions.publishDragSource(),e.cancelable&&e.preventDefault();const l=(r||[]).map((e=>this.targetNodes.get(e))).filter((e=>!!e)),d=this.options.getDropTargetElementsAtPoint?this.options.getDropTargetElementsAtPoint(o.x,o.y,l):this.document.elementsFromPoint(o.x,o.y),h=[];for(const e in d){if(!d.hasOwnProperty(e))continue;let t=d[e];for(null!=t&&h.push(t);t;)t=t.parentElement,t&&-1===h.indexOf(t)&&h.push(t)}const g=h.filter((e=>l.indexOf(e)>-1)).map((e=>this._getDropTargetId(e))).filter((e=>!!e)).filter(((e,t,r)=>r.indexOf(e)===t));if(n)for(const e in this.targetNodes){const t=this.targetNodes.get(e);if(u&&t&&t.contains(u)&&-1===g.indexOf(e)){g.unshift(e);break}}g.reverse(),this.actions.hover(g,{clientOffset:o})},this._getDropTargetId=e=>{const t=this.targetNodes.keys();let r=t.next();for(;!1===r.done;){const n=r.value;if(e===this.targetNodes.get(n))return n;r=t.next()}},this.handleTopMoveEndCapture=e=>{this._isScrolling=!1,this.lastTargetTouchFallback=void 0,function(e){return void 0===e.buttons||0==(e.buttons&xt)}(e)&&(this.monitor.isDragging()&&!this.monitor.didDrop()?(e.cancelable&&e.preventDefault(),this._mouseClientOffset={},this.uninstallSourceNodeRemovalObserver(),this.actions.drop(),this.actions.endDrag()):this.moveStartSourceIds=void 0)},this.handleCancelOnEscape=e=>{\"Escape\"===e.key&&this.monitor.isDragging()&&(this._mouseClientOffset={},this.uninstallSourceNodeRemovalObserver(),this.actions.endDrag())},this.options=new Pt(r,t),this.actions=e.getActions(),this.monitor=e.getMonitor(),this.sourceNodes=new Map,this.sourcePreviewNodes=new Map,this.sourcePreviewNodeOptions=new Map,this.targetNodes=new Map,this.listenerTypes=[],this._mouseClientOffset={},this._isScrolling=!1,this.options.enableMouseEvents&&this.listenerTypes.push(Lt.mouse),this.options.enableTouchEvents&&this.listenerTypes.push(Lt.touch),this.options.enableKeyboardEvents&&this.listenerTypes.push(Lt.keyboard)}}const zt=function(e,t={},r={}){return new _t(e,t,r)},Ht=\"abcdefgh\".split(\"\"),Bt={a8:\"bR\",b8:\"bN\",c8:\"bB\",d8:\"bQ\",e8:\"bK\",f8:\"bB\",g8:\"bN\",h8:\"bR\",a7:\"bP\",b7:\"bP\",c7:\"bP\",d7:\"bP\",e7:\"bP\",f7:\"bP\",g7:\"bP\",h7:\"bP\",a2:\"wP\",b2:\"wP\",c2:\"wP\",d2:\"wP\",e2:\"wP\",f2:\"wP\",g2:\"wP\",h2:\"wP\",a1:\"wR\",b1:\"wN\",c1:\"wB\",d1:\"wQ\",e1:\"wK\",f1:\"wB\",g1:\"wN\",h1:\"wR\"},Wt={a:0,b:1,c:2,d:3,e:4,f:5,g:6,h:7},Ut={a:7,b:6,c:5,d:4,e:3,f:2,g:1,h:0},Ft=[7,6,5,4,3,2,1,0],$t=[0,1,2,3,4,5,6,7],Vt={wP:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({xmlns:\"http://www.w3.org/2000/svg\",version:\"1.1\",width:\"45\",height:\"45\"},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z\",style:{opacity:\"1\",fill:\"#ffffff\",fillOpacity:\"1\",fillRule:\"nonzero\",stroke:\"#000000\",strokeWidth:\"1.5\",strokeLinecap:\"round\",strokeLinejoin:\"miter\",strokeMiterlimit:\"4\",strokeDasharray:\"none\",strokeOpacity:\"1\"}})})),wR:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({xmlns:\"http://www.w3.org/2000/svg\",version:\"1.1\",width:\"45\",height:\"45\"},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\",Object.assign({style:{opacity:\"1\",fill:\"#ffffff\",fillOpacity:\"1\",fillRule:\"evenodd\",stroke:\"#000000\",strokeWidth:\"1.5\",strokeLinecap:\"round\",strokeLinejoin:\"round\",strokeMiterlimit:\"4\",strokeDasharray:\"none\",strokeOpacity:\"1\"}},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \",style:{strokeLinecap:\"butt\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \",style:{strokeLinecap:\"butt\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14\",style:{strokeLinecap:\"butt\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 34,14 L 31,17 L 14,17 L 11,14\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 31,17 L 31,29.5 L 14,29.5 L 14,17\",style:{strokeLinecap:\"butt\",strokeLinejoin:\"miter\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 11,14 L 34,14\",style:{fill:\"none\",stroke:\"#000000\",strokeLinejoin:\"miter\"}})]}))})),wN:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({xmlns:\"http://www.w3.org/2000/svg\",version:\"1.1\",width:\"45\",height:\"45\"},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\",Object.assign({style:{opacity:\"1\",fill:\"none\",fillOpacity:\"1\",fillRule:\"evenodd\",stroke:\"#000000\",strokeWidth:\"1.5\",strokeLinecap:\"round\",strokeLinejoin:\"round\",strokeMiterlimit:\"4\",strokeDasharray:\"none\",strokeOpacity:\"1\"}},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\",style:{fill:\"#ffffff\",stroke:\"#000000\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\",style:{fill:\"#ffffff\",stroke:\"#000000\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\",style:{fill:\"#000000\",stroke:\"#000000\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\",transform:\"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\",style:{fill:\"#000000\",stroke:\"#000000\"}})]}))})),wB:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({xmlns:\"http://www.w3.org/2000/svg\",version:\"1.1\",width:\"45\",height:\"45\"},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\",Object.assign({style:{opacity:\"1\",fill:\"none\",fillRule:\"evenodd\",fillOpacity:\"1\",stroke:\"#000000\",strokeWidth:\"1.5\",strokeLinecap:\"round\",strokeLinejoin:\"round\",strokeMiterlimit:\"4\",strokeDasharray:\"none\",strokeOpacity:\"1\"}},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\",Object.assign({style:{fill:\"#ffffff\",stroke:\"#000000\",strokeLinecap:\"butt\"}},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\"})]})),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\",style:{fill:\"none\",stroke:\"#000000\",strokeLinejoin:\"miter\"}})]}))})),wQ:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({xmlns:\"http://www.w3.org/2000/svg\",version:\"1.1\",width:\"45\",height:\"45\"},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\",Object.assign({style:{fill:\"#ffffff\",stroke:\"#000000\",strokeWidth:\"1.5\",strokeLinejoin:\"round\"}},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 11,36 11,36 C 9.5,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 11.5,30 C 15,29 30,29 33.5,30\",style:{fill:\"none\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 12,33.5 C 18,32.5 27,32.5 33,33.5\",style:{fill:\"none\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\",{cx:\"6\",cy:\"12\",r:\"2\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\",{cx:\"14\",cy:\"9\",r:\"2\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\",{cx:\"22.5\",cy:\"8\",r:\"2\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\",{cx:\"31\",cy:\"9\",r:\"2\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\",{cx:\"39\",cy:\"12\",r:\"2\"})]}))})),wK:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({xmlns:\"http://www.w3.org/2000/svg\",version:\"1.1\",width:\"45\",height:\"45\"},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\",Object.assign({style:{fill:\"none\",fillOpacity:\"1\",fillRule:\"evenodd\",stroke:\"#000000\",strokeWidth:\"1.5\",strokeLinecap:\"round\",strokeLinejoin:\"round\",strokeMiterlimit:\"4\",strokeDasharray:\"none\",strokeOpacity:\"1\"}},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 22.5,11.63 L 22.5,6\",style:{fill:\"none\",stroke:\"#000000\",strokeLinejoin:\"miter\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 20,8 L 25,8\",style:{fill:\"none\",stroke:\"#000000\",strokeLinejoin:\"miter\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\",style:{fill:\"#ffffff\",stroke:\"#000000\",strokeLinecap:\"butt\",strokeLinejoin:\"miter\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37\",style:{fill:\"#ffffff\",stroke:\"#000000\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 12.5,30 C 18,27 27,27 32.5,30\",style:{fill:\"none\",stroke:\"#000000\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5\",style:{fill:\"none\",stroke:\"#000000\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 12.5,37 C 18,34 27,34 32.5,37\",style:{fill:\"none\",stroke:\"#000000\"}})]}))})),bP:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({xmlns:\"http://www.w3.org/2000/svg\",version:\"1.1\",width:\"45\",height:\"45\"},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z\",style:{opacity:\"1\",fill:\"#000000\",fillOpacity:\"1\",fillRule:\"nonzero\",stroke:\"#000000\",strokeWidth:\"1.5\",strokeLinecap:\"round\",strokeLinejoin:\"miter\",strokeMiterlimit:\"4\",strokeDasharray:\"none\",strokeOpacity:\"1\"}})})),bR:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({xmlns:\"http://www.w3.org/2000/svg\",version:\"1.1\",width:\"45\",height:\"45\"},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\",Object.assign({style:{opacity:\"1\",fill:\"#000000\",fillOpacity:\"1\",fillRule:\"evenodd\",stroke:\"#000000\",strokeWidth:\"1.5\",strokeLinecap:\"round\",strokeLinejoin:\"round\",strokeMiterlimit:\"4\",strokeDasharray:\"none\",strokeOpacity:\"1\"}},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \",style:{strokeLinecap:\"butt\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z \",style:{strokeLinecap:\"butt\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \",style:{strokeLinecap:\"butt\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z \",style:{strokeLinecap:\"butt\",strokeLinejoin:\"miter\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z \",style:{strokeLinecap:\"butt\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z \",style:{strokeLinecap:\"butt\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 12,35.5 L 33,35.5 L 33,35.5\",style:{fill:\"none\",stroke:\"#ffffff\",strokeWidth:\"1\",strokeLinejoin:\"miter\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 13,31.5 L 32,31.5\",style:{fill:\"none\",stroke:\"#ffffff\",strokeWidth:\"1\",strokeLinejoin:\"miter\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 14,29.5 L 31,29.5\",style:{fill:\"none\",stroke:\"#ffffff\",strokeWidth:\"1\",strokeLinejoin:\"miter\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 14,16.5 L 31,16.5\",style:{fill:\"none\",stroke:\"#ffffff\",strokeWidth:\"1\",strokeLinejoin:\"miter\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 11,14 L 34,14\",style:{fill:\"none\",stroke:\"#ffffff\",strokeWidth:\"1\",strokeLinejoin:\"miter\"}})]}))})),bN:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({xmlns:\"http://www.w3.org/2000/svg\",version:\"1.1\",width:\"45\",height:\"45\"},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\",Object.assign({style:{opacity:\"1\",fill:\"none\",fillOpacity:\"1\",fillRule:\"evenodd\",stroke:\"#000000\",strokeWidth:\"1.5\",strokeLinecap:\"round\",strokeLinejoin:\"round\",strokeMiterlimit:\"4\",strokeDasharray:\"none\",strokeOpacity:\"1\"}},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\",style:{fill:\"#000000\",stroke:\"#000000\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\",style:{fill:\"#000000\",stroke:\"#000000\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\",style:{fill:\"#ffffff\",stroke:\"#ffffff\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\",transform:\"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\",style:{fill:\"#ffffff\",stroke:\"#ffffff\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z \",style:{fill:\"#ffffff\",stroke:\"none\"}})]}))})),bB:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({xmlns:\"http://www.w3.org/2000/svg\",version:\"1.1\",width:\"45\",height:\"45\"},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\",Object.assign({style:{opacity:\"1\",fill:\"none\",fillRule:\"evenodd\",fillOpacity:\"1\",stroke:\"#000000\",strokeWidth:\"1.5\",strokeLinecap:\"round\",strokeLinejoin:\"round\",strokeMiterlimit:\"4\",strokeDasharray:\"none\",strokeOpacity:\"1\"}},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\",Object.assign({style:{fill:\"#000000\",stroke:\"#000000\",strokeLinecap:\"butt\"}},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\"})]})),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\",style:{fill:\"none\",stroke:\"#ffffff\",strokeLinejoin:\"miter\"}})]}))})),bQ:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({xmlns:\"http://www.w3.org/2000/svg\",version:\"1.1\",width:\"45\",height:\"45\"},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\",Object.assign({style:{fill:\"#000000\",stroke:\"#000000\",strokeWidth:\"1.5\",strokeLinecap:\"round\",strokeLinejoin:\"round\"}},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z\",style:{strokeLinecap:\"butt\",fill:\"#000000\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"m 9,26 c 0,2 1.5,2 2.5,4 1,1.5 1,1 0.5,3.5 -1.5,1 -1,2.5 -1,2.5 -1.5,1.5 0,2.5 0,2.5 6.5,1 16.5,1 23,0 0,0 1.5,-1 0,-2.5 0,0 0.5,-1.5 -1,-2.5 -0.5,-2.5 -0.5,-2 0.5,-3.5 1,-2 2.5,-2 2.5,-4 -8.5,-1.5 -18.5,-1.5 -27,0 z\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 11.5,30 C 15,29 30,29 33.5,30\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"m 12,33.5 c 6,-1 15,-1 21,0\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\",{cx:\"6\",cy:\"12\",r:\"2\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\",{cx:\"14\",cy:\"9\",r:\"2\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\",{cx:\"22.5\",cy:\"8\",r:\"2\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\",{cx:\"31\",cy:\"9\",r:\"2\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\",{cx:\"39\",cy:\"12\",r:\"2\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 11,38.5 A 35,35 1 0 0 34,38.5\",style:{fill:\"none\",stroke:\"#000000\",strokeLinecap:\"butt\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\",Object.assign({style:{fill:\"none\",stroke:\"#ffffff\"}},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 11,29 A 35,35 1 0 1 34,29\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 12.5,31.5 L 32.5,31.5\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 11.5,34.5 A 35,35 1 0 0 33.5,34.5\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 10.5,37.5 A 35,35 1 0 0 34.5,37.5\"})]}))]}))})),bK:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({xmlns:\"http://www.w3.org/2000/svg\",version:\"1.1\",width:\"45\",height:\"45\"},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\",Object.assign({style:{fill:\"none\",fillOpacity:\"1\",fillRule:\"evenodd\",stroke:\"#000000\",strokeWidth:\"1.5\",strokeLinecap:\"round\",strokeLinejoin:\"round\",strokeMiterlimit:\"4\",strokeDasharray:\"none\",strokeOpacity:\"1\"}},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 22.5,11.63 L 22.5,6\",style:{fill:\"none\",stroke:\"#000000\",strokeLinejoin:\"miter\"},id:\"path6570\"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\",style:{fill:\"#000000\",fillOpacity:\"1\",strokeLinecap:\"butt\",strokeLinejoin:\"miter\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37\",style:{fill:\"#000000\",stroke:\"#000000\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 20,8 L 25,8\",style:{fill:\"none\",stroke:\"#000000\",strokeLinejoin:\"miter\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.5,26.6 L 22.5,24.5 C 20,18 10.85,14 6.97,19.85 C 4.5,25.5 13,29.5 13,29.5\",style:{fill:\"none\",stroke:\"#ffffff\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{d:\"M 12.5,30 C 18,27 27,27 32.5,30 M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5 M 12.5,37 C 18,34 27,34 32.5,37\",style:{fill:\"none\",stroke:\"#ffffff\"}})]}))}))};function Yt(e,t,r){const n=t/8,o=\"white\"===e?Ft:$t;return{x:(\"white\"===e?Wt:Ut)[r[0]]*n+n/2,y:o[parseInt(r[1],10)-1]*n+n/2}}function Kt(e){return\"start\"===e?Bt:\"string\"==typeof e?function(e){if(!function(e){e=e.replace(/ .+$/,\"\"),e=function(e){return e.replace(/8/g,\"11111111\").replace(/7/g,\"1111111\").replace(/6/g,\"111111\").replace(/5/g,\"11111\").replace(/4/g,\"1111\").replace(/3/g,\"111\").replace(/2/g,\"11\")}(e);const t=e.split(\"/\");if(8!==t.length)return!1;for(let e=0;e<8;e++)if(8!==t[e].length||-1!==t[e].search(/[^kqrnbpKQRNBP1]/))return!1;return!0}(e))return{};const t=(e=e.replace(/ .+$/,\"\")).split(\"/\"),r={};let n=8;for(let e=0;e<8;e++){const o=t[e].split(\"\");let i=0;for(let e=0;e<o.length;e++)if(-1!==o[e].search(/[1-8]/)){i+=parseInt(o[e],10)}else{r[Ht[i]+n]=Xt(o[e]),i+=1}n-=1}return r}(e):e}function Xt(e){return e.toLowerCase()===e?\"b\"+e.toUpperCase():\"w\"+e.toUpperCase()}const Gt=e=>Array.from(e).map((e=>e.split(\",\"))),Qt=(e,t=!0,r)=>{const[n,o]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Set),[s,c]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{e&&(0!==e.length||n.size>0)&&o((e=>new Set(null==e?void 0:e.map((e=>e.join(\",\")))))(e))}),[e]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{null==r||r(Gt(n))}),[n]);return{arrows:Gt(n),newArrow:s,clearArrows:function(){o(new Set),c(void 0)},removeArrow:(e,t)=>{let r;const i=Array.from(n);for(const[n]of i.entries())i[n][0]===e&&i[n][1]===t&&(o((e=>{const t=[...e];return t.splice(n,1),new Set(t)})),r=[e,t]);return Boolean(r)},drawNewArrow:(e,r)=>{t&&e!==r&&c([e,r])},setArrows:o,onArrowDrawEnd:(e,t)=>{if(e===t)return;const r=`${e},${t}`,i=new Set(n);i.has(r)?i.delete(r):i.add(r),c(void 0),o(i)}}},Jt=(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({}),Zt=()=>(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Jt),er=(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((({animationDuration:t=300,areArrowsAllowed:r=!0,arePiecesDraggable:n=!0,arePremovesAllowed:o=!1,boardOrientation:s=\"white\",boardWidth:c,children:u,clearPremovesOnRightClick:l=!0,customArrows:d,customArrowColor:h=\"rgb(255,170,0)\",customBoardStyle:g,customDarkSquareStyle:v={backgroundColor:\"#B58863\"},customDropSquareStyle:m={boxShadow:\"inset 0 0 1px 6px rgba(255,255,255,0.75)\"},customLightSquareStyle:y={backgroundColor:\"#F0D9B5\"},customPieces:b,customPremoveDarkSquareStyle:O={backgroundColor:\"#A42323\"},customPremoveLightSquareStyle:w={backgroundColor:\"#BD2828\"},customSquare:S=\"div\",customSquareStyles:D,dropOffBoardAction:C=\"snapback\",id:T=0,isDraggablePiece:E=(()=>!0),getPositionObject:I=(()=>{}),onArrowsChange:k=(()=>{}),onDragOverSquare:L=(()=>{}),onMouseOutSquare:P=(()=>{}),onMouseOverSquare:x=(()=>{}),onPieceClick:M=(()=>{}),onPieceDragBegin:N=(()=>{}),onPieceDragEnd:j=(()=>{}),onPieceDrop:R=(()=>!0),onPromotionPieceSelect:A,onSquareClick:q=(()=>{}),onSquareRightClick:_=(()=>{}),position:z=\"start\",promotionDialogVariant:H=\"default\",promotionToSquare:B=null,showBoardNotation:W=!0,showPromotionDialog:U=!1,snapToCursor:F=!0,autoPromoteToQueen:$=!1},V)=>{const[Y,K]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Kt(z)),[X,G]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({removed:{},added:{}}),[Q,J]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(void 0),[Z,ee]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(U&&!$),[te,re]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null),[ne,oe]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(B),[ie,se]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]),ae=(0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(ie),[ce,ue]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(),[le,de]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Object.assign(Object.assign({},Vt),b)),[he,ge]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1),[fe,pe]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(),[ve,me]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1);(0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(V,(()=>({clearPremoves(e=!0){Ce(e)}}))),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{de(Object.assign(Object.assign({},Vt),b))}),[b]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{ee(U),oe(B)}),[B,U]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{var e,r,n;Te();const i=Kt(z),s=function(e,t){const r={removed:{},added:{}};return Object.keys(e).forEach((n=>{t[n]!==e[n]&&(r.removed[n]=e[n])})),Object.keys(t).forEach((n=>{e[n]!==t[n]&&(r.added[n]=t[n])})),r}(Y,i),a=(null===(e=Object.keys(s.added))||void 0===e?void 0:e.length)<=2?null===(n=null===(r=Object.entries(s.added))||void 0===r?void 0:r[0])||void 0===n?void 0:n[1][0]:void 0;if(ve)K(i),me(!1),o&&De(a),fe&&clearTimeout(fe);else if(he)K(i),me(!1),o&&De(a);else{!function(e){let t=!1;return Object.keys(Bt).forEach((r=>{e[r]!==Bt[r]&&(t=!0)})),Object.keys(e).forEach((r=>{Bt[r]!==e[r]&&(t=!0)})),t}(i)||void 0===Q?J(void 0):J(a),G(s),me(!0);const e=setTimeout((()=>{K(i),me(!1),o&&De(a)}),t);pe(e)}return ge(!1),I(i),Oe(),()=>{clearTimeout(fe)}}),[z]);const{arrows:ye,newArrow:be,clearArrows:Oe,drawNewArrow:we,onArrowDrawEnd:Se}=Qt(d,r,k);function De(e){if(0===ae.current.length)return;const t=ae.current[0];if(void 0!==t.piece[0]&&t.piece[0]!==e&&R.length){J(t.piece[0]),ge(!0);if(R(t.sourceSq,t.targetSq,t.piece)){const e=[...ae.current];e.shift(),ae.current=e,se([...e])}else Ce()}}function Ce(e=!0){e&&J(void 0),ae.current=[],se([])}function Te(){re(null),oe(null),ee(!1)}const Ee={animationDuration:t,arePiecesDraggable:n,arePremovesAllowed:o,boardOrientation:s,boardWidth:c,customArrowColor:h,customBoardStyle:g,customDarkSquareStyle:v,customDropSquareStyle:m,customLightSquareStyle:y,customPremoveDarkSquareStyle:O,customPremoveLightSquareStyle:w,customSquare:S,customSquareStyles:D,id:T,isDraggablePiece:E,onDragOverSquare:L,onMouseOutSquare:P,onMouseOverSquare:x,onPieceClick:M,onPieceDragBegin:N,onPieceDragEnd:j,onPieceDrop:R,onPromotionPieceSelect:A,onSquareClick:q,showBoardNotation:W,snapToCursor:F,promotionDialogVariant:H,arrows:ye,newArrow:be,onArrowDrawEnd:Se,chessPieces:le,clearArrows:Oe,drawNewArrow:we,clearCurrentRightClickDown:function(){ue(void 0)},currentPosition:Y,handleSetPosition:function(e,t,r,n){if(e===t)return;if(Oe(),o&&ve||o&&(Q===r[0]||ae.current.filter((e=>e.piece[0]===r[0])).length>0)){const n=[...ae.current];return n.push({sourceSq:e,targetSq:t,piece:r}),ae.current=n,se([...n]),void Te()}if(!o&&ve)return;const i=Object.assign({},Y);if(ge(!!n),J(r[0]),R.length){R(e,t,r)||Ce()}else\"trash\"!==C||t||delete i[e],delete i[e],i[t]=r,K(i);Te(),I(i)},isWaitingForAnimation:ve,lastPieceColour:Q,onRightClickDown:function(e){ue(e)},onRightClickUp:function(e){if(ce){if(ce===e)return ue(void 0),l&&Ce(!1),void _(e)}else ue(void 0)},positionDifferences:X,promoteFromSquare:te,promoteToSquare:ne,premoves:ie,setPromoteFromSquare:re,setPromoteToSquare:oe,setShowPromoteDialog:ee,showPromoteDialog:Z,autoPromoteToQueen:$,currentRightClickDown:ce};return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Jt.Provider,Object.assign({value:Ee},{children:u}))}));function tr({row:n,col:o}){const{boardOrientation:i,boardWidth:s,customDarkSquareStyle:a,customLightSquareStyle:c}=Zt(),u=c.backgroundColor,l=a.backgroundColor,d=0===o,h=7===n;function g(){return\"white\"===i?8-n:n+1}function f(){return\"black\"===i?Ht[7-o]:Ht[o]}return d&&h?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment,{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",Object.assign({style:Object.assign(Object.assign({zIndex:3,position:\"absolute\"},{color:u}),nr(s))},{children:g()})),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",Object.assign({style:Object.assign(Object.assign({zIndex:3,position:\"absolute\"},{color:u}),rr(s))},{children:f()}))]}):h?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",Object.assign({style:Object.assign(Object.assign({zIndex:3,position:\"absolute\"},{color:o%2!=0?l:u}),rr(s))},{children:f()})):d?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",Object.assign({style:Object.assign(Object.assign({zIndex:3,position:\"absolute\"},{color:n%2==0?l:u}),nr(s))},{children:g()})):null}const rr=e=>({alignSelf:\"flex-end\",paddingLeft:e/8-e/48,fontSize:e/48}),nr=e=>({alignSelf:\"flex-start\",paddingRight:e/8-e/48,fontSize:e/48});function or({isPremovedPiece:t=!1,piece:r,square:n,squares:o}){const{animationDuration:s,arePiecesDraggable:c,arePremovesAllowed:u,boardWidth:l,chessPieces:d,currentPosition:h,id:g,isDraggablePiece:f,isWaitingForAnimation:p,onPieceClick:v,onPieceDragBegin:m,onPieceDragEnd:y,positionDifferences:b,premoves:O}=Zt(),[w,S]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({opacity:1,zIndex:5,touchAction:\"none\",cursor:c&&f({piece:r,sourceSquare:n})?\"-webkit-grab\":\"default\"}),[{canDrag:D,isDragging:C},T,E]=tt((()=>({type:\"piece\",item:()=>(m(r,n),{piece:r,square:n,id:g}),end:()=>y(r,n),collect:e=>({canDrag:f({piece:r,sourceSquare:n}),isDragging:!!e.isDragging()})})),[r,n,h,g]);return E((Ct||(Ct=new Image,Ct.src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"),Ct),{captureDraggingState:!0}),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{S((e=>Object.assign(Object.assign({},e),{opacity:C?0:1})))}),[C]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{if(!u)return;let e=!1;!t&&O.find((e=>e.targetSq===n))&&(e=!0),O.find((e=>e.sourceSq===n&&e.piece===r))&&(e=!0),S((t=>Object.assign(Object.assign({},t),{display:e?\"none\":\"unset\"})))}),[h,O]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{var e;const r=null===(e=b.removed)||void 0===e?void 0:e[n];if(!b.added)return;const i=Object.entries(b.added).find((([e,t])=>t===r||\"P\"===(null==r?void 0:r[1])&&(\"1\"===e[1]||\"8\"===e[1])));if(p&&r&&i&&!t){const{sourceSq:e,targetSq:t}=(a=n,c=i[0],{sourceSq:o[a],targetSq:o[c]});e&&t&&S((r=>Object.assign(Object.assign({},r),{transform:`translate(${t.x-e.x}px, ${t.y-e.y}px)`,transition:`transform ${s}ms`,zIndex:6})))}var a,c}),[b]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{const{sourceSq:e}={sourceSq:o[n]};e&&S((e=>Object.assign(Object.assign({},e),{transform:\"translate(0px, 0px)\",transition:\"transform 0ms\"})))}),[h]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{S((e=>Object.assign(Object.assign({},e),{cursor:c&&f({piece:r,sourceSquare:n})?\"-webkit-grab\":\"default\"})))}),[n,h,c]),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",Object.assign({ref:c&&D?T:null,onClick:()=>v(r),\"data-piece\":r,style:w},{children:\"function\"==typeof d[r]?d[r]({squareWidth:l/8,isDragging:C}):(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({viewBox:\"1 1 43 43\",width:l/8,height:l/8},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\",{children:d[r]})}))}))}function ir({square:t,squareColor:r,setSquares:n,squareHasPremove:o,children:s}){const a=(0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null),{boardWidth:c,boardOrientation:u,clearArrows:l,currentPosition:d,customBoardStyle:h,customDarkSquareStyle:g,customDropSquareStyle:p,customLightSquareStyle:v,customPremoveDarkSquareStyle:m,customPremoveLightSquareStyle:y,customSquare:b,customSquareStyles:O,handleSetPosition:w,isWaitingForAnimation:S,lastPieceColour:D,onDragOverSquare:C,onMouseOutSquare:T,onMouseOverSquare:E,onPieceDrop:I,onRightClickDown:k,onRightClickUp:L,onSquareClick:P,setPromoteFromSquare:x,setPromoteToSquare:M,setShowPromoteDialog:N,autoPromoteToQueen:j,currentRightClickDown:R,drawNewArrow:A,onArrowDrawEnd:q}=Zt(),[{isOver:_},z]=it((()=>({accept:\"piece\",drop:H,collect:e=>({isOver:!!e.isOver()})})),[t,d,I,S,D]);function H(e){Math.abs(e.square[0].charCodeAt(0)-t[0].charCodeAt(0))<=1&&(\"wP\"===e.piece&&\"8\"===t[1]||\"bP\"===e.piece&&\"1\"===t[1])?j?w(e.square,t,\"8\"===t[1]?\"wQ\":\"bQ\"):(x(e.square),M(t),N(!0)):w(e.square,t,e.piece,!0)}(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{if(a.current){const{x:e,y:r}=a.current.getBoundingClientRect();n((n=>Object.assign(Object.assign({},n),{[t]:{x:e,y:r}})))}}),[c,u]);const B=Object.assign(Object.assign(Object.assign(Object.assign({},cr(t,u,h)),\"black\"===r?g:v),o&&(\"black\"===r?m:y)),_&&p);return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",Object.assign({ref:z,style:B,\"data-square-color\":r,\"data-square\":t,onMouseOver:e=>{2===e.buttons&&R&&A(R,t),e.relatedTarget&&e.currentTarget.contains(e.relatedTarget)||E(t)},onMouseOut:e=>{e.relatedTarget&&e.currentTarget.contains(e.relatedTarget)||T(t)},onMouseDown:e=>{2===e.button&&k(t)},onMouseUp:e=>{2===e.button&&(R&&q(R,t),L(t))},onDragEnter:()=>C(t),onClick:()=>{P(t),l()},onContextMenu:e=>{e.preventDefault()}},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(b,\"string\"==typeof b?Object.assign({ref:a,style:Object.assign(Object.assign(Object.assign({},ar(c)),sr),!o&&(null==O?void 0:O[t]))},{children:s}):Object.assign({ref:a,square:t,squareColor:r,style:Object.assign(Object.assign(Object.assign({},ar(c)),sr),!o&&(null==O?void 0:O[t]))},{children:s}))}))}const sr={display:\"flex\",justifyContent:\"center\"},ar=e=>({width:e/8,height:e/8}),cr=(e,t,r)=>(null==r?void 0:r.borderRadius)?\"a1\"===e?\"white\"===t?{borderBottomLeftRadius:r.borderRadius}:{borderTopRightRadius:r.borderRadius}:\"a8\"===e?\"white\"===t?{borderTopLeftRadius:r.borderRadius}:{borderBottomRightRadius:r.borderRadius}:\"h1\"===e?\"white\"===t?{borderBottomRightRadius:r.borderRadius}:{borderTopLeftRadius:r.borderRadius}:\"h8\"===e?\"white\"===t?{borderTopRightRadius:r.borderRadius}:{borderBottomLeftRadius:r.borderRadius}:{}:{};function ur(){const[r,n]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({}),{boardOrientation:o,boardWidth:i,currentPosition:s,customBoardStyle:c,id:u,premoves:l,showBoardNotation:d}=Zt();return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",Object.assign({\"data-boardid\":u,style:Object.assign(Object.assign({},lr(i)),c)},{children:[...Array(8)].map(((a,c)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",Object.assign({style:{display:\"flex\",flexWrap:\"nowrap\",width:i}},{children:[...Array(8)].map(((i,a)=>{const u=\"black\"===o?Ht[7-a]+(c+1):Ht[a]+(8-c),h=a%2==c%2?\"white\":\"black\",g=l.find((e=>e.sourceSq===u||e.targetSq===u)),f=l.find((e=>e.targetSq===u));return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(ir,Object.assign({square:u,squareColor:h,setSquares:n,squareHasPremove:!!g},{children:[s[u]&&(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(or,{piece:s[u],square:u,squares:r}),f&&(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(or,{isPremovedPiece:!0,piece:f.piece,square:u,squares:r}),d&&(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(tr,{row:c,col:a})]}),`${a}${c}`)}))}),c.toString())))}))}const lr=e=>({cursor:\"default\",height:e,width:e}),dr=()=>{const{arrows:r,newArrow:n,boardOrientation:o,boardWidth:i,customArrowColor:s}=Zt(),a=[...r,n].filter(Boolean);return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({width:i,height:i,style:{position:\"absolute\",top:\"0\",left:\"0\",pointerEvents:\"none\",zIndex:\"10\"}},{children:a.map(((n,a)=>{const c=Yt(o,i,n[0]),u=Yt(o,i,n[1]);let l=i/32;const d=a===r.length;r.some((e=>e[0]!==n[0]&&e[1]===n[1]))&&!d&&(l=i/16);const h=u.x-c.x,g=u.y-c.y,f=Math.hypot(g,h),p={x:c.x+h*(f-l)/f,y:c.y+g*(f-l)/f};return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_1__.Fragment,{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"marker\",Object.assign({id:\"arrowhead\",markerWidth:\"2\",markerHeight:\"2.5\",refX:\"1.25\",refY:\"1.25\",orient:\"auto\"},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polygon\",{points:\"0.3 0, 2 1.25, 0.3 2.5\",fill:s})})),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"line\",{x1:c.x,y1:c.y,x2:p.x,y2:p.y,opacity:d?\"0.5\":\"0.65\",stroke:s,strokeWidth:d?.9*i/36:i/36,markerEnd:\"url(#arrowhead)\"})]},`${n[0]}-${n[1]}${d?\"active\":\"\"}`)}))}))};function hr({option:t}){const[r,n]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1),{boardWidth:o,chessPieces:i,customDarkSquareStyle:s,customLightSquareStyle:c,handleSetPosition:u,onPromotionPieceSelect:l,promoteFromSquare:d,promoteToSquare:h,promotionDialogVariant:g}=Zt(),f=()=>{switch(t[1]){case\"Q\":return s.backgroundColor;case\"R\":return c.backgroundColor;case\"N\":return\"default\"===g?c.backgroundColor:s.backgroundColor;case\"B\":return\"default\"===g?s.backgroundColor:c.backgroundColor}};return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",Object.assign({onClick:()=>{(null==l?void 0:l.length)?l(t):u(d,h,t)},onMouseOver:()=>n(!0),onMouseOut:()=>n(!1),\"data-piece\":t,style:{cursor:\"pointer\",backgroundColor:r?f():`${f()}aa`,borderRadius:\"4px\",transition:\"all 0.1s ease-out\"}},{children:\"function\"==typeof i[t]?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",Object.assign({style:{transition:\"all 0.1s ease-out\",transform:r?\"scale(1)\":\"scale(0.85)\"}},{children:i[t]({squareWidth:o/8,isDragging:!1})})):(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({viewBox:\"1 1 43 43\",width:o/8,height:o/8,style:{transition:\"all 0.1s ease-out\",transform:r?\"scale(1)\":\"scale(0.85)\"}},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\",{children:i[t]})}))}))}function gr(){const{boardOrientation:t,boardWidth:r,promotionDialogVariant:n,promoteToSquare:o}=Zt(),i=\"1\"===(null==o?void 0:o[1])?\"b\":\"w\",s=[`${null!=i?i:\"w\"}Q`,`${null!=i?i:\"w\"}R`,`${null!=i?i:\"w\"}N`,`${null!=i?i:\"w\"}B`],a={default:{display:\"grid\",gridTemplateColumns:\"1fr 1fr\",transform:`translate(${-r/8}px, ${-r/8}px)`},vertical:{transform:`translate(${-r/16}px, ${-r/16}px)`},modal:{display:\"flex\",justifyContent:\"center\",alignItems:\"center\",transform:`translate(0px, ${3*r/8}px)`,width:\"100%\",height:r/4+\"px\",top:0,backgroundColor:\"white\",left:0}},c=Yt(t,r,o||\"a8\");return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",Object.assign({style:Object.assign({position:\"absolute\",top:`${null==c?void 0:c.y}px`,left:`${null==c?void 0:c.x}px`,zIndex:1e3},a[n]),title:\"Choose promotion piece\"},{children:s.map((t=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(hr,{option:t},t)))}))}const fr={whiteKing:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({xmlns:\"http://www.w3.org/2000/svg\",version:\"1.1\",style:{shapeRendering:\"geometricPrecision\",textRendering:\"geometricPrecision\",imageRendering:\"crisp-edges\"},viewBox:\"0 0 4210 12970\",x:\"0px\",y:\"0px\",fillRule:\"evenodd\",clipRule:\"evenodd\",width:\"250\",height:\"250\"},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\",{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\",{style:{fill:\"black\",fillRule:\"nonzero\"},d:\"M2105 0c169,0 286,160 249,315l200 0c-172,266 -231,479 -256,792 315,-24 530,-86 792,-255l0 897c-265,-171 -479,-231 -792,-256 18,234 75,495 185,682l339 0c233,0 369,269 225,456l545 0 -595 1916c130,94 158,275 59,402 465,0 416,568 51,568l-334 0 465 2867 332 0c250,0 381,306 199,485 162,63 273,220 273,399l0 633 168 0 0 475c-1403,0 -2807,0 -4210,0l0 -475 167 0 0 -633c0,-179 112,-336 274,-399 -181,-178 -52,-485 199,-485l332 0 465 -2867 -335 0c-353,0 -418,-568 51,-568 -98,-127 -70,-308 59,-402l-594 -1916c181,0 363,0 545,0 -144,-187 -9,-456 225,-456l339 0c110,-187 167,-448 185,-682 -315,25 -530,87 -793,256l0 -897c266,171 480,231 793,255 -25,-315 -87,-529 -256,-792l199 0c-36,-155 81,-315 250,-315zm-1994 10012l0 253 3988 0 0 -253c-1330,0 -2659,0 -3988,0zm484 -1060c-174,0 -316,142 -316,316l0 633 3652 0 0 -633c0,-174 -142,-316 -316,-316 -1007,0 -2013,0 -3020,0zm45 -457c-230,0 -225,345 0,345l2930 0c230,0 225,-345 0,-345 -977,0 -1953,0 -2930,0zm2020 -2978l-1111 0 -465 2867 2041 0 -465 -2867zm-1558 -456c-229,0 -224,345 0,345 669,0 1337,0 2005,0 230,0 225,-345 0,-345 -668,0 -1336,0 -2005,0zm1730 -457l-1454 0c-229,0 -224,345 0,345l1454 0c229,0 224,-345 0,-345zm-2064 -1862l544 1751c529,0 1057,0 1586,0l544 -1751c-892,0 -1783,0 -2674,0zm1085 -567l504 0c-126,-247 -163,-526 -177,-800 273,15 553,52 800,177l0 -504c-247,126 -527,163 -800,177 14,-273 51,-552 177,-799 -168,0 -336,0 -504,0 125,247 162,526 177,799 -274,-14 -553,-51 -800,-177l0 504c247,-125 527,-162 800,-177 -15,274 -52,553 -177,800zm969 111l-1434 0c-230,0 -225,345 0,345l1434 0c230,0 225,-345 0,-345zm-717 -2175c-105,0 -175,109 -133,204l266 0c42,-96 -30,-205 -133,-204z\"})})}))};function pr({children:t}){try{return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment,{children:t})}catch(t){return console.log(t),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(vr,{showError:!0})}}function vr({showError:r=!1}){return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\",Object.assign({style:{display:\"flex\",justifyContent:\"center\",alignItems:\"center\",flexDirection:\"column\"}},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",Object.assign({style:{width:250,height:250,transform:\"rotate(90deg)\"}},{children:fr.whiteKing})),r&&(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h1\",{children:\"Something went wrong\"})]}))}function mr(){const n=(0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null),{boardWidth:o,clearCurrentRightClickDown:s,onPromotionPieceSelect:a,setShowPromoteDialog:c,showPromoteDialog:u}=Zt();return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{function e(e){n.current&&!n.current.contains(e.target)&&s()}return document.addEventListener(\"mouseup\",e),()=>{document.removeEventListener(\"mouseup\",e)}}),[]),o?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\",Object.assign({ref:n,style:{position:\"relative\"}},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ur,{}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(dr,{}),u&&(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment,{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",{onClick:()=>{c(!1),null==a||a()},style:{position:\"absolute\",top:\"0\",left:\"0\",zIndex:\"100\",backgroundColor:\"rgba(22,21,18,.7)\",width:o,height:o}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(gr,{})]})]})):(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(vr,{})}function yr(){const{boardWidth:t,chessPieces:r,id:n,snapToCursor:o}=Zt(),s=function(e){const t=Je().getMonitor(),[r,n]=Re(t,e);return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>t.subscribeToOffsetChange(n))),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>t.subscribeToStateChange(n))),r}((e=>({item:e.getItem(),clientOffset:e.getClientOffset(),sourceClientOffset:e.getSourceClientOffset(),isDragging:e.isDragging()}))),{isDragging:a,item:u,clientOffset:l,sourceClientOffset:d}=s,h=(0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(((e,r)=>{if(!e||!r)return{display:\"none\"};let{x:n,y:i}=o?e:r;if(o){const e=t/8/2;n-=e,i-=e}const s=`translate(${n}px, ${i}px)`;return{transform:s,WebkitTransform:s,touchAction:\"none\"}}),[t,o]);return a&&u.id===n?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",Object.assign({style:{position:\"fixed\",pointerEvents:\"none\",zIndex:10,left:0,top:0}},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",Object.assign({style:h(l,d)},{children:\"function\"==typeof r[u.piece]?r[u.piece]({squareWidth:t/8,isDragging:!0}):(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\",Object.assign({viewBox:\"1 1 43 43\",width:t/8,height:t/8},{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\",{children:r[u.piece]})}))}))})):null}const br=(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(((r,n)=>{const{customDndBackend:o,customDndBackendOptions:s}=r,c=function(e,t){var r={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(null!=e&&\"function\"==typeof Object.getOwnPropertySymbols){var o=0;for(n=Object.getOwnPropertySymbols(e);o<n.length;o++)t.indexOf(n[o])<0&&Object.prototype.propertyIsEnumerable.call(e,n[o])&&(r[n[o]]=e[n[o]])}return r}(r,[\"customDndBackend\",\"customDndBackendOptions\"]),[u,l]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(),[d,h]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1),[g,p]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1),[v,m]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(r.boardWidth),y=(0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{p(\"ontouchstart\"in window),h(!0),l(window)}),[]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((()=>{var e;if(void 0===r.boardWidth&&(null===(e=y.current)||void 0===e?void 0:e.offsetWidth)){const e=new ResizeObserver((()=>{var e;m(null===(e=y.current)||void 0===e?void 0:e.offsetWidth)}));return e.observe(y.current),()=>{e.disconnect()}}}),[y.current,u]);const b=o||(g?zt:kt);return d&&u?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(pr,{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\",Object.assign({style:{display:\"flex\",flexDirection:\"column\",width:\"100%\"}},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",{ref:y,style:{width:\"100%\"}}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(xe,Object.assign({backend:b,context:u,options:o?s:void 0},{children:v&&(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(er,Object.assign({boardWidth:v},c,{ref:n},{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(yr,{}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(mr,{})]}))}))]}))}):null}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWNoZXNzYm9hcmQvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeVQsUUFBUSxvREFBQyxFQUFFLHVCQUF1QixFQUFFLGNBQWMsb0NBQW9DLDZIQUE2SCxnRkFBZ0YsbUVBQW1FLElBQUksc0ZBQXNGLDJDQUEyQyxjQUFjLGdDQUFnQyx5QkFBeUIsZUFBZSxVQUFVLDZFQUE2RSxrQ0FBa0MsZUFBZSx3SEFBd0gsaUJBQWlCLGVBQWUscUhBQXFILGtCQUFrQixrQkFBa0IsK0RBQStELElBQUksVUFBVSxvRkFBb0YscURBQXFELGNBQWMsZUFBZSxNQUFNLEtBQW1DLGFBQWEsa0JBQWtCLE1BQU0scUhBQXFILE1BQW1DLENBQUMsQ0FBSSxxUUFBcVEsZ0VBQWdFLHdDQUF3QyxNQUFtQyxDQUFDLENBQUksMEVBQTBFLGlCQUFpQix3Q0FBd0MsTUFBbUMsQ0FBQyxDQUFJLDhFQUE4RSwwQkFBMEIsYUFBYSxxQkFBcUIsYUFBYSxxQkFBcUIsTUFBbUMsQ0FBQyxDQUFJLHlNQUF5TSxTQUFTLGNBQWMsd0NBQXdDLE1BQW1DLENBQUMsQ0FBSSwwRUFBMEUscUJBQXFCLE1BQW1DLENBQUMsQ0FBSSxvVEFBb1QsU0FBUyxnQ0FBZ0MsTUFBTSxxQkFBcUIsTUFBbUMsQ0FBQyxDQUFJLHlKQUF5SixTQUFTLG1CQUFtQix1QkFBdUIsY0FBYyxnQkFBZ0IseUNBQXlDLFlBQVksZ0NBQWdDLDRCQUE0QixvQ0FBb0Msb0JBQW9CLE1BQW1DLENBQUMsQ0FBSSxxWkFBcVosbUNBQW1DLE1BQW1DLENBQUMsQ0FBSSwrR0FBK0cscUJBQXFCLE1BQW1DLENBQUMsQ0FBSSx1Q0FBdUMsSUFBSSxjQUFjLFFBQVEsS0FBSyxrQkFBa0IsV0FBVyxLQUFLLFdBQVcsU0FBUyxVQUFVLFlBQVksTUFBTSw2REFBNkQsd0NBQXdDLE1BQW1DLENBQUMsQ0FBSyx5RUFBeUUsT0FBTyxlQUFlLEdBQUcsZ0JBQWdCLFVB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QUFNLEdBQUcsR0FBRyxJQUFJLEdBQUcsT0FBTyxHQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtY2hlc3Nib2FyZC9kaXN0L2luZGV4LmVzbS5qcz80N2M2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydHtqc3ggYXMgZSxqc3hzIGFzIHQsRnJhZ21lbnQgYXMgcn1mcm9tXCJyZWFjdC9qc3gtcnVudGltZVwiO2ltcG9ydHtjcmVhdGVDb250ZXh0IGFzIG4sbWVtbyBhcyBvLHVzZUVmZmVjdCBhcyBpLHVzZUxheW91dEVmZmVjdCBhcyBzLHVzZVN0YXRlIGFzIGEsdXNlQ2FsbGJhY2sgYXMgYyx1c2VNZW1vIGFzIHUsaXNWYWxpZEVsZW1lbnQgYXMgbCxjbG9uZUVsZW1lbnQgYXMgZCx1c2VDb250ZXh0IGFzIGgsZm9yd2FyZFJlZiBhcyBnLHVzZVJlZiBhcyBmLHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgcCxGcmFnbWVudCBhcyB2fWZyb21cInJlYWN0XCI7Y29uc3QgbT1uKHtkcmFnRHJvcE1hbmFnZXI6dm9pZCAwfSk7ZnVuY3Rpb24geShlKXtyZXR1cm5cIk1pbmlmaWVkIFJlZHV4IGVycm9yICNcIitlK1wiOyB2aXNpdCBodHRwczovL3JlZHV4LmpzLm9yZy9FcnJvcnM/Y29kZT1cIitlK1wiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMuIFwifXZhciBiPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLm9ic2VydmFibGV8fFwiQEBvYnNlcnZhYmxlXCIsTz1mdW5jdGlvbigpe3JldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoXCJcIikuam9pbihcIi5cIil9LHc9e0lOSVQ6XCJAQHJlZHV4L0lOSVRcIitPKCksUkVQTEFDRTpcIkBAcmVkdXgvUkVQTEFDRVwiK08oKSxQUk9CRV9VTktOT1dOX0FDVElPTjpmdW5jdGlvbigpe3JldHVyblwiQEByZWR1eC9QUk9CRV9VTktOT1dOX0FDVElPTlwiK08oKX19O2Z1bmN0aW9uIFMoZSl7aWYodm9pZCAwPT09ZSlyZXR1cm5cInVuZGVmaW5lZFwiO2lmKG51bGw9PT1lKXJldHVyblwibnVsbFwiO3ZhciB0PXR5cGVvZiBlO3N3aXRjaCh0KXtjYXNlXCJib29sZWFuXCI6Y2FzZVwic3RyaW5nXCI6Y2FzZVwibnVtYmVyXCI6Y2FzZVwic3ltYm9sXCI6Y2FzZVwiZnVuY3Rpb25cIjpyZXR1cm4gdH1pZihBcnJheS5pc0FycmF5KGUpKXJldHVyblwiYXJyYXlcIjtpZihmdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIERhdGV8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGUudG9EYXRlU3RyaW5nJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmdldERhdGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuc2V0RGF0ZX0oZSkpcmV0dXJuXCJkYXRlXCI7aWYoZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBFcnJvcnx8XCJzdHJpbmdcIj09dHlwZW9mIGUubWVzc2FnZSYmZS5jb25zdHJ1Y3RvciYmXCJudW1iZXJcIj09dHlwZW9mIGUuY29uc3RydWN0b3Iuc3RhY2tUcmFjZUxpbWl0fShlKSlyZXR1cm5cImVycm9yXCI7dmFyIHI9ZnVuY3Rpb24oZSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZS5jb25zdHJ1Y3Rvcj9lLmNvbnN0cnVjdG9yLm5hbWU6bnVsbH0oZSk7c3dpdGNoKHIpe2Nhc2VcIlN5bWJvbFwiOmNhc2VcIlByb21pc2VcIjpjYXNlXCJXZWFrTWFwXCI6Y2FzZVwiV2Vha1NldFwiOmNhc2VcIk1hcFwiOmNhc2VcIlNldFwiOnJldHVybiByfXJldHVybiB0LnNsaWNlKDgsLTEpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzL2csXCJcIil9ZnVuY3Rpb24gRChlKXt2YXIgdD10eXBlb2YgZTtyZXR1cm5cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiYodD1TKGUpKSx0fWZ1bmN0aW9uIEMoZSx0LHIpe3ZhciBuO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHJ8fFwiZnVuY3Rpb25cIj09dHlwZW9mIHImJlwiZnVuY3Rpb25cIj09dHlwZW9mIGFyZ3VtZW50c1szXSl0aHJvdyBuZXcgRXJyb3IoXCJwcm9kdWN0aW9uXCI9PT1wcm9jZXNzLmVudi5OT0RFX0VOVj95KDApOlwiSXQgbG9va3MgbGlrZSB5b3UgYXJlIHBhc3Npbmcgc2V2ZXJhbCBzdG9yZSBlbmhhbmNlcnMgdG8gY3JlYXRlU3RvcmUoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBJbnN0ZWFkLCBjb21wb3NlIHRoZW0gdG9nZXRoZXIgdG8gYSBzaW5nbGUgZnVuY3Rpb24uIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNjcmVhdGluZy1hLXN0b3JlLXdpdGgtZW5oYW5jZXJzIGZvciBhbiBleGFtcGxlLlwiKTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiZ2b2lkIDA9PT1yJiYocj10LHQ9dm9pZCAwKSx2b2lkIDAhPT1yKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiByKXRocm93IG5ldyBFcnJvcihcInByb2R1Y3Rpb25cIj09PXByb2Nlc3MuZW52Lk5PREVfRU5WP3koMSk6XCJFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICdcIitEKHIpK1wiJ1wiKTtyZXR1cm4gcihDKShlLHQpfWlmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwicHJvZHVjdGlvblwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/eSgyKTpcIkV4cGVjdGVkIHRoZSByb290IHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICdcIitEKGUpK1wiJ1wiKTt2YXIgbz1lLGk9dCxzPVtdLGE9cyxjPSExO2Z1bmN0aW9uIHUoKXthPT09cyYmKGE9cy5zbGljZSgpKX1mdW5jdGlvbiBsKCl7aWYoYyl0aHJvdyBuZXcgRXJyb3IoXCJwcm9kdWN0aW9uXCI9PT1wcm9jZXNzLmVudi5OT0RFX0VOVj95KDMpOlwiWW91IG1heSBub3QgY2FsbCBzdG9yZS5nZXRTdGF0ZSgpIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gVGhlIHJlZHVjZXIgaGFzIGFscmVhZHkgcmVjZWl2ZWQgdGhlIHN0YXRlIGFzIGFuIGFyZ3VtZW50LiBQYXNzIGl0IGRvd24gZnJvbSB0aGUgdG9wIHJlZHVjZXIgaW5zdGVhZCBvZiByZWFkaW5nIGl0IGZyb20gdGhlIHN0b3JlLlwiKTtyZXR1cm4gaX1mdW5jdGlvbiBkKGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwicHJvZHVjdGlvblwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/eSg0KTpcIkV4cGVjdGVkIHRoZSBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJ1wiK0QoZSkrXCInXCIpO2lmKGMpdGhyb3cgbmV3IEVycm9yKFwicHJvZHVjdGlvblwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/eSg1KTpcIllvdSBtYXkgbm90IGNhbGwgc3RvcmUuc3Vic2NyaWJlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiBJZiB5b3Ugd291bGQgbGlrZSB0byBiZSBub3RpZmllZCBhZnRlciB0aGUgc3RvcmUgaGFzIGJlZW4gdXBkYXRlZCwgc3Vic2NyaWJlIGZyb20gYSBjb21wb25lbnQgYW5kIGludm9rZSBzdG9yZS5nZXRTdGF0ZSgpIGluIHRoZSBjYWxsYmFjayB0byBhY2Nlc3MgdGhlIGxhdGVzdCBzdGF0ZS4gU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS9zdG9yZSNzdWJzY3JpYmVsaXN0ZW5lciBmb3IgbW9yZSBkZXRhaWxzLlwiKTt2YXIgdD0hMDtyZXR1cm4gdSgpLGEucHVzaChlKSxmdW5jdGlvbigpe2lmKHQpe2lmKGMpdGhyb3cgbmV3IEVycm9yKFwicHJvZHVjdGlvblwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/eSg2KTpcIllvdSBtYXkgbm90IHVuc3Vic2NyaWJlIGZyb20gYSBzdG9yZSBsaXN0ZW5lciB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9hcGkvc3RvcmUjc3Vic2NyaWJlbGlzdGVuZXIgZm9yIG1vcmUgZGV0YWlscy5cIik7dD0hMSx1KCk7dmFyIHI9YS5pbmRleE9mKGUpO2Euc3BsaWNlKHIsMSkscz1udWxsfX19ZnVuY3Rpb24gaChlKXtpZighZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVybiExO2Zvcih2YXIgdD1lO251bGwhPT1PYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7KXQ9T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO3JldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSk9PT10fShlKSl0aHJvdyBuZXcgRXJyb3IoXCJwcm9kdWN0aW9uXCI9PT1wcm9jZXNzLmVudi5OT0RFX0VOVj95KDcpOlwiQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuIEluc3RlYWQsIHRoZSBhY3R1YWwgdHlwZSB3YXM6ICdcIitEKGUpK1wiJy4gWW91IG1heSBuZWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRvIHlvdXIgc3RvcmUgc2V0dXAgdG8gaGFuZGxlIGRpc3BhdGNoaW5nIG90aGVyIHZhbHVlcywgc3VjaCBhcyAncmVkdXgtdGh1bmsnIHRvIGhhbmRsZSBkaXNwYXRjaGluZyBmdW5jdGlvbnMuIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNtaWRkbGV3YXJlIGFuZCBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNi1hc3luYy1sb2dpYyN1c2luZy10aGUtcmVkdXgtdGh1bmstbWlkZGxld2FyZSBmb3IgZXhhbXBsZXMuXCIpO2lmKHZvaWQgMD09PWUudHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJwcm9kdWN0aW9uXCI9PT1wcm9jZXNzLmVudi5OT0RFX0VOVj95KDgpOidBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGFuIGFjdGlvbiB0eXBlIHN0cmluZyBjb25zdGFudC4nKTtpZihjKXRocm93IG5ldyBFcnJvcihcInByb2R1Y3Rpb25cIj09PXByb2Nlc3MuZW52Lk5PREVfRU5WP3koOSk6XCJSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuXCIpO3RyeXtjPSEwLGk9byhpLGUpfWZpbmFsbHl7Yz0hMX1mb3IodmFyIHQ9cz1hLHI9MDtyPHQubGVuZ3RoO3IrKyl7KDAsdFtyXSkoKX1yZXR1cm4gZX1yZXR1cm4gaCh7dHlwZTp3LklOSVR9KSwobj17ZGlzcGF0Y2g6aCxzdWJzY3JpYmU6ZCxnZXRTdGF0ZTpsLHJlcGxhY2VSZWR1Y2VyOmZ1bmN0aW9uKGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwicHJvZHVjdGlvblwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/eSgxMCk6XCJFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICdcIitEKGUpKTtvPWUsaCh7dHlwZTp3LlJFUExBQ0V9KX19KVtiXT1mdW5jdGlvbigpe3ZhciBlLHQ9ZDtyZXR1cm4oZT17c3Vic2NyaWJlOmZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJwcm9kdWN0aW9uXCI9PT1wcm9jZXNzLmVudi5OT0RFX0VOVj95KDExKTpcIkV4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuIEluc3RlYWQsIHJlY2VpdmVkOiAnXCIrRChlKStcIidcIik7ZnVuY3Rpb24gcigpe2UubmV4dCYmZS5uZXh0KGwoKSl9cmV0dXJuIHIoKSx7dW5zdWJzY3JpYmU6dChyKX19fSlbYl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sZX0sbn1mdW5jdGlvbiBUKCl7fWZ1bmN0aW9uIEUoZSx0LC4uLnIpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzJiZcInByb2R1Y3Rpb25cIj09PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZ2b2lkIDA9PT10KXRocm93IG5ldyBFcnJvcihcImludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50XCIpO2lmKCFlKXtsZXQgZTtpZih2b2lkIDA9PT10KWU9bmV3IEVycm9yKFwiTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy5cIik7ZWxzZXtsZXQgbj0wO2U9bmV3IEVycm9yKHQucmVwbGFjZSgvJXMvZywoZnVuY3Rpb24oKXtyZXR1cm4gcltuKytdfSkpKSxlLm5hbWU9XCJJbnZhcmlhbnQgVmlvbGF0aW9uXCJ9dGhyb3cgZS5mcmFtZXNUb1BvcD0xLGV9fWZ1bmN0aW9uIEkoZSl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGV9XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmXCJzdHJpbmdcIj09dHlwZW9mIFQubmFtZSYmXCJpc0NydXNoZWRcIiE9PVQubmFtZSYmZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGNvbnNvbGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGNvbnNvbGUuZXJyb3ImJmNvbnNvbGUuZXJyb3IoZSk7dHJ5e3Rocm93IG5ldyBFcnJvcihlKX1jYXRjaChlKXt9fSgnWW91IGFyZSBjdXJyZW50bHkgdXNpbmcgbWluaWZpZWQgY29kZSBvdXRzaWRlIG9mIE5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIi4gVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gWW91IGNhbiB1c2UgbG9vc2UtZW52aWZ5IChodHRwczovL2dpdGh1Yi5jb20vemVydG9zaC9sb29zZS1lbnZpZnkpIGZvciBicm93c2VyaWZ5IG9yIHNldHRpbmcgbW9kZSB0byBwcm9kdWN0aW9uIGluIHdlYnBhY2sgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uY2VwdHMvbW9kZS8pIHRvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7Y29uc3Qgaz1cImRuZC1jb3JlL0lOSVRfQ09PUkRTXCIsTD1cImRuZC1jb3JlL0JFR0lOX0RSQUdcIixQPVwiZG5kLWNvcmUvUFVCTElTSF9EUkFHX1NPVVJDRVwiLHg9XCJkbmQtY29yZS9IT1ZFUlwiLE09XCJkbmQtY29yZS9EUk9QXCIsTj1cImRuZC1jb3JlL0VORF9EUkFHXCI7ZnVuY3Rpb24gaihlLHQpe3JldHVybnt0eXBlOmsscGF5bG9hZDp7c291cmNlQ2xpZW50T2Zmc2V0OnR8fG51bGwsY2xpZW50T2Zmc2V0OmV8fG51bGx9fX1jb25zdCBSPXt0eXBlOmsscGF5bG9hZDp7Y2xpZW50T2Zmc2V0Om51bGwsc291cmNlQ2xpZW50T2Zmc2V0Om51bGx9fTtmdW5jdGlvbiBBKGUpe3JldHVybiBmdW5jdGlvbih0PVtdLHI9e3B1Ymxpc2hTb3VyY2U6ITB9KXtjb25zdHtwdWJsaXNoU291cmNlOm49ITAsY2xpZW50T2Zmc2V0Om8sZ2V0U291cmNlQ2xpZW50T2Zmc2V0Oml9PXIscz1lLmdldE1vbml0b3IoKSxhPWUuZ2V0UmVnaXN0cnkoKTtlLmRpc3BhdGNoKGoobykpLGZ1bmN0aW9uKGUsdCxyKXtFKCF0LmlzRHJhZ2dpbmcoKSxcIkNhbm5vdCBjYWxsIGJlZ2luRHJhZyB3aGlsZSBkcmFnZ2luZy5cIiksZS5mb3JFYWNoKChmdW5jdGlvbihlKXtFKHIuZ2V0U291cmNlKGUpLFwiRXhwZWN0ZWQgc291cmNlSWRzIHRvIGJlIHJlZ2lzdGVyZWQuXCIpfSkpfSh0LHMsYSk7Y29uc3QgYz1mdW5jdGlvbihlLHQpe2xldCByPW51bGw7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0paWYodC5jYW5EcmFnU291cmNlKGVbbl0pKXtyPWVbbl07YnJlYWt9cmV0dXJuIHJ9KHQscyk7aWYobnVsbD09YylyZXR1cm4gdm9pZCBlLmRpc3BhdGNoKFIpO2xldCB1PW51bGw7aWYobyl7aWYoIWkpdGhyb3cgbmV3IEVycm9yKFwiZ2V0U291cmNlQ2xpZW50T2Zmc2V0IG11c3QgYmUgZGVmaW5lZFwiKTshZnVuY3Rpb24oZSl7RShcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLFwiV2hlbiBjbGllbnRPZmZzZXQgaXMgcHJvdmlkZWQsIGdldFNvdXJjZUNsaWVudE9mZnNldCBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpfShpKSx1PWkoYyl9ZS5kaXNwYXRjaChqKG8sdSkpO2NvbnN0IGw9YS5nZXRTb3VyY2UoYykuYmVnaW5EcmFnKHMsYyk7aWYobnVsbD09bClyZXR1cm47IWZ1bmN0aW9uKGUpe0UoSShlKSxcIkl0ZW0gbXVzdCBiZSBhbiBvYmplY3QuXCIpfShsKSxhLnBpblNvdXJjZShjKTtjb25zdCBkPWEuZ2V0U291cmNlVHlwZShjKTtyZXR1cm57dHlwZTpMLHBheWxvYWQ6e2l0ZW1UeXBlOmQsaXRlbTpsLHNvdXJjZUlkOmMsY2xpZW50T2Zmc2V0Om98fG51bGwsc291cmNlQ2xpZW50T2Zmc2V0OnV8fG51bGwsaXNTb3VyY2VQdWJsaWM6ISFufX19fWZ1bmN0aW9uIHEoZSx0LHIpe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6cixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09cixlfWZ1bmN0aW9uIF8oZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIHI9bnVsbCE9YXJndW1lbnRzW3RdP2FyZ3VtZW50c1t0XTp7fSxuPU9iamVjdC5rZXlzKHIpO1wiZnVuY3Rpb25cIj09dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMmJihuPW4uY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocikuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLGUpLmVudW1lcmFibGV9KSkpKSxuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3EoZSx0LHJbdF0pfSkpfXJldHVybiBlfWZ1bmN0aW9uIHooZSl7cmV0dXJuIGZ1bmN0aW9uKHQ9e30pe2NvbnN0IHI9ZS5nZXRNb25pdG9yKCksbj1lLmdldFJlZ2lzdHJ5KCk7IWZ1bmN0aW9uKGUpe0UoZS5pc0RyYWdnaW5nKCksXCJDYW5ub3QgY2FsbCBkcm9wIHdoaWxlIG5vdCBkcmFnZ2luZy5cIiksRSghZS5kaWREcm9wKCksXCJDYW5ub3QgY2FsbCBkcm9wIHR3aWNlIGR1cmluZyBvbmUgZHJhZyBvcGVyYXRpb24uXCIpfShyKTtjb25zdCBvPWZ1bmN0aW9uKGUpe2NvbnN0IHQ9ZS5nZXRUYXJnZXRJZHMoKS5maWx0ZXIoZS5jYW5Ecm9wT25UYXJnZXQsZSk7cmV0dXJuIHQucmV2ZXJzZSgpLHR9KHIpO28uZm9yRWFjaCgoKG8saSk9Pntjb25zdCBzPWZ1bmN0aW9uKGUsdCxyLG4pe2NvbnN0IG89ci5nZXRUYXJnZXQoZSk7bGV0IGk9bz9vLmRyb3AobixlKTp2b2lkIDA7KGZ1bmN0aW9uKGUpe0Uodm9pZCAwPT09ZXx8SShlKSxcIkRyb3AgcmVzdWx0IG11c3QgZWl0aGVyIGJlIGFuIG9iamVjdCBvciB1bmRlZmluZWQuXCIpfSkoaSksdm9pZCAwPT09aSYmKGk9MD09PXQ/e306bi5nZXREcm9wUmVzdWx0KCkpO3JldHVybiBpfShvLGksbixyKSxhPXt0eXBlOk0scGF5bG9hZDp7ZHJvcFJlc3VsdDpfKHt9LHQscyl9fTtlLmRpc3BhdGNoKGEpfSkpfX1mdW5jdGlvbiBIKGUpe3JldHVybiBmdW5jdGlvbigpe2NvbnN0IHQ9ZS5nZXRNb25pdG9yKCkscj1lLmdldFJlZ2lzdHJ5KCk7IWZ1bmN0aW9uKGUpe0UoZS5pc0RyYWdnaW5nKCksXCJDYW5ub3QgY2FsbCBlbmREcmFnIHdoaWxlIG5vdCBkcmFnZ2luZy5cIil9KHQpO2NvbnN0IG49dC5nZXRTb3VyY2VJZCgpO2lmKG51bGwhPW4pe3IuZ2V0U291cmNlKG4sITApLmVuZERyYWcodCxuKSxyLnVucGluU291cmNlKCl9cmV0dXJue3R5cGU6Tn19fWZ1bmN0aW9uIEIoZSx0KXtyZXR1cm4gbnVsbD09PXQ/bnVsbD09PWU6QXJyYXkuaXNBcnJheShlKT9lLnNvbWUoKGU9PmU9PT10KSk6ZT09PXR9ZnVuY3Rpb24gVyhlKXtyZXR1cm4gZnVuY3Rpb24odCx7Y2xpZW50T2Zmc2V0OnJ9PXt9KXshZnVuY3Rpb24oZSl7RShBcnJheS5pc0FycmF5KGUpLFwiRXhwZWN0ZWQgdGFyZ2V0SWRzIHRvIGJlIGFuIGFycmF5LlwiKX0odCk7Y29uc3Qgbj10LnNsaWNlKDApLG89ZS5nZXRNb25pdG9yKCksaT1lLmdldFJlZ2lzdHJ5KCk7cmV0dXJuIGZ1bmN0aW9uKGUsdCxyKXtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl7Y29uc3Qgbz1lW25dO0IodC5nZXRUYXJnZXRUeXBlKG8pLHIpfHxlLnNwbGljZShuLDEpfX0obixpLG8uZ2V0SXRlbVR5cGUoKSksZnVuY3Rpb24oZSx0LHIpe0UodC5pc0RyYWdnaW5nKCksXCJDYW5ub3QgY2FsbCBob3ZlciB3aGlsZSBub3QgZHJhZ2dpbmcuXCIpLEUoIXQuZGlkRHJvcCgpLFwiQ2Fubm90IGNhbGwgaG92ZXIgYWZ0ZXIgZHJvcC5cIik7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IG49ZVt0XTtFKGUubGFzdEluZGV4T2Yobik9PT10LFwiRXhwZWN0ZWQgdGFyZ2V0SWRzIHRvIGJlIHVuaXF1ZSBpbiB0aGUgcGFzc2VkIGFycmF5LlwiKTtFKHIuZ2V0VGFyZ2V0KG4pLFwiRXhwZWN0ZWQgdGFyZ2V0SWRzIHRvIGJlIHJlZ2lzdGVyZWQuXCIpfX0obixvLGkpLGZ1bmN0aW9uKGUsdCxyKXtlLmZvckVhY2goKGZ1bmN0aW9uKGUpe3IuZ2V0VGFyZ2V0KGUpLmhvdmVyKHQsZSl9KSl9KG4sbyxpKSx7dHlwZTp4LHBheWxvYWQ6e3RhcmdldElkczpuLGNsaWVudE9mZnNldDpyfHxudWxsfX19fWZ1bmN0aW9uIFUoZSl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoZS5nZXRNb25pdG9yKCkuaXNEcmFnZ2luZygpKXJldHVybnt0eXBlOlB9fX1jbGFzcyBGe3JlY2VpdmVCYWNrZW5kKGUpe3RoaXMuYmFja2VuZD1lfWdldE1vbml0b3IoKXtyZXR1cm4gdGhpcy5tb25pdG9yfWdldEJhY2tlbmQoKXtyZXR1cm4gdGhpcy5iYWNrZW5kfWdldFJlZ2lzdHJ5KCl7cmV0dXJuIHRoaXMubW9uaXRvci5yZWdpc3RyeX1nZXRBY3Rpb25zKCl7Y29uc3QgZT10aGlzLHtkaXNwYXRjaDp0fT10aGlzLnN0b3JlO2NvbnN0IHI9ZnVuY3Rpb24oZSl7cmV0dXJue2JlZ2luRHJhZzpBKGUpLHB1Ymxpc2hEcmFnU291cmNlOlUoZSksaG92ZXI6VyhlKSxkcm9wOnooZSksZW5kRHJhZzpIKGUpfX0odGhpcyk7cmV0dXJuIE9iamVjdC5rZXlzKHIpLnJlZHVjZSgoKG4sbyk9Pntjb25zdCBpPXJbb107dmFyIHM7cmV0dXJuIG5bb109KHM9aSwoLi4ucik9Pntjb25zdCBuPXMuYXBwbHkoZSxyKTt2b2lkIDAhPT1uJiZ0KG4pfSksbn0pLHt9KX1kaXNwYXRjaChlKXt0aGlzLnN0b3JlLmRpc3BhdGNoKGUpfWNvbnN0cnVjdG9yKGUsdCl7dGhpcy5pc1NldFVwPSExLHRoaXMuaGFuZGxlUmVmQ291bnRDaGFuZ2U9KCk9Pntjb25zdCBlPXRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5yZWZDb3VudD4wO3RoaXMuYmFja2VuZCYmKGUmJiF0aGlzLmlzU2V0VXA/KHRoaXMuYmFja2VuZC5zZXR1cCgpLHRoaXMuaXNTZXRVcD0hMCk6IWUmJnRoaXMuaXNTZXRVcCYmKHRoaXMuYmFja2VuZC50ZWFyZG93bigpLHRoaXMuaXNTZXRVcD0hMSkpfSx0aGlzLnN0b3JlPWUsdGhpcy5tb25pdG9yPXQsZS5zdWJzY3JpYmUodGhpcy5oYW5kbGVSZWZDb3VudENoYW5nZSl9fWZ1bmN0aW9uICQoZSx0KXtyZXR1cm57eDplLngtdC54LHk6ZS55LXQueX19Y29uc3QgVj1bXSxZPVtdO1YuX19JU19OT05FX189ITAsWS5fX0lTX0FMTF9fPSEwO2NsYXNzIEt7c3Vic2NyaWJlVG9TdGF0ZUNoYW5nZShlLHQ9e30pe2NvbnN0e2hhbmRsZXJJZHM6cn09dDtFKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUsXCJsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpLEUodm9pZCAwPT09cnx8QXJyYXkuaXNBcnJheShyKSxcImhhbmRsZXJJZHMsIHdoZW4gc3BlY2lmaWVkLCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3MuXCIpO2xldCBuPXRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5zdGF0ZUlkO3JldHVybiB0aGlzLnN0b3JlLnN1YnNjcmliZSgoKCk9Pntjb25zdCB0PXRoaXMuc3RvcmUuZ2V0U3RhdGUoKSxvPXQuc3RhdGVJZDt0cnl7Y29uc3QgaT1vPT09bnx8bz09PW4rMSYmIWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUhPT1WJiYoZT09PVl8fHZvaWQgMD09PXR8fChyPWUsdC5maWx0ZXIoKGU9PnIuaW5kZXhPZihlKT4tMSkpKS5sZW5ndGg+MCk7dmFyIHJ9KHQuZGlydHlIYW5kbGVySWRzLHIpO2l8fGUoKX1maW5hbGx5e249b319KSl9c3Vic2NyaWJlVG9PZmZzZXRDaGFuZ2UoZSl7RShcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLFwibGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtsZXQgdD10aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09mZnNldDtyZXR1cm4gdGhpcy5zdG9yZS5zdWJzY3JpYmUoKCgpPT57Y29uc3Qgcj10aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09mZnNldDtyIT09dCYmKHQ9cixlKCkpfSkpfWNhbkRyYWdTb3VyY2UoZSl7aWYoIWUpcmV0dXJuITE7Y29uc3QgdD10aGlzLnJlZ2lzdHJ5LmdldFNvdXJjZShlKTtyZXR1cm4gRSh0LGBFeHBlY3RlZCB0byBmaW5kIGEgdmFsaWQgc291cmNlLiBzb3VyY2VJZD0ke2V9YCksIXRoaXMuaXNEcmFnZ2luZygpJiZ0LmNhbkRyYWcodGhpcyxlKX1jYW5Ecm9wT25UYXJnZXQoZSl7aWYoIWUpcmV0dXJuITE7Y29uc3QgdD10aGlzLnJlZ2lzdHJ5LmdldFRhcmdldChlKTtpZihFKHQsYEV4cGVjdGVkIHRvIGZpbmQgYSB2YWxpZCB0YXJnZXQuIHRhcmdldElkPSR7ZX1gKSwhdGhpcy5pc0RyYWdnaW5nKCl8fHRoaXMuZGlkRHJvcCgpKXJldHVybiExO3JldHVybiBCKHRoaXMucmVnaXN0cnkuZ2V0VGFyZ2V0VHlwZShlKSx0aGlzLmdldEl0ZW1UeXBlKCkpJiZ0LmNhbkRyb3AodGhpcyxlKX1pc0RyYWdnaW5nKCl7cmV0dXJuIEJvb2xlYW4odGhpcy5nZXRJdGVtVHlwZSgpKX1pc0RyYWdnaW5nU291cmNlKGUpe2lmKCFlKXJldHVybiExO2NvbnN0IHQ9dGhpcy5yZWdpc3RyeS5nZXRTb3VyY2UoZSwhMCk7aWYoRSh0LGBFeHBlY3RlZCB0byBmaW5kIGEgdmFsaWQgc291cmNlLiBzb3VyY2VJZD0ke2V9YCksIXRoaXMuaXNEcmFnZ2luZygpfHwhdGhpcy5pc1NvdXJjZVB1YmxpYygpKXJldHVybiExO3JldHVybiB0aGlzLnJlZ2lzdHJ5LmdldFNvdXJjZVR5cGUoZSk9PT10aGlzLmdldEl0ZW1UeXBlKCkmJnQuaXNEcmFnZ2luZyh0aGlzLGUpfWlzT3ZlclRhcmdldChlLHQ9e3NoYWxsb3c6ITF9KXtpZighZSlyZXR1cm4hMTtjb25zdHtzaGFsbG93OnJ9PXQ7aWYoIXRoaXMuaXNEcmFnZ2luZygpKXJldHVybiExO2NvbnN0IG49dGhpcy5yZWdpc3RyeS5nZXRUYXJnZXRUeXBlKGUpLG89dGhpcy5nZXRJdGVtVHlwZSgpO2lmKG8mJiFCKG4sbykpcmV0dXJuITE7Y29uc3QgaT10aGlzLmdldFRhcmdldElkcygpO2lmKCFpLmxlbmd0aClyZXR1cm4hMTtjb25zdCBzPWkuaW5kZXhPZihlKTtyZXR1cm4gcj9zPT09aS5sZW5ndGgtMTpzPi0xfWdldEl0ZW1UeXBlKCl7cmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT3BlcmF0aW9uLml0ZW1UeXBlfWdldEl0ZW0oKXtyZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPcGVyYXRpb24uaXRlbX1nZXRTb3VyY2VJZCgpe3JldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09wZXJhdGlvbi5zb3VyY2VJZH1nZXRUYXJnZXRJZHMoKXtyZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPcGVyYXRpb24udGFyZ2V0SWRzfWdldERyb3BSZXN1bHQoKXtyZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPcGVyYXRpb24uZHJvcFJlc3VsdH1kaWREcm9wKCl7cmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT3BlcmF0aW9uLmRpZERyb3B9aXNTb3VyY2VQdWJsaWMoKXtyZXR1cm4gQm9vbGVhbih0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09wZXJhdGlvbi5pc1NvdXJjZVB1YmxpYyl9Z2V0SW5pdGlhbENsaWVudE9mZnNldCgpe3JldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09mZnNldC5pbml0aWFsQ2xpZW50T2Zmc2V0fWdldEluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQoKXtyZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQuaW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldH1nZXRDbGllbnRPZmZzZXQoKXtyZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQuY2xpZW50T2Zmc2V0fWdldFNvdXJjZUNsaWVudE9mZnNldCgpe3JldHVybiBmdW5jdGlvbihlKXtjb25zdHtjbGllbnRPZmZzZXQ6dCxpbml0aWFsQ2xpZW50T2Zmc2V0OnIsaW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldDpufT1lO3JldHVybiB0JiZyJiZuPyQoKGk9bix7eDoobz10KS54K2kueCx5Om8ueStpLnl9KSxyKTpudWxsO3ZhciBvLGl9KHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT2Zmc2V0KX1nZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQoKXtyZXR1cm4gZnVuY3Rpb24oZSl7Y29uc3R7Y2xpZW50T2Zmc2V0OnQsaW5pdGlhbENsaWVudE9mZnNldDpyfT1lO3JldHVybiB0JiZyPyQodCxyKTpudWxsfSh0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09mZnNldCl9Y29uc3RydWN0b3IoZSx0KXt0aGlzLnN0b3JlPWUsdGhpcy5yZWdpc3RyeT10fX1jb25zdCBYPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOnNlbGYsRz1YLk11dGF0aW9uT2JzZXJ2ZXJ8fFguV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtmdW5jdGlvbiBRKGUpe3JldHVybiBmdW5jdGlvbigpe2NvbnN0IHQ9c2V0VGltZW91dChuLDApLHI9c2V0SW50ZXJ2YWwobiw1MCk7ZnVuY3Rpb24gbigpe2NsZWFyVGltZW91dCh0KSxjbGVhckludGVydmFsKHIpLGUoKX19fWNvbnN0IEo9XCJmdW5jdGlvblwiPT10eXBlb2YgRz9mdW5jdGlvbihlKXtsZXQgdD0xO2NvbnN0IHI9bmV3IEcoZSksbj1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtyZXR1cm4gci5vYnNlcnZlKG4se2NoYXJhY3RlckRhdGE6ITB9KSxmdW5jdGlvbigpe3Q9LXQsbi5kYXRhPXR9fTpRO2NsYXNzIFp7Y2FsbCgpe3RyeXt0aGlzLnRhc2smJnRoaXMudGFzaygpfWNhdGNoKGUpe3RoaXMub25FcnJvcihlKX1maW5hbGx5e3RoaXMudGFzaz1udWxsLHRoaXMucmVsZWFzZSh0aGlzKX19Y29uc3RydWN0b3IoZSx0KXt0aGlzLm9uRXJyb3I9ZSx0aGlzLnJlbGVhc2U9dCx0aGlzLnRhc2s9bnVsbH19Y29uc3QgZWU9bmV3IGNsYXNze2VucXVldWVUYXNrKGUpe2NvbnN0e3F1ZXVlOnQscmVxdWVzdEZsdXNoOnJ9PXRoaXM7dC5sZW5ndGh8fChyKCksdGhpcy5mbHVzaGluZz0hMCksdFt0Lmxlbmd0aF09ZX1jb25zdHJ1Y3Rvcigpe3RoaXMucXVldWU9W10sdGhpcy5wZW5kaW5nRXJyb3JzPVtdLHRoaXMuZmx1c2hpbmc9ITEsdGhpcy5pbmRleD0wLHRoaXMuY2FwYWNpdHk9MTAyNCx0aGlzLmZsdXNoPSgpPT57Y29uc3R7cXVldWU6ZX09dGhpcztmb3IoO3RoaXMuaW5kZXg8ZS5sZW5ndGg7KXtjb25zdCB0PXRoaXMuaW5kZXg7aWYodGhpcy5pbmRleCsrLGVbdF0uY2FsbCgpLHRoaXMuaW5kZXg+dGhpcy5jYXBhY2l0eSl7Zm9yKGxldCB0PTAscj1lLmxlbmd0aC10aGlzLmluZGV4O3Q8cjt0KyspZVt0XT1lW3QrdGhpcy5pbmRleF07ZS5sZW5ndGgtPXRoaXMuaW5kZXgsdGhpcy5pbmRleD0wfX1lLmxlbmd0aD0wLHRoaXMuaW5kZXg9MCx0aGlzLmZsdXNoaW5nPSExfSx0aGlzLnJlZ2lzdGVyUGVuZGluZ0Vycm9yPWU9Pnt0aGlzLnBlbmRpbmdFcnJvcnMucHVzaChlKSx0aGlzLnJlcXVlc3RFcnJvclRocm93KCl9LHRoaXMucmVxdWVzdEZsdXNoPUoodGhpcy5mbHVzaCksdGhpcy5yZXF1ZXN0RXJyb3JUaHJvdz1RKCgoKT0+e2lmKHRoaXMucGVuZGluZ0Vycm9ycy5sZW5ndGgpdGhyb3cgdGhpcy5wZW5kaW5nRXJyb3JzLnNoaWZ0KCl9KSl9fSx0ZT1uZXcgY2xhc3N7Y3JlYXRlKGUpe2NvbnN0IHQ9dGhpcy5mcmVlVGFza3Mscj10Lmxlbmd0aD90LnBvcCgpOm5ldyBaKHRoaXMub25FcnJvciwoZT0+dFt0Lmxlbmd0aF09ZSkpO3JldHVybiByLnRhc2s9ZSxyfWNvbnN0cnVjdG9yKGUpe3RoaXMub25FcnJvcj1lLHRoaXMuZnJlZVRhc2tzPVtdfX0oZWUucmVnaXN0ZXJQZW5kaW5nRXJyb3IpO2NvbnN0IHJlPVwiZG5kLWNvcmUvQUREX1NPVVJDRVwiLG5lPVwiZG5kLWNvcmUvQUREX1RBUkdFVFwiLG9lPVwiZG5kLWNvcmUvUkVNT1ZFX1NPVVJDRVwiLGllPVwiZG5kLWNvcmUvUkVNT1ZFX1RBUkdFVFwiO2Z1bmN0aW9uIHNlKGUsdCl7dCYmQXJyYXkuaXNBcnJheShlKT9lLmZvckVhY2goKGU9PnNlKGUsITEpKSk6RShcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJzeW1ib2xcIj09dHlwZW9mIGUsdD9cIlR5cGUgY2FuIG9ubHkgYmUgYSBzdHJpbmcsIGEgc3ltYm9sLCBvciBhbiBhcnJheSBvZiBlaXRoZXIuXCI6XCJUeXBlIGNhbiBvbmx5IGJlIGEgc3RyaW5nIG9yIGEgc3ltYm9sLlwiKX12YXIgYWU7IWZ1bmN0aW9uKGUpe2UuU09VUkNFPVwiU09VUkNFXCIsZS5UQVJHRVQ9XCJUQVJHRVRcIn0oYWV8fChhZT17fSkpO2xldCBjZT0wO2Z1bmN0aW9uIHVlKGUpe2NvbnN0IHQ9KGNlKyspLnRvU3RyaW5nKCk7c3dpdGNoKGUpe2Nhc2UgYWUuU09VUkNFOnJldHVybmBTJHt0fWA7Y2FzZSBhZS5UQVJHRVQ6cmV0dXJuYFQke3R9YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5rbm93biBIYW5kbGVyIFJvbGU6ICR7ZX1gKX19ZnVuY3Rpb24gbGUoZSl7c3dpdGNoKGVbMF0pe2Nhc2VcIlNcIjpyZXR1cm4gYWUuU09VUkNFO2Nhc2VcIlRcIjpyZXR1cm4gYWUuVEFSR0VUO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgaGFuZGxlciBJRDogJHtlfWApfX1mdW5jdGlvbiBkZShlLHQpe2NvbnN0IHI9ZS5lbnRyaWVzKCk7bGV0IG49ITE7ZG97Y29uc3R7ZG9uZTplLHZhbHVlOlssb119PXIubmV4dCgpO2lmKG89PT10KXJldHVybiEwO249ISFlfXdoaWxlKCFuKTtyZXR1cm4hMX1jbGFzcyBoZXthZGRTb3VyY2UoZSx0KXtzZShlKSxmdW5jdGlvbihlKXtFKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUuY2FuRHJhZyxcIkV4cGVjdGVkIGNhbkRyYWcgdG8gYmUgYSBmdW5jdGlvbi5cIiksRShcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmJlZ2luRHJhZyxcIkV4cGVjdGVkIGJlZ2luRHJhZyB0byBiZSBhIGZ1bmN0aW9uLlwiKSxFKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZW5kRHJhZyxcIkV4cGVjdGVkIGVuZERyYWcgdG8gYmUgYSBmdW5jdGlvbi5cIil9KHQpO2NvbnN0IHI9dGhpcy5hZGRIYW5kbGVyKGFlLlNPVVJDRSxlLHQpO3JldHVybiB0aGlzLnN0b3JlLmRpc3BhdGNoKGZ1bmN0aW9uKGUpe3JldHVybnt0eXBlOnJlLHBheWxvYWQ6e3NvdXJjZUlkOmV9fX0ocikpLHJ9YWRkVGFyZ2V0KGUsdCl7c2UoZSwhMCksZnVuY3Rpb24oZSl7RShcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmNhbkRyb3AsXCJFeHBlY3RlZCBjYW5Ecm9wIHRvIGJlIGEgZnVuY3Rpb24uXCIpLEUoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5ob3ZlcixcIkV4cGVjdGVkIGhvdmVyIHRvIGJlIGEgZnVuY3Rpb24uXCIpLEUoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5kcm9wLFwiRXhwZWN0ZWQgYmVnaW5EcmFnIHRvIGJlIGEgZnVuY3Rpb24uXCIpfSh0KTtjb25zdCByPXRoaXMuYWRkSGFuZGxlcihhZS5UQVJHRVQsZSx0KTtyZXR1cm4gdGhpcy5zdG9yZS5kaXNwYXRjaChmdW5jdGlvbihlKXtyZXR1cm57dHlwZTpuZSxwYXlsb2FkOnt0YXJnZXRJZDplfX19KHIpKSxyfWNvbnRhaW5zSGFuZGxlcihlKXtyZXR1cm4gZGUodGhpcy5kcmFnU291cmNlcyxlKXx8ZGUodGhpcy5kcm9wVGFyZ2V0cyxlKX1nZXRTb3VyY2UoZSx0PSExKXtFKHRoaXMuaXNTb3VyY2VJZChlKSxcIkV4cGVjdGVkIGEgdmFsaWQgc291cmNlIElELlwiKTtyZXR1cm4gdCYmZT09PXRoaXMucGlubmVkU291cmNlSWQ/dGhpcy5waW5uZWRTb3VyY2U6dGhpcy5kcmFnU291cmNlcy5nZXQoZSl9Z2V0VGFyZ2V0KGUpe3JldHVybiBFKHRoaXMuaXNUYXJnZXRJZChlKSxcIkV4cGVjdGVkIGEgdmFsaWQgdGFyZ2V0IElELlwiKSx0aGlzLmRyb3BUYXJnZXRzLmdldChlKX1nZXRTb3VyY2VUeXBlKGUpe3JldHVybiBFKHRoaXMuaXNTb3VyY2VJZChlKSxcIkV4cGVjdGVkIGEgdmFsaWQgc291cmNlIElELlwiKSx0aGlzLnR5cGVzLmdldChlKX1nZXRUYXJnZXRUeXBlKGUpe3JldHVybiBFKHRoaXMuaXNUYXJnZXRJZChlKSxcIkV4cGVjdGVkIGEgdmFsaWQgdGFyZ2V0IElELlwiKSx0aGlzLnR5cGVzLmdldChlKX1pc1NvdXJjZUlkKGUpe3JldHVybiBsZShlKT09PWFlLlNPVVJDRX1pc1RhcmdldElkKGUpe3JldHVybiBsZShlKT09PWFlLlRBUkdFVH1yZW1vdmVTb3VyY2UoZSl7dmFyIHQ7RSh0aGlzLmdldFNvdXJjZShlKSxcIkV4cGVjdGVkIGFuIGV4aXN0aW5nIHNvdXJjZS5cIiksdGhpcy5zdG9yZS5kaXNwYXRjaChmdW5jdGlvbihlKXtyZXR1cm57dHlwZTpvZSxwYXlsb2FkOntzb3VyY2VJZDplfX19KGUpKSx0PSgpPT57dGhpcy5kcmFnU291cmNlcy5kZWxldGUoZSksdGhpcy50eXBlcy5kZWxldGUoZSl9LGVlLmVucXVldWVUYXNrKHRlLmNyZWF0ZSh0KSl9cmVtb3ZlVGFyZ2V0KGUpe0UodGhpcy5nZXRUYXJnZXQoZSksXCJFeHBlY3RlZCBhbiBleGlzdGluZyB0YXJnZXQuXCIpLHRoaXMuc3RvcmUuZGlzcGF0Y2goZnVuY3Rpb24oZSl7cmV0dXJue3R5cGU6aWUscGF5bG9hZDp7dGFyZ2V0SWQ6ZX19fShlKSksdGhpcy5kcm9wVGFyZ2V0cy5kZWxldGUoZSksdGhpcy50eXBlcy5kZWxldGUoZSl9cGluU291cmNlKGUpe2NvbnN0IHQ9dGhpcy5nZXRTb3VyY2UoZSk7RSh0LFwiRXhwZWN0ZWQgYW4gZXhpc3Rpbmcgc291cmNlLlwiKSx0aGlzLnBpbm5lZFNvdXJjZUlkPWUsdGhpcy5waW5uZWRTb3VyY2U9dH11bnBpblNvdXJjZSgpe0UodGhpcy5waW5uZWRTb3VyY2UsXCJObyBzb3VyY2UgaXMgcGlubmVkIGF0IHRoZSB0aW1lLlwiKSx0aGlzLnBpbm5lZFNvdXJjZUlkPW51bGwsdGhpcy5waW5uZWRTb3VyY2U9bnVsbH1hZGRIYW5kbGVyKGUsdCxyKXtjb25zdCBuPXVlKGUpO3JldHVybiB0aGlzLnR5cGVzLnNldChuLHQpLGU9PT1hZS5TT1VSQ0U/dGhpcy5kcmFnU291cmNlcy5zZXQobixyKTplPT09YWUuVEFSR0VUJiZ0aGlzLmRyb3BUYXJnZXRzLnNldChuLHIpLG59Y29uc3RydWN0b3IoZSl7dGhpcy50eXBlcz1uZXcgTWFwLHRoaXMuZHJhZ1NvdXJjZXM9bmV3IE1hcCx0aGlzLmRyb3BUYXJnZXRzPW5ldyBNYXAsdGhpcy5waW5uZWRTb3VyY2VJZD1udWxsLHRoaXMucGlubmVkU291cmNlPW51bGwsdGhpcy5zdG9yZT1lfX1jb25zdCBnZT0oZSx0KT0+ZT09PXQ7ZnVuY3Rpb24gZmUoZT1WLHQpe3N3aXRjaCh0LnR5cGUpe2Nhc2UgeDpicmVhaztjYXNlIHJlOmNhc2UgbmU6Y2FzZSBpZTpjYXNlIG9lOnJldHVybiBWO2RlZmF1bHQ6cmV0dXJuIFl9Y29uc3R7dGFyZ2V0SWRzOnI9W10scHJldlRhcmdldElkczpuPVtdfT10LnBheWxvYWQsbz1mdW5jdGlvbihlLHQpe2NvbnN0IHI9bmV3IE1hcCxuPWU9PntyLnNldChlLHIuaGFzKGUpP3IuZ2V0KGUpKzE6MSl9O2UuZm9yRWFjaChuKSx0LmZvckVhY2gobik7Y29uc3Qgbz1bXTtyZXR1cm4gci5mb3JFYWNoKCgoZSx0KT0+ezE9PT1lJiZvLnB1c2godCl9KSksb30ocixuKTtpZighKG8ubGVuZ3RoPjB8fCFmdW5jdGlvbihlLHQscj1nZSl7aWYoZS5sZW5ndGghPT10Lmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbilpZighcihlW25dLHRbbl0pKXJldHVybiExO3JldHVybiEwfShyLG4pKSlyZXR1cm4gVjtjb25zdCBpPW5bbi5sZW5ndGgtMV0scz1yW3IubGVuZ3RoLTFdO3JldHVybiBpIT09cyYmKGkmJm8ucHVzaChpKSxzJiZvLnB1c2gocykpLG99ZnVuY3Rpb24gcGUoZSx0LHIpe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6cixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09cixlfWNvbnN0IHZlPXtpbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0Om51bGwsaW5pdGlhbENsaWVudE9mZnNldDpudWxsLGNsaWVudE9mZnNldDpudWxsfTtmdW5jdGlvbiBtZShlPXZlLHQpe2NvbnN0e3BheWxvYWQ6cn09dDtzd2l0Y2godC50eXBlKXtjYXNlIGs6Y2FzZSBMOnJldHVybntpbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0OnIuc291cmNlQ2xpZW50T2Zmc2V0LGluaXRpYWxDbGllbnRPZmZzZXQ6ci5jbGllbnRPZmZzZXQsY2xpZW50T2Zmc2V0OnIuY2xpZW50T2Zmc2V0fTtjYXNlIHg6cmV0dXJuIG49ZS5jbGllbnRPZmZzZXQsbz1yLmNsaWVudE9mZnNldCwhbiYmIW98fG4mJm8mJm4ueD09PW8ueCYmbi55PT09by55P2U6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIHI9bnVsbCE9YXJndW1lbnRzW3RdP2FyZ3VtZW50c1t0XTp7fSxuPU9iamVjdC5rZXlzKHIpO1wiZnVuY3Rpb25cIj09dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMmJihuPW4uY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocikuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLGUpLmVudW1lcmFibGV9KSkpKSxuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3BlKGUsdCxyW3RdKX0pKX1yZXR1cm4gZX0oe30sZSx7Y2xpZW50T2Zmc2V0OnIuY2xpZW50T2Zmc2V0fSk7Y2FzZSBOOmNhc2UgTTpyZXR1cm4gdmU7ZGVmYXVsdDpyZXR1cm4gZX12YXIgbixvfWZ1bmN0aW9uIHllKGUsdCxyKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOnIsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPXIsZX1mdW5jdGlvbiBiZShlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgcj1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9LG49T2JqZWN0LmtleXMocik7XCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyYmKG49bi5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhyKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSkuZW51bWVyYWJsZX0pKSkpLG4uZm9yRWFjaCgoZnVuY3Rpb24odCl7eWUoZSx0LHJbdF0pfSkpfXJldHVybiBlfWNvbnN0IE9lPXtpdGVtVHlwZTpudWxsLGl0ZW06bnVsbCxzb3VyY2VJZDpudWxsLHRhcmdldElkczpbXSxkcm9wUmVzdWx0Om51bGwsZGlkRHJvcDohMSxpc1NvdXJjZVB1YmxpYzpudWxsfTtmdW5jdGlvbiB3ZShlPU9lLHQpe2NvbnN0e3BheWxvYWQ6cn09dDtzd2l0Y2godC50eXBlKXtjYXNlIEw6cmV0dXJuIGJlKHt9LGUse2l0ZW1UeXBlOnIuaXRlbVR5cGUsaXRlbTpyLml0ZW0sc291cmNlSWQ6ci5zb3VyY2VJZCxpc1NvdXJjZVB1YmxpYzpyLmlzU291cmNlUHVibGljLGRyb3BSZXN1bHQ6bnVsbCxkaWREcm9wOiExfSk7Y2FzZSBQOnJldHVybiBiZSh7fSxlLHtpc1NvdXJjZVB1YmxpYzohMH0pO2Nhc2UgeDpyZXR1cm4gYmUoe30sZSx7dGFyZ2V0SWRzOnIudGFyZ2V0SWRzfSk7Y2FzZSBpZTpyZXR1cm4tMT09PWUudGFyZ2V0SWRzLmluZGV4T2Yoci50YXJnZXRJZCk/ZTpiZSh7fSxlLHt0YXJnZXRJZHM6KG49ZS50YXJnZXRJZHMsbz1yLnRhcmdldElkLG4uZmlsdGVyKChlPT5lIT09bykpKX0pO2Nhc2UgTTpyZXR1cm4gYmUoe30sZSx7ZHJvcFJlc3VsdDpyLmRyb3BSZXN1bHQsZGlkRHJvcDohMCx0YXJnZXRJZHM6W119KTtjYXNlIE46cmV0dXJuIGJlKHt9LGUse2l0ZW1UeXBlOm51bGwsaXRlbTpudWxsLHNvdXJjZUlkOm51bGwsZHJvcFJlc3VsdDpudWxsLGRpZERyb3A6ITEsaXNTb3VyY2VQdWJsaWM6bnVsbCx0YXJnZXRJZHM6W119KTtkZWZhdWx0OnJldHVybiBlfXZhciBuLG99ZnVuY3Rpb24gU2UoZT0wLHQpe3N3aXRjaCh0LnR5cGUpe2Nhc2UgcmU6Y2FzZSBuZTpyZXR1cm4gZSsxO2Nhc2Ugb2U6Y2FzZSBpZTpyZXR1cm4gZS0xO2RlZmF1bHQ6cmV0dXJuIGV9fWZ1bmN0aW9uIERlKGU9MCl7cmV0dXJuIGUrMX1mdW5jdGlvbiBDZShlLHQscil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpyLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1yLGV9ZnVuY3Rpb24gVGUoZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIHI9bnVsbCE9YXJndW1lbnRzW3RdP2FyZ3VtZW50c1t0XTp7fSxuPU9iamVjdC5rZXlzKHIpO1wiZnVuY3Rpb25cIj09dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMmJihuPW4uY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocikuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLGUpLmVudW1lcmFibGV9KSkpKSxuLmZvckVhY2goKGZ1bmN0aW9uKHQpe0NlKGUsdCxyW3RdKX0pKX1yZXR1cm4gZX1mdW5jdGlvbiBFZShlPXt9LHQpe3JldHVybntkaXJ0eUhhbmRsZXJJZHM6ZmUoZS5kaXJ0eUhhbmRsZXJJZHMse3R5cGU6dC50eXBlLHBheWxvYWQ6VGUoe30sdC5wYXlsb2FkLHtwcmV2VGFyZ2V0SWRzOihyPWUsbj1cImRyYWdPcGVyYXRpb24udGFyZ2V0SWRzXCIsbz1bXSxuLnNwbGl0KFwiLlwiKS5yZWR1Y2UoKChlLHQpPT5lJiZlW3RdP2VbdF06b3x8bnVsbCkscikpfSl9KSxkcmFnT2Zmc2V0Om1lKGUuZHJhZ09mZnNldCx0KSxyZWZDb3VudDpTZShlLnJlZkNvdW50LHQpLGRyYWdPcGVyYXRpb246d2UoZS5kcmFnT3BlcmF0aW9uLHQpLHN0YXRlSWQ6RGUoZS5zdGF0ZUlkKX07dmFyIHIsbixvfWZ1bmN0aW9uIEllKGUsdD12b2lkIDAscj17fSxuPSExKXtjb25zdCBvPWZ1bmN0aW9uKGUpe2NvbnN0IHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX187cmV0dXJuIEMoRWUsZSYmdCYmdCh7bmFtZTpcImRuZC1jb3JlXCIsaW5zdGFuY2VJZDpcImRuZC1jb3JlXCJ9KSl9KG4pLGk9bmV3IEsobyxuZXcgaGUobykpLHM9bmV3IEYobyxpKSxhPWUocyx0LHIpO3JldHVybiBzLnJlY2VpdmVCYWNrZW5kKGEpLHN9ZnVuY3Rpb24ga2UoZSx0KXtpZihudWxsPT1lKXJldHVybnt9O3ZhciByLG4sbz1mdW5jdGlvbihlLHQpe2lmKG51bGw9PWUpcmV0dXJue307dmFyIHIsbixvPXt9LGk9T2JqZWN0LmtleXMoZSk7Zm9yKG49MDtuPGkubGVuZ3RoO24rKylyPWlbbl0sdC5pbmRleE9mKHIpPj0wfHwob1tyXT1lW3JdKTtyZXR1cm4gb30oZSx0KTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO2ZvcihuPTA7bjxpLmxlbmd0aDtuKyspcj1pW25dLHQuaW5kZXhPZihyKT49MHx8T2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUscikmJihvW3JdPWVbcl0pfXJldHVybiBvfWxldCBMZT0wO2NvbnN0IFBlPVN5bWJvbC5mb3IoXCJfX1JFQUNUX0RORF9DT05URVhUX0lOU1RBTkNFX19cIik7dmFyIHhlPW8oKGZ1bmN0aW9uKHQpe3ZhcntjaGlsZHJlbjpyfT10LG49a2UodCxbXCJjaGlsZHJlblwiXSk7Y29uc3RbbyxzXT1mdW5jdGlvbihlKXtpZihcIm1hbmFnZXJcImluIGUpe3JldHVyblt7ZHJhZ0Ryb3BNYW5hZ2VyOmUubWFuYWdlcn0sITFdfWNvbnN0IHQ9ZnVuY3Rpb24oZSx0PU1lKCkscixuKXtjb25zdCBvPXQ7b1tQZV18fChvW1BlXT17ZHJhZ0Ryb3BNYW5hZ2VyOkllKGUsdCxyLG4pfSk7cmV0dXJuIG9bUGVdfShlLmJhY2tlbmQsZS5jb250ZXh0LGUub3B0aW9ucyxlLmRlYnVnTW9kZSkscj0hZS5jb250ZXh0O3JldHVyblt0LHJdfShuKTtyZXR1cm4gaSgoKCk9PntpZihzKXtjb25zdCBlPU1lKCk7cmV0dXJuKytMZSwoKT0+ezA9PS0tTGUmJihlW1BlXT1udWxsKX19fSksW10pLGUobS5Qcm92aWRlcix7dmFsdWU6byxjaGlsZHJlbjpyfSl9KSk7ZnVuY3Rpb24gTWUoKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDp3aW5kb3d9dmFyIE5lPWZ1bmN0aW9uIGUodCxyKXtpZih0PT09cilyZXR1cm4hMDtpZih0JiZyJiZcIm9iamVjdFwiPT10eXBlb2YgdCYmXCJvYmplY3RcIj09dHlwZW9mIHIpe2lmKHQuY29uc3RydWN0b3IhPT1yLmNvbnN0cnVjdG9yKXJldHVybiExO3ZhciBuLG8saTtpZihBcnJheS5pc0FycmF5KHQpKXtpZigobj10Lmxlbmd0aCkhPXIubGVuZ3RoKXJldHVybiExO2ZvcihvPW47MCE9by0tOylpZighZSh0W29dLHJbb10pKXJldHVybiExO3JldHVybiEwfWlmKHQuY29uc3RydWN0b3I9PT1SZWdFeHApcmV0dXJuIHQuc291cmNlPT09ci5zb3VyY2UmJnQuZmxhZ3M9PT1yLmZsYWdzO2lmKHQudmFsdWVPZiE9PU9iamVjdC5wcm90b3R5cGUudmFsdWVPZilyZXR1cm4gdC52YWx1ZU9mKCk9PT1yLnZhbHVlT2YoKTtpZih0LnRvU3RyaW5nIT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZylyZXR1cm4gdC50b1N0cmluZygpPT09ci50b1N0cmluZygpO2lmKChuPShpPU9iamVjdC5rZXlzKHQpKS5sZW5ndGgpIT09T2JqZWN0LmtleXMocikubGVuZ3RoKXJldHVybiExO2ZvcihvPW47MCE9by0tOylpZighT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsaVtvXSkpcmV0dXJuITE7Zm9yKG89bjswIT1vLS07KXt2YXIgcz1pW29dO2lmKCFlKHRbc10scltzXSkpcmV0dXJuITF9cmV0dXJuITB9cmV0dXJuIHQhPXQmJnIhPXJ9O2NvbnN0IGplPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/czppO2Z1bmN0aW9uIFJlKGUsdCxyKXtjb25zdFtuLG9dPWEoKCgpPT50KGUpKSksaT1jKCgoKT0+e2NvbnN0IGk9dChlKTtOZShuLGkpfHwobyhpKSxyJiZyKCkpfSksW24sZSxyXSk7cmV0dXJuIGplKGkpLFtuLGldfWZ1bmN0aW9uIEFlKGUsdCxyKXtyZXR1cm4gZnVuY3Rpb24oZSx0LHIpe2NvbnN0W24sb109UmUoZSx0LHIpO3JldHVybiBqZSgoZnVuY3Rpb24oKXtjb25zdCB0PWUuZ2V0SGFuZGxlcklkKCk7aWYobnVsbCE9dClyZXR1cm4gZS5zdWJzY3JpYmVUb1N0YXRlQ2hhbmdlKG8se2hhbmRsZXJJZHM6W3RdfSl9KSxbZSxvXSksbn0odCxlfHwoKCk9Pih7fSkpLCgoKT0+ci5yZWNvbm5lY3QoKSkpfWZ1bmN0aW9uIHFlKGUsdCl7Y29uc3Qgcj1bLi4udHx8W11dO3JldHVybiBudWxsPT10JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZyLnB1c2goZSksdSgoKCk9PlwiZnVuY3Rpb25cIj09dHlwZW9mIGU/ZSgpOmUpLHIpfWZ1bmN0aW9uIF9lKGUpe3JldHVybiB1KCgoKT0+ZS5ob29rcy5kcmFnU291cmNlKCkpLFtlXSl9ZnVuY3Rpb24gemUoZSl7cmV0dXJuIHUoKCgpPT5lLmhvb2tzLmRyYWdQcmV2aWV3KCkpLFtlXSl9bGV0IEhlPSExLEJlPSExO2NsYXNzIFdle3JlY2VpdmVIYW5kbGVySWQoZSl7dGhpcy5zb3VyY2VJZD1lfWdldEhhbmRsZXJJZCgpe3JldHVybiB0aGlzLnNvdXJjZUlkfWNhbkRyYWcoKXtFKCFIZSxcIllvdSBtYXkgbm90IGNhbGwgbW9uaXRvci5jYW5EcmFnKCkgaW5zaWRlIHlvdXIgY2FuRHJhZygpIGltcGxlbWVudGF0aW9uLiBSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzL2FwaS9kcmFnLXNvdXJjZS1tb25pdG9yXCIpO3RyeXtyZXR1cm4gSGU9ITAsdGhpcy5pbnRlcm5hbE1vbml0b3IuY2FuRHJhZ1NvdXJjZSh0aGlzLnNvdXJjZUlkKX1maW5hbGx5e0hlPSExfX1pc0RyYWdnaW5nKCl7aWYoIXRoaXMuc291cmNlSWQpcmV0dXJuITE7RSghQmUsXCJZb3UgbWF5IG5vdCBjYWxsIG1vbml0b3IuaXNEcmFnZ2luZygpIGluc2lkZSB5b3VyIGlzRHJhZ2dpbmcoKSBpbXBsZW1lbnRhdGlvbi4gUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy9hcGkvZHJhZy1zb3VyY2UtbW9uaXRvclwiKTt0cnl7cmV0dXJuIEJlPSEwLHRoaXMuaW50ZXJuYWxNb25pdG9yLmlzRHJhZ2dpbmdTb3VyY2UodGhpcy5zb3VyY2VJZCl9ZmluYWxseXtCZT0hMX19c3Vic2NyaWJlVG9TdGF0ZUNoYW5nZShlLHQpe3JldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5zdWJzY3JpYmVUb1N0YXRlQ2hhbmdlKGUsdCl9aXNEcmFnZ2luZ1NvdXJjZShlKXtyZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuaXNEcmFnZ2luZ1NvdXJjZShlKX1pc092ZXJUYXJnZXQoZSx0KXtyZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuaXNPdmVyVGFyZ2V0KGUsdCl9Z2V0VGFyZ2V0SWRzKCl7cmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldFRhcmdldElkcygpfWlzU291cmNlUHVibGljKCl7cmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmlzU291cmNlUHVibGljKCl9Z2V0U291cmNlSWQoKXtyZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0U291cmNlSWQoKX1zdWJzY3JpYmVUb09mZnNldENoYW5nZShlKXtyZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3Iuc3Vic2NyaWJlVG9PZmZzZXRDaGFuZ2UoZSl9Y2FuRHJhZ1NvdXJjZShlKXtyZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuY2FuRHJhZ1NvdXJjZShlKX1jYW5Ecm9wT25UYXJnZXQoZSl7cmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmNhbkRyb3BPblRhcmdldChlKX1nZXRJdGVtVHlwZSgpe3JldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRJdGVtVHlwZSgpfWdldEl0ZW0oKXtyZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0SXRlbSgpfWdldERyb3BSZXN1bHQoKXtyZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0RHJvcFJlc3VsdCgpfWRpZERyb3AoKXtyZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZGlkRHJvcCgpfWdldEluaXRpYWxDbGllbnRPZmZzZXQoKXtyZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0SW5pdGlhbENsaWVudE9mZnNldCgpfWdldEluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQoKXtyZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0SW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldCgpfWdldFNvdXJjZUNsaWVudE9mZnNldCgpe3JldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRTb3VyY2VDbGllbnRPZmZzZXQoKX1nZXRDbGllbnRPZmZzZXQoKXtyZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0Q2xpZW50T2Zmc2V0KCl9Z2V0RGlmZmVyZW5jZUZyb21Jbml0aWFsT2Zmc2V0KCl7cmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldERpZmZlcmVuY2VGcm9tSW5pdGlhbE9mZnNldCgpfWNvbnN0cnVjdG9yKGUpe3RoaXMuc291cmNlSWQ9bnVsbCx0aGlzLmludGVybmFsTW9uaXRvcj1lLmdldE1vbml0b3IoKX19bGV0IFVlPSExO2NsYXNzIEZle3JlY2VpdmVIYW5kbGVySWQoZSl7dGhpcy50YXJnZXRJZD1lfWdldEhhbmRsZXJJZCgpe3JldHVybiB0aGlzLnRhcmdldElkfXN1YnNjcmliZVRvU3RhdGVDaGFuZ2UoZSx0KXtyZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3Iuc3Vic2NyaWJlVG9TdGF0ZUNoYW5nZShlLHQpfWNhbkRyb3AoKXtpZighdGhpcy50YXJnZXRJZClyZXR1cm4hMTtFKCFVZSxcIllvdSBtYXkgbm90IGNhbGwgbW9uaXRvci5jYW5Ecm9wKCkgaW5zaWRlIHlvdXIgY2FuRHJvcCgpIGltcGxlbWVudGF0aW9uLiBSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzL2FwaS9kcm9wLXRhcmdldC1tb25pdG9yXCIpO3RyeXtyZXR1cm4gVWU9ITAsdGhpcy5pbnRlcm5hbE1vbml0b3IuY2FuRHJvcE9uVGFyZ2V0KHRoaXMudGFyZ2V0SWQpfWZpbmFsbHl7VWU9ITF9fWlzT3ZlcihlKXtyZXR1cm4hIXRoaXMudGFyZ2V0SWQmJnRoaXMuaW50ZXJuYWxNb25pdG9yLmlzT3ZlclRhcmdldCh0aGlzLnRhcmdldElkLGUpfWdldEl0ZW1UeXBlKCl7cmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEl0ZW1UeXBlKCl9Z2V0SXRlbSgpe3JldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRJdGVtKCl9Z2V0RHJvcFJlc3VsdCgpe3JldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXREcm9wUmVzdWx0KCl9ZGlkRHJvcCgpe3JldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5kaWREcm9wKCl9Z2V0SW5pdGlhbENsaWVudE9mZnNldCgpe3JldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRJbml0aWFsQ2xpZW50T2Zmc2V0KCl9Z2V0SW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldCgpe3JldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRJbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0KCl9Z2V0U291cmNlQ2xpZW50T2Zmc2V0KCl7cmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldFNvdXJjZUNsaWVudE9mZnNldCgpfWdldENsaWVudE9mZnNldCgpe3JldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRDbGllbnRPZmZzZXQoKX1nZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQoKXtyZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0RGlmZmVyZW5jZUZyb21Jbml0aWFsT2Zmc2V0KCl9Y29uc3RydWN0b3IoZSl7dGhpcy50YXJnZXRJZD1udWxsLHRoaXMuaW50ZXJuYWxNb25pdG9yPWUuZ2V0TW9uaXRvcigpfX1mdW5jdGlvbiAkZShlLHQscixuKXtsZXQgbz1yP3IuY2FsbChuLGUsdCk6dm9pZCAwO2lmKHZvaWQgMCE9PW8pcmV0dXJuISFvO2lmKGU9PT10KXJldHVybiEwO2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHwhZXx8XCJvYmplY3RcIiE9dHlwZW9mIHR8fCF0KXJldHVybiExO2NvbnN0IGk9T2JqZWN0LmtleXMoZSkscz1PYmplY3Qua2V5cyh0KTtpZihpLmxlbmd0aCE9PXMubGVuZ3RoKXJldHVybiExO2NvbnN0IGE9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5iaW5kKHQpO2ZvcihsZXQgcz0wO3M8aS5sZW5ndGg7cysrKXtjb25zdCBjPWlbc107aWYoIWEoYykpcmV0dXJuITE7Y29uc3QgdT1lW2NdLGw9dFtjXTtpZihvPXI/ci5jYWxsKG4sdSxsLGMpOnZvaWQgMCwhMT09PW98fHZvaWQgMD09PW8mJnUhPT1sKXJldHVybiExfXJldHVybiEwfWZ1bmN0aW9uIFZlKGUpe3JldHVybiBudWxsIT09ZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiY3VycmVudFwiKX1mdW5jdGlvbiBZZShlKXtyZXR1cm4odD1udWxsLHI9bnVsbCk9PntpZighbCh0KSl7Y29uc3Qgbj10O3JldHVybiBlKG4sciksbn1jb25zdCBuPXQ7IWZ1bmN0aW9uKGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlLnR5cGUpcmV0dXJuO2NvbnN0IHQ9ZS50eXBlLmRpc3BsYXlOYW1lfHxlLnR5cGUubmFtZXx8XCJ0aGUgY29tcG9uZW50XCI7dGhyb3cgbmV3IEVycm9yKGBPbmx5IG5hdGl2ZSBlbGVtZW50IG5vZGVzIGNhbiBub3cgYmUgcGFzc2VkIHRvIFJlYWN0IERuRCBjb25uZWN0b3JzLllvdSBjYW4gZWl0aGVyIHdyYXAgJHt0fSBpbnRvIGEgPGRpdj4sIG9yIHR1cm4gaXQgaW50byBhIGRyYWcgc291cmNlIG9yIGEgZHJvcCB0YXJnZXQgaXRzZWxmLmApfShuKTtyZXR1cm4gZnVuY3Rpb24oZSx0KXtjb25zdCByPWUucmVmO3JldHVybiBFKFwic3RyaW5nXCIhPXR5cGVvZiByLFwiQ2Fubm90IGNvbm5lY3QgUmVhY3QgRG5EIHRvIGFuIGVsZW1lbnQgd2l0aCBhbiBleGlzdGluZyBzdHJpbmcgcmVmLiBQbGVhc2UgY29udmVydCBpdCB0byB1c2UgYSBjYWxsYmFjayByZWYgaW5zdGVhZCwgb3Igd3JhcCBpdCBpbnRvIGEgPHNwYW4+IG9yIDxkaXY+LiBSZWFkIG1vcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWZzLWFuZC10aGUtZG9tLmh0bWwjY2FsbGJhY2stcmVmc1wiKSxkKGUscj97cmVmOmU9PntYZShyLGUpLFhlKHQsZSl9fTp7cmVmOnR9KX0obixyP3Q9PmUodCxyKTplKX19ZnVuY3Rpb24gS2UoZSl7Y29uc3QgdD17fTtyZXR1cm4gT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgocj0+e2NvbnN0IG49ZVtyXTtpZihyLmVuZHNXaXRoKFwiUmVmXCIpKXRbcl09ZVtyXTtlbHNle2NvbnN0IGU9WWUobik7dFtyXT0oKT0+ZX19KSksdH1mdW5jdGlvbiBYZShlLHQpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGU/ZSh0KTplLmN1cnJlbnQ9dH1jbGFzcyBHZXtyZWNlaXZlSGFuZGxlcklkKGUpe3RoaXMuaGFuZGxlcklkIT09ZSYmKHRoaXMuaGFuZGxlcklkPWUsdGhpcy5yZWNvbm5lY3QoKSl9Z2V0IGNvbm5lY3RUYXJnZXQoKXtyZXR1cm4gdGhpcy5kcmFnU291cmNlfWdldCBkcmFnU291cmNlT3B0aW9ucygpe3JldHVybiB0aGlzLmRyYWdTb3VyY2VPcHRpb25zSW50ZXJuYWx9c2V0IGRyYWdTb3VyY2VPcHRpb25zKGUpe3RoaXMuZHJhZ1NvdXJjZU9wdGlvbnNJbnRlcm5hbD1lfWdldCBkcmFnUHJldmlld09wdGlvbnMoKXtyZXR1cm4gdGhpcy5kcmFnUHJldmlld09wdGlvbnNJbnRlcm5hbH1zZXQgZHJhZ1ByZXZpZXdPcHRpb25zKGUpe3RoaXMuZHJhZ1ByZXZpZXdPcHRpb25zSW50ZXJuYWw9ZX1yZWNvbm5lY3QoKXtjb25zdCBlPXRoaXMucmVjb25uZWN0RHJhZ1NvdXJjZSgpO3RoaXMucmVjb25uZWN0RHJhZ1ByZXZpZXcoZSl9cmVjb25uZWN0RHJhZ1NvdXJjZSgpe2NvbnN0IGU9dGhpcy5kcmFnU291cmNlLHQ9dGhpcy5kaWRIYW5kbGVySWRDaGFuZ2UoKXx8dGhpcy5kaWRDb25uZWN0ZWREcmFnU291cmNlQ2hhbmdlKCl8fHRoaXMuZGlkRHJhZ1NvdXJjZU9wdGlvbnNDaGFuZ2UoKTtyZXR1cm4gdCYmdGhpcy5kaXNjb25uZWN0RHJhZ1NvdXJjZSgpLHRoaXMuaGFuZGxlcklkP2U/KHQmJih0aGlzLmxhc3RDb25uZWN0ZWRIYW5kbGVySWQ9dGhpcy5oYW5kbGVySWQsdGhpcy5sYXN0Q29ubmVjdGVkRHJhZ1NvdXJjZT1lLHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2VPcHRpb25zPXRoaXMuZHJhZ1NvdXJjZU9wdGlvbnMsdGhpcy5kcmFnU291cmNlVW5zdWJzY3JpYmU9dGhpcy5iYWNrZW5kLmNvbm5lY3REcmFnU291cmNlKHRoaXMuaGFuZGxlcklkLGUsdGhpcy5kcmFnU291cmNlT3B0aW9ucykpLHQpOih0aGlzLmxhc3RDb25uZWN0ZWREcmFnU291cmNlPWUsdCk6dH1yZWNvbm5lY3REcmFnUHJldmlldyhlPSExKXtjb25zdCB0PXRoaXMuZHJhZ1ByZXZpZXcscj1lfHx0aGlzLmRpZEhhbmRsZXJJZENoYW5nZSgpfHx0aGlzLmRpZENvbm5lY3RlZERyYWdQcmV2aWV3Q2hhbmdlKCl8fHRoaXMuZGlkRHJhZ1ByZXZpZXdPcHRpb25zQ2hhbmdlKCk7ciYmdGhpcy5kaXNjb25uZWN0RHJhZ1ByZXZpZXcoKSx0aGlzLmhhbmRsZXJJZCYmKHQ/ciYmKHRoaXMubGFzdENvbm5lY3RlZEhhbmRsZXJJZD10aGlzLmhhbmRsZXJJZCx0aGlzLmxhc3RDb25uZWN0ZWREcmFnUHJldmlldz10LHRoaXMubGFzdENvbm5lY3RlZERyYWdQcmV2aWV3T3B0aW9ucz10aGlzLmRyYWdQcmV2aWV3T3B0aW9ucyx0aGlzLmRyYWdQcmV2aWV3VW5zdWJzY3JpYmU9dGhpcy5iYWNrZW5kLmNvbm5lY3REcmFnUHJldmlldyh0aGlzLmhhbmRsZXJJZCx0LHRoaXMuZHJhZ1ByZXZpZXdPcHRpb25zKSk6dGhpcy5sYXN0Q29ubmVjdGVkRHJhZ1ByZXZpZXc9dCl9ZGlkSGFuZGxlcklkQ2hhbmdlKCl7cmV0dXJuIHRoaXMubGFzdENvbm5lY3RlZEhhbmRsZXJJZCE9PXRoaXMuaGFuZGxlcklkfWRpZENvbm5lY3RlZERyYWdTb3VyY2VDaGFuZ2UoKXtyZXR1cm4gdGhpcy5sYXN0Q29ubmVjdGVkRHJhZ1NvdXJjZSE9PXRoaXMuZHJhZ1NvdXJjZX1kaWRDb25uZWN0ZWREcmFnUHJldmlld0NoYW5nZSgpe3JldHVybiB0aGlzLmxhc3RDb25uZWN0ZWREcmFnUHJldmlldyE9PXRoaXMuZHJhZ1ByZXZpZXd9ZGlkRHJhZ1NvdXJjZU9wdGlvbnNDaGFuZ2UoKXtyZXR1cm4hJGUodGhpcy5sYXN0Q29ubmVjdGVkRHJhZ1NvdXJjZU9wdGlvbnMsdGhpcy5kcmFnU291cmNlT3B0aW9ucyl9ZGlkRHJhZ1ByZXZpZXdPcHRpb25zQ2hhbmdlKCl7cmV0dXJuISRlKHRoaXMubGFzdENvbm5lY3RlZERyYWdQcmV2aWV3T3B0aW9ucyx0aGlzLmRyYWdQcmV2aWV3T3B0aW9ucyl9ZGlzY29ubmVjdERyYWdTb3VyY2UoKXt0aGlzLmRyYWdTb3VyY2VVbnN1YnNjcmliZSYmKHRoaXMuZHJhZ1NvdXJjZVVuc3Vic2NyaWJlKCksdGhpcy5kcmFnU291cmNlVW5zdWJzY3JpYmU9dm9pZCAwKX1kaXNjb25uZWN0RHJhZ1ByZXZpZXcoKXt0aGlzLmRyYWdQcmV2aWV3VW5zdWJzY3JpYmUmJih0aGlzLmRyYWdQcmV2aWV3VW5zdWJzY3JpYmUoKSx0aGlzLmRyYWdQcmV2aWV3VW5zdWJzY3JpYmU9dm9pZCAwLHRoaXMuZHJhZ1ByZXZpZXdOb2RlPW51bGwsdGhpcy5kcmFnUHJldmlld1JlZj1udWxsKX1nZXQgZHJhZ1NvdXJjZSgpe3JldHVybiB0aGlzLmRyYWdTb3VyY2VOb2RlfHx0aGlzLmRyYWdTb3VyY2VSZWYmJnRoaXMuZHJhZ1NvdXJjZVJlZi5jdXJyZW50fWdldCBkcmFnUHJldmlldygpe3JldHVybiB0aGlzLmRyYWdQcmV2aWV3Tm9kZXx8dGhpcy5kcmFnUHJldmlld1JlZiYmdGhpcy5kcmFnUHJldmlld1JlZi5jdXJyZW50fWNsZWFyRHJhZ1NvdXJjZSgpe3RoaXMuZHJhZ1NvdXJjZU5vZGU9bnVsbCx0aGlzLmRyYWdTb3VyY2VSZWY9bnVsbH1jbGVhckRyYWdQcmV2aWV3KCl7dGhpcy5kcmFnUHJldmlld05vZGU9bnVsbCx0aGlzLmRyYWdQcmV2aWV3UmVmPW51bGx9Y29uc3RydWN0b3IoZSl7dGhpcy5ob29rcz1LZSh7ZHJhZ1NvdXJjZTooZSx0KT0+e3RoaXMuY2xlYXJEcmFnU291cmNlKCksdGhpcy5kcmFnU291cmNlT3B0aW9ucz10fHxudWxsLFZlKGUpP3RoaXMuZHJhZ1NvdXJjZVJlZj1lOnRoaXMuZHJhZ1NvdXJjZU5vZGU9ZSx0aGlzLnJlY29ubmVjdERyYWdTb3VyY2UoKX0sZHJhZ1ByZXZpZXc6KGUsdCk9Pnt0aGlzLmNsZWFyRHJhZ1ByZXZpZXcoKSx0aGlzLmRyYWdQcmV2aWV3T3B0aW9ucz10fHxudWxsLFZlKGUpP3RoaXMuZHJhZ1ByZXZpZXdSZWY9ZTp0aGlzLmRyYWdQcmV2aWV3Tm9kZT1lLHRoaXMucmVjb25uZWN0RHJhZ1ByZXZpZXcoKX19KSx0aGlzLmhhbmRsZXJJZD1udWxsLHRoaXMuZHJhZ1NvdXJjZVJlZj1udWxsLHRoaXMuZHJhZ1NvdXJjZU9wdGlvbnNJbnRlcm5hbD1udWxsLHRoaXMuZHJhZ1ByZXZpZXdSZWY9bnVsbCx0aGlzLmRyYWdQcmV2aWV3T3B0aW9uc0ludGVybmFsPW51bGwsdGhpcy5sYXN0Q29ubmVjdGVkSGFuZGxlcklkPW51bGwsdGhpcy5sYXN0Q29ubmVjdGVkRHJhZ1NvdXJjZT1udWxsLHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2VPcHRpb25zPW51bGwsdGhpcy5sYXN0Q29ubmVjdGVkRHJhZ1ByZXZpZXc9bnVsbCx0aGlzLmxhc3RDb25uZWN0ZWREcmFnUHJldmlld09wdGlvbnM9bnVsbCx0aGlzLmJhY2tlbmQ9ZX19Y2xhc3MgUWV7Z2V0IGNvbm5lY3RUYXJnZXQoKXtyZXR1cm4gdGhpcy5kcm9wVGFyZ2V0fXJlY29ubmVjdCgpe2NvbnN0IGU9dGhpcy5kaWRIYW5kbGVySWRDaGFuZ2UoKXx8dGhpcy5kaWREcm9wVGFyZ2V0Q2hhbmdlKCl8fHRoaXMuZGlkT3B0aW9uc0NoYW5nZSgpO2UmJnRoaXMuZGlzY29ubmVjdERyb3BUYXJnZXQoKTtjb25zdCB0PXRoaXMuZHJvcFRhcmdldDt0aGlzLmhhbmRsZXJJZCYmKHQ/ZSYmKHRoaXMubGFzdENvbm5lY3RlZEhhbmRsZXJJZD10aGlzLmhhbmRsZXJJZCx0aGlzLmxhc3RDb25uZWN0ZWREcm9wVGFyZ2V0PXQsdGhpcy5sYXN0Q29ubmVjdGVkRHJvcFRhcmdldE9wdGlvbnM9dGhpcy5kcm9wVGFyZ2V0T3B0aW9ucyx0aGlzLnVuc3Vic2NyaWJlRHJvcFRhcmdldD10aGlzLmJhY2tlbmQuY29ubmVjdERyb3BUYXJnZXQodGhpcy5oYW5kbGVySWQsdCx0aGlzLmRyb3BUYXJnZXRPcHRpb25zKSk6dGhpcy5sYXN0Q29ubmVjdGVkRHJvcFRhcmdldD10KX1yZWNlaXZlSGFuZGxlcklkKGUpe2UhPT10aGlzLmhhbmRsZXJJZCYmKHRoaXMuaGFuZGxlcklkPWUsdGhpcy5yZWNvbm5lY3QoKSl9Z2V0IGRyb3BUYXJnZXRPcHRpb25zKCl7cmV0dXJuIHRoaXMuZHJvcFRhcmdldE9wdGlvbnNJbnRlcm5hbH1zZXQgZHJvcFRhcmdldE9wdGlvbnMoZSl7dGhpcy5kcm9wVGFyZ2V0T3B0aW9uc0ludGVybmFsPWV9ZGlkSGFuZGxlcklkQ2hhbmdlKCl7cmV0dXJuIHRoaXMubGFzdENvbm5lY3RlZEhhbmRsZXJJZCE9PXRoaXMuaGFuZGxlcklkfWRpZERyb3BUYXJnZXRDaGFuZ2UoKXtyZXR1cm4gdGhpcy5sYXN0Q29ubmVjdGVkRHJvcFRhcmdldCE9PXRoaXMuZHJvcFRhcmdldH1kaWRPcHRpb25zQ2hhbmdlKCl7cmV0dXJuISRlKHRoaXMubGFzdENvbm5lY3RlZERyb3BUYXJnZXRPcHRpb25zLHRoaXMuZHJvcFRhcmdldE9wdGlvbnMpfWRpc2Nvbm5lY3REcm9wVGFyZ2V0KCl7dGhpcy51bnN1YnNjcmliZURyb3BUYXJnZXQmJih0aGlzLnVuc3Vic2NyaWJlRHJvcFRhcmdldCgpLHRoaXMudW5zdWJzY3JpYmVEcm9wVGFyZ2V0PXZvaWQgMCl9Z2V0IGRyb3BUYXJnZXQoKXtyZXR1cm4gdGhpcy5kcm9wVGFyZ2V0Tm9kZXx8dGhpcy5kcm9wVGFyZ2V0UmVmJiZ0aGlzLmRyb3BUYXJnZXRSZWYuY3VycmVudH1jbGVhckRyb3BUYXJnZXQoKXt0aGlzLmRyb3BUYXJnZXRSZWY9bnVsbCx0aGlzLmRyb3BUYXJnZXROb2RlPW51bGx9Y29uc3RydWN0b3IoZSl7dGhpcy5ob29rcz1LZSh7ZHJvcFRhcmdldDooZSx0KT0+e3RoaXMuY2xlYXJEcm9wVGFyZ2V0KCksdGhpcy5kcm9wVGFyZ2V0T3B0aW9ucz10LFZlKGUpP3RoaXMuZHJvcFRhcmdldFJlZj1lOnRoaXMuZHJvcFRhcmdldE5vZGU9ZSx0aGlzLnJlY29ubmVjdCgpfX0pLHRoaXMuaGFuZGxlcklkPW51bGwsdGhpcy5kcm9wVGFyZ2V0UmVmPW51bGwsdGhpcy5kcm9wVGFyZ2V0T3B0aW9uc0ludGVybmFsPW51bGwsdGhpcy5sYXN0Q29ubmVjdGVkSGFuZGxlcklkPW51bGwsdGhpcy5sYXN0Q29ubmVjdGVkRHJvcFRhcmdldD1udWxsLHRoaXMubGFzdENvbm5lY3RlZERyb3BUYXJnZXRPcHRpb25zPW51bGwsdGhpcy5iYWNrZW5kPWV9fWZ1bmN0aW9uIEplKCl7Y29uc3R7ZHJhZ0Ryb3BNYW5hZ2VyOmV9PWgobSk7cmV0dXJuIEUobnVsbCE9ZSxcIkV4cGVjdGVkIGRyYWcgZHJvcCBjb250ZXh0XCIpLGV9Y2xhc3MgWmV7YmVnaW5EcmFnKCl7Y29uc3QgZT10aGlzLnNwZWMsdD10aGlzLm1vbml0b3I7bGV0IHI9bnVsbDtyZXR1cm4gcj1cIm9iamVjdFwiPT10eXBlb2YgZS5pdGVtP2UuaXRlbTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLml0ZW0/ZS5pdGVtKHQpOnt9LG51bGwhPXI/cjpudWxsfWNhbkRyYWcoKXtjb25zdCBlPXRoaXMuc3BlYyx0PXRoaXMubW9uaXRvcjtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIGUuY2FuRHJhZz9lLmNhbkRyYWc6XCJmdW5jdGlvblwiIT10eXBlb2YgZS5jYW5EcmFnfHxlLmNhbkRyYWcodCl9aXNEcmFnZ2luZyhlLHQpe2NvbnN0IHI9dGhpcy5zcGVjLG49dGhpcy5tb25pdG9yLHtpc0RyYWdnaW5nOm99PXI7cmV0dXJuIG8/byhuKTp0PT09ZS5nZXRTb3VyY2VJZCgpfWVuZERyYWcoKXtjb25zdCBlPXRoaXMuc3BlYyx0PXRoaXMubW9uaXRvcixyPXRoaXMuY29ubmVjdG9yLHtlbmQ6bn09ZTtuJiZuKHQuZ2V0SXRlbSgpLHQpLHIucmVjb25uZWN0KCl9Y29uc3RydWN0b3IoZSx0LHIpe3RoaXMuc3BlYz1lLHRoaXMubW9uaXRvcj10LHRoaXMuY29ubmVjdG9yPXJ9fWZ1bmN0aW9uIGV0KGUsdCxyKXtjb25zdCBuPUplKCksbz1mdW5jdGlvbihlLHQscil7Y29uc3Qgbj11KCgoKT0+bmV3IFplKGUsdCxyKSksW3Qscl0pO3JldHVybiBpKCgoKT0+e24uc3BlYz1lfSksW2VdKSxufShlLHQscikscz1mdW5jdGlvbihlKXtyZXR1cm4gdSgoKCk9Pntjb25zdCB0PWUudHlwZTtyZXR1cm4gRShudWxsIT10LFwic3BlYy50eXBlIG11c3QgYmUgZGVmaW5lZFwiKSx0fSksW2VdKX0oZSk7amUoKGZ1bmN0aW9uKCl7aWYobnVsbCE9cyl7Y29uc3RbZSxpXT1mdW5jdGlvbihlLHQscil7Y29uc3Qgbj1yLmdldFJlZ2lzdHJ5KCksbz1uLmFkZFNvdXJjZShlLHQpO3JldHVybltvLCgpPT5uLnJlbW92ZVNvdXJjZShvKV19KHMsbyxuKTtyZXR1cm4gdC5yZWNlaXZlSGFuZGxlcklkKGUpLHIucmVjZWl2ZUhhbmRsZXJJZChlKSxpfX0pLFtuLHQscixvLHNdKX1mdW5jdGlvbiB0dChlLHQpe2NvbnN0IHI9cWUoZSx0KTtFKCFyLmJlZ2luLFwidXNlRHJhZzo6c3BlYy5iZWdpbiB3YXMgZGVwcmVjYXRlZCBpbiB2MTQuIFJlcGxhY2Ugc3BlYy5iZWdpbigpIHdpdGggc3BlYy5pdGVtKCkuIChzZWUgbW9yZSBoZXJlIC0gaHR0cHM6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzL2FwaS91c2UtZHJhZylcIik7Y29uc3Qgbj1mdW5jdGlvbigpe2NvbnN0IGU9SmUoKTtyZXR1cm4gdSgoKCk9Pm5ldyBXZShlKSksW2VdKX0oKSxvPWZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj1KZSgpLG49dSgoKCk9Pm5ldyBHZShyLmdldEJhY2tlbmQoKSkpLFtyXSk7cmV0dXJuIGplKCgoKT0+KG4uZHJhZ1NvdXJjZU9wdGlvbnM9ZXx8bnVsbCxuLnJlY29ubmVjdCgpLCgpPT5uLmRpc2Nvbm5lY3REcmFnU291cmNlKCkpKSxbbixlXSksamUoKCgpPT4obi5kcmFnUHJldmlld09wdGlvbnM9dHx8bnVsbCxuLnJlY29ubmVjdCgpLCgpPT5uLmRpc2Nvbm5lY3REcmFnUHJldmlldygpKSksW24sdF0pLG59KHIub3B0aW9ucyxyLnByZXZpZXdPcHRpb25zKTtyZXR1cm4gZXQocixuLG8pLFtBZShyLmNvbGxlY3QsbixvKSxfZShvKSx6ZShvKV19ZnVuY3Rpb24gcnQoZSl7cmV0dXJuIHUoKCgpPT5lLmhvb2tzLmRyb3BUYXJnZXQoKSksW2VdKX1jbGFzcyBudHtjYW5Ecm9wKCl7Y29uc3QgZT10aGlzLnNwZWMsdD10aGlzLm1vbml0b3I7cmV0dXJuIWUuY2FuRHJvcHx8ZS5jYW5Ecm9wKHQuZ2V0SXRlbSgpLHQpfWhvdmVyKCl7Y29uc3QgZT10aGlzLnNwZWMsdD10aGlzLm1vbml0b3I7ZS5ob3ZlciYmZS5ob3Zlcih0LmdldEl0ZW0oKSx0KX1kcm9wKCl7Y29uc3QgZT10aGlzLnNwZWMsdD10aGlzLm1vbml0b3I7aWYoZS5kcm9wKXJldHVybiBlLmRyb3AodC5nZXRJdGVtKCksdCl9Y29uc3RydWN0b3IoZSx0KXt0aGlzLnNwZWM9ZSx0aGlzLm1vbml0b3I9dH19ZnVuY3Rpb24gb3QoZSx0LHIpe2NvbnN0IG49SmUoKSxvPWZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj11KCgoKT0+bmV3IG50KGUsdCkpLFt0XSk7cmV0dXJuIGkoKCgpPT57ci5zcGVjPWV9KSxbZV0pLHJ9KGUsdCkscz1mdW5jdGlvbihlKXtjb25zdHthY2NlcHQ6dH09ZTtyZXR1cm4gdSgoKCk9PihFKG51bGwhPWUuYWNjZXB0LFwiYWNjZXB0IG11c3QgYmUgZGVmaW5lZFwiKSxBcnJheS5pc0FycmF5KHQpP3Q6W3RdKSksW3RdKX0oZSk7amUoKGZ1bmN0aW9uKCl7Y29uc3RbZSxpXT1mdW5jdGlvbihlLHQscil7Y29uc3Qgbj1yLmdldFJlZ2lzdHJ5KCksbz1uLmFkZFRhcmdldChlLHQpO3JldHVybltvLCgpPT5uLnJlbW92ZVRhcmdldChvKV19KHMsbyxuKTtyZXR1cm4gdC5yZWNlaXZlSGFuZGxlcklkKGUpLHIucmVjZWl2ZUhhbmRsZXJJZChlKSxpfSksW24sdCxvLHIscy5tYXAoKGU9PmUudG9TdHJpbmcoKSkpLmpvaW4oXCJ8XCIpXSl9ZnVuY3Rpb24gaXQoZSx0KXtjb25zdCByPXFlKGUsdCksbj1mdW5jdGlvbigpe2NvbnN0IGU9SmUoKTtyZXR1cm4gdSgoKCk9Pm5ldyBGZShlKSksW2VdKX0oKSxvPWZ1bmN0aW9uKGUpe2NvbnN0IHQ9SmUoKSxyPXUoKCgpPT5uZXcgUWUodC5nZXRCYWNrZW5kKCkpKSxbdF0pO3JldHVybiBqZSgoKCk9PihyLmRyb3BUYXJnZXRPcHRpb25zPWV8fG51bGwsci5yZWNvbm5lY3QoKSwoKT0+ci5kaXNjb25uZWN0RHJvcFRhcmdldCgpKSksW2VdKSxyfShyLm9wdGlvbnMpO3JldHVybiBvdChyLG4sbyksW0FlKHIuY29sbGVjdCxuLG8pLHJ0KG8pXX1mdW5jdGlvbiBzdChlKXtsZXQgdD1udWxsO3JldHVybigpPT4obnVsbD09dCYmKHQ9ZSgpKSx0KX1jbGFzcyBhdHtlbnRlcihlKXtjb25zdCB0PXRoaXMuZW50ZXJlZC5sZW5ndGg7cmV0dXJuIHRoaXMuZW50ZXJlZD1mdW5jdGlvbihlLHQpe2NvbnN0IHI9bmV3IFNldCxuPWU9PnIuYWRkKGUpO2UuZm9yRWFjaChuKSx0LmZvckVhY2gobik7Y29uc3Qgbz1bXTtyZXR1cm4gci5mb3JFYWNoKChlPT5vLnB1c2goZSkpKSxvfSh0aGlzLmVudGVyZWQuZmlsdGVyKCh0PT50aGlzLmlzTm9kZUluRG9jdW1lbnQodCkmJighdC5jb250YWluc3x8dC5jb250YWlucyhlKSkpKSxbZV0pLDA9PT10JiZ0aGlzLmVudGVyZWQubGVuZ3RoPjB9bGVhdmUoZSl7Y29uc3QgdD10aGlzLmVudGVyZWQubGVuZ3RoO3ZhciByLG47cmV0dXJuIHRoaXMuZW50ZXJlZD0ocj10aGlzLmVudGVyZWQuZmlsdGVyKHRoaXMuaXNOb2RlSW5Eb2N1bWVudCksbj1lLHIuZmlsdGVyKChlPT5lIT09bikpKSx0PjAmJjA9PT10aGlzLmVudGVyZWQubGVuZ3RofXJlc2V0KCl7dGhpcy5lbnRlcmVkPVtdfWNvbnN0cnVjdG9yKGUpe3RoaXMuZW50ZXJlZD1bXSx0aGlzLmlzTm9kZUluRG9jdW1lbnQ9ZX19Y2xhc3MgY3R7aW5pdGlhbGl6ZUV4cG9zZWRQcm9wZXJ0aWVzKCl7T2JqZWN0LmtleXModGhpcy5jb25maWcuZXhwb3NlUHJvcGVydGllcykuZm9yRWFjaCgoZT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLml0ZW0sZSx7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsZ2V0OigpPT4oY29uc29sZS53YXJuKGBCcm93c2VyIGRvZXNuJ3QgYWxsb3cgcmVhZGluZyBcIiR7ZX1cIiB1bnRpbCB0aGUgZHJvcCBldmVudC5gKSxudWxsKX0pfSkpfWxvYWREYXRhVHJhbnNmZXIoZSl7aWYoZSl7Y29uc3QgdD17fTtPYmplY3Qua2V5cyh0aGlzLmNvbmZpZy5leHBvc2VQcm9wZXJ0aWVzKS5mb3JFYWNoKChyPT57Y29uc3Qgbj10aGlzLmNvbmZpZy5leHBvc2VQcm9wZXJ0aWVzW3JdO251bGwhPW4mJih0W3JdPXt2YWx1ZTpuKGUsdGhpcy5jb25maWcubWF0Y2hlc1R5cGVzKSxjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMH0pfSkpLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMuaXRlbSx0KX19Y2FuRHJhZygpe3JldHVybiEwfWJlZ2luRHJhZygpe3JldHVybiB0aGlzLml0ZW19aXNEcmFnZ2luZyhlLHQpe3JldHVybiB0PT09ZS5nZXRTb3VyY2VJZCgpfWVuZERyYWcoKXt9Y29uc3RydWN0b3IoZSl7dGhpcy5jb25maWc9ZSx0aGlzLml0ZW09e30sdGhpcy5pbml0aWFsaXplRXhwb3NlZFByb3BlcnRpZXMoKX19Y29uc3QgdXQ9XCJfX05BVElWRV9GSUxFX19cIixsdD1cIl9fTkFUSVZFX1VSTF9fXCIsZHQ9XCJfX05BVElWRV9URVhUX19cIixodD1cIl9fTkFUSVZFX0hUTUxfX1wiO3ZhciBndD1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxGSUxFOnV0LEhUTUw6aHQsVEVYVDpkdCxVUkw6bHR9KTtmdW5jdGlvbiBmdChlLHQscil7Y29uc3Qgbj10LnJlZHVjZSgoKHQscik9PnR8fGUuZ2V0RGF0YShyKSksXCJcIik7cmV0dXJuIG51bGwhPW4/bjpyfWNvbnN0IHB0PXtbdXRdOntleHBvc2VQcm9wZXJ0aWVzOntmaWxlczplPT5BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLmZpbGVzKSxpdGVtczplPT5lLml0ZW1zLGRhdGFUcmFuc2ZlcjplPT5lfSxtYXRjaGVzVHlwZXM6W1wiRmlsZXNcIl19LFtodF06e2V4cG9zZVByb3BlcnRpZXM6e2h0bWw6KGUsdCk9PmZ0KGUsdCxcIlwiKSxkYXRhVHJhbnNmZXI6ZT0+ZX0sbWF0Y2hlc1R5cGVzOltcIkh0bWxcIixcInRleHQvaHRtbFwiXX0sW2x0XTp7ZXhwb3NlUHJvcGVydGllczp7dXJsczooZSx0KT0+ZnQoZSx0LFwiXCIpLnNwbGl0KFwiXFxuXCIpLGRhdGFUcmFuc2ZlcjplPT5lfSxtYXRjaGVzVHlwZXM6W1wiVXJsXCIsXCJ0ZXh0L3VyaS1saXN0XCJdfSxbZHRdOntleHBvc2VQcm9wZXJ0aWVzOnt0ZXh0OihlLHQpPT5mdChlLHQsXCJcIiksZGF0YVRyYW5zZmVyOmU9PmV9LG1hdGNoZXNUeXBlczpbXCJUZXh0XCIsXCJ0ZXh0L3BsYWluXCJdfX07ZnVuY3Rpb24gdnQoZSl7aWYoIWUpcmV0dXJuIG51bGw7Y29uc3QgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLnR5cGVzfHxbXSk7cmV0dXJuIE9iamVjdC5rZXlzKHB0KS5maWx0ZXIoKGU9Pntjb25zdCByPXB0W2VdO3JldHVybiEhKG51bGw9PXI/dm9pZCAwOnIubWF0Y2hlc1R5cGVzKSYmci5tYXRjaGVzVHlwZXMuc29tZSgoZT0+dC5pbmRleE9mKGUpPi0xKSl9KSlbMF18fG51bGx9Y29uc3QgbXQ9c3QoKCgpPT4vZmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpKSx5dD1zdCgoKCk9PkJvb2xlYW4od2luZG93LnNhZmFyaSkpKTtjbGFzcyBidHtpbnRlcnBvbGF0ZShlKXtjb25zdHt4czp0LHlzOnIsYzFzOm4sYzJzOm8sYzNzOml9PXRoaXM7bGV0IHM9dC5sZW5ndGgtMTtpZihlPT09dFtzXSlyZXR1cm4gcltzXTtsZXQgYSxjPTAsdT1pLmxlbmd0aC0xO2Zvcig7Yzw9dTspe2E9TWF0aC5mbG9vciguNSooYyt1KSk7Y29uc3Qgbj10W2FdO2lmKG48ZSljPWErMTtlbHNle2lmKCEobj5lKSlyZXR1cm4gclthXTt1PWEtMX19cz1NYXRoLm1heCgwLHUpO2NvbnN0IGw9ZS10W3NdLGQ9bCpsO3JldHVybiByW3NdK25bc10qbCtvW3NdKmQraVtzXSpsKmR9Y29uc3RydWN0b3IoZSx0KXtjb25zdHtsZW5ndGg6cn09ZSxuPVtdO2ZvcihsZXQgZT0wO2U8cjtlKyspbi5wdXNoKGUpO24uc29ydCgoKHQscik9PmVbdF08ZVtyXT8tMToxKSk7Y29uc3Qgbz1bXSxpPVtdO2xldCBzLGE7Zm9yKGxldCBuPTA7bjxyLTE7bisrKXM9ZVtuKzFdLWVbbl0sYT10W24rMV0tdFtuXSxvLnB1c2gocyksaS5wdXNoKGEvcyk7Y29uc3QgYz1baVswXV07Zm9yKGxldCBlPTA7ZTxvLmxlbmd0aC0xO2UrKyl7Y29uc3QgdD1pW2VdLHI9aVtlKzFdO2lmKHQqcjw9MCljLnB1c2goMCk7ZWxzZXtzPW9bZV07Y29uc3Qgbj1vW2UrMV0saT1zK247Yy5wdXNoKDMqaS8oKGkrbikvdCsoaStzKS9yKSl9fWMucHVzaChpW2kubGVuZ3RoLTFdKTtjb25zdCB1PVtdLGw9W107bGV0IGQ7Zm9yKGxldCBlPTA7ZTxjLmxlbmd0aC0xO2UrKyl7ZD1pW2VdO2NvbnN0IHQ9Y1tlXSxyPTEvb1tlXSxuPXQrY1tlKzFdLWQtZDt1LnB1c2goKGQtdC1uKSpyKSxsLnB1c2gobipyKnIpfXRoaXMueHM9ZSx0aGlzLnlzPXQsdGhpcy5jMXM9Yyx0aGlzLmMycz11LHRoaXMuYzNzPWx9fWNvbnN0IE90PTE7ZnVuY3Rpb24gd3QoZSl7Y29uc3QgdD1lLm5vZGVUeXBlPT09T3Q/ZTplLnBhcmVudEVsZW1lbnQ7aWYoIXQpcmV0dXJuIG51bGw7Y29uc3R7dG9wOnIsbGVmdDpufT10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Om4seTpyfX1mdW5jdGlvbiBTdChlKXtyZXR1cm57eDplLmNsaWVudFgseTplLmNsaWVudFl9fWZ1bmN0aW9uIER0KGUsdCxyLG4sbyl7Y29uc3QgaT1cIklNR1wiPT09KHM9dCkubm9kZU5hbWUmJihtdCgpfHwhKG51bGw9PT0oYT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpfHx2b2lkIDA9PT1hP3ZvaWQgMDphLmNvbnRhaW5zKHMpKSk7dmFyIHMsYTtjb25zdCBjPXd0KGk/ZTp0KSx1PXt4OnIueC1jLngseTpyLnktYy55fSx7b2Zmc2V0V2lkdGg6bCxvZmZzZXRIZWlnaHQ6ZH09ZSx7YW5jaG9yWDpoLGFuY2hvclk6Z309bix7ZHJhZ1ByZXZpZXdXaWR0aDpmLGRyYWdQcmV2aWV3SGVpZ2h0OnB9PWZ1bmN0aW9uKGUsdCxyLG4pe2xldCBvPWU/dC53aWR0aDpyLGk9ZT90LmhlaWdodDpuO3JldHVybiB5dCgpJiZlJiYoaS89d2luZG93LmRldmljZVBpeGVsUmF0aW8sby89d2luZG93LmRldmljZVBpeGVsUmF0aW8pLHtkcmFnUHJldmlld1dpZHRoOm8sZHJhZ1ByZXZpZXdIZWlnaHQ6aX19KGksdCxsLGQpLHtvZmZzZXRYOnYsb2Zmc2V0WTptfT1vLHk9MD09PW18fG07cmV0dXJue3g6MD09PXZ8fHY/djpuZXcgYnQoWzAsLjUsMV0sW3UueCx1LngvbCpmLHUueCtmLWxdKS5pbnRlcnBvbGF0ZShoKSx5Onk/bTooKCk9PntsZXQgZT1uZXcgYnQoWzAsLjUsMV0sW3UueSx1LnkvZCpwLHUueStwLWRdKS5pbnRlcnBvbGF0ZShnKTtyZXR1cm4geXQoKSYmaSYmKGUrPSh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpby0xKSpwKSxlfSkoKX19bGV0IEN0O2Z1bmN0aW9uIFR0KGUsdCxyKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOnIsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPXIsZX1mdW5jdGlvbiBFdChlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgcj1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9LG49T2JqZWN0LmtleXMocik7XCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyYmKG49bi5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhyKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSkuZW51bWVyYWJsZX0pKSkpLG4uZm9yRWFjaCgoZnVuY3Rpb24odCl7VHQoZSx0LHJbdF0pfSkpfXJldHVybiBlfWNsYXNzIEl0e3Byb2ZpbGUoKXt2YXIgZSx0O3JldHVybntzb3VyY2VQcmV2aWV3Tm9kZXM6dGhpcy5zb3VyY2VQcmV2aWV3Tm9kZXMuc2l6ZSxzb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnM6dGhpcy5zb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMuc2l6ZSxzb3VyY2VOb2RlT3B0aW9uczp0aGlzLnNvdXJjZU5vZGVPcHRpb25zLnNpemUsc291cmNlTm9kZXM6dGhpcy5zb3VyY2VOb2Rlcy5zaXplLGRyYWdTdGFydFNvdXJjZUlkczoobnVsbD09PShlPXRoaXMuZHJhZ1N0YXJ0U291cmNlSWRzKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5sZW5ndGgpfHwwLGRyb3BUYXJnZXRJZHM6dGhpcy5kcm9wVGFyZ2V0SWRzLmxlbmd0aCxkcmFnRW50ZXJUYXJnZXRJZHM6dGhpcy5kcmFnRW50ZXJUYXJnZXRJZHMubGVuZ3RoLGRyYWdPdmVyVGFyZ2V0SWRzOihudWxsPT09KHQ9dGhpcy5kcmFnT3ZlclRhcmdldElkcyl8fHZvaWQgMD09PXQ/dm9pZCAwOnQubGVuZ3RoKXx8MH19Z2V0IHdpbmRvdygpe3JldHVybiB0aGlzLm9wdGlvbnMud2luZG93fWdldCBkb2N1bWVudCgpe3JldHVybiB0aGlzLm9wdGlvbnMuZG9jdW1lbnR9Z2V0IHJvb3RFbGVtZW50KCl7cmV0dXJuIHRoaXMub3B0aW9ucy5yb290RWxlbWVudH1zZXR1cCgpe2NvbnN0IGU9dGhpcy5yb290RWxlbWVudDtpZih2b2lkIDAhPT1lKXtpZihlLl9faXNSZWFjdERuZEJhY2tlbmRTZXRVcCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaGF2ZSB0d28gSFRNTDUgYmFja2VuZHMgYXQgdGhlIHNhbWUgdGltZS5cIik7ZS5fX2lzUmVhY3REbmRCYWNrZW5kU2V0VXA9ITAsdGhpcy5hZGRFdmVudExpc3RlbmVycyhlKX19dGVhcmRvd24oKXtjb25zdCBlPXRoaXMucm9vdEVsZW1lbnQ7dmFyIHQ7dm9pZCAwIT09ZSYmKGUuX19pc1JlYWN0RG5kQmFja2VuZFNldFVwPSExLHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5yb290RWxlbWVudCksdGhpcy5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSgpLHRoaXMuYXN5bmNFbmREcmFnRnJhbWVJZCYmKG51bGw9PT0odD10aGlzLndpbmRvdyl8fHZvaWQgMD09PXR8fHQuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hc3luY0VuZERyYWdGcmFtZUlkKSkpfWNvbm5lY3REcmFnUHJldmlldyhlLHQscil7cmV0dXJuIHRoaXMuc291cmNlUHJldmlld05vZGVPcHRpb25zLnNldChlLHIpLHRoaXMuc291cmNlUHJldmlld05vZGVzLnNldChlLHQpLCgpPT57dGhpcy5zb3VyY2VQcmV2aWV3Tm9kZXMuZGVsZXRlKGUpLHRoaXMuc291cmNlUHJldmlld05vZGVPcHRpb25zLmRlbGV0ZShlKX19Y29ubmVjdERyYWdTb3VyY2UoZSx0LHIpe3RoaXMuc291cmNlTm9kZXMuc2V0KGUsdCksdGhpcy5zb3VyY2VOb2RlT3B0aW9ucy5zZXQoZSxyKTtjb25zdCBuPXQ9PnRoaXMuaGFuZGxlRHJhZ1N0YXJ0KHQsZSksbz1lPT50aGlzLmhhbmRsZVNlbGVjdFN0YXJ0KGUpO3JldHVybiB0LnNldEF0dHJpYnV0ZShcImRyYWdnYWJsZVwiLFwidHJ1ZVwiKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIixuKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3RzdGFydFwiLG8pLCgpPT57dGhpcy5zb3VyY2VOb2Rlcy5kZWxldGUoZSksdGhpcy5zb3VyY2VOb2RlT3B0aW9ucy5kZWxldGUoZSksdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsbiksdC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0c3RhcnRcIixvKSx0LnNldEF0dHJpYnV0ZShcImRyYWdnYWJsZVwiLFwiZmFsc2VcIil9fWNvbm5lY3REcm9wVGFyZ2V0KGUsdCl7Y29uc3Qgcj10PT50aGlzLmhhbmRsZURyYWdFbnRlcih0LGUpLG49dD0+dGhpcy5oYW5kbGVEcmFnT3Zlcih0LGUpLG89dD0+dGhpcy5oYW5kbGVEcm9wKHQsZSk7cmV0dXJuIHQuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbnRlclwiLHIpLHQuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsbiksdC5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLG8pLCgpPT57dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ2VudGVyXCIsciksdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIixuKSx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsbyl9fWFkZEV2ZW50TGlzdGVuZXJzKGUpe2UuYWRkRXZlbnRMaXN0ZW5lciYmKGUuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLHRoaXMuaGFuZGxlVG9wRHJhZ1N0YXJ0KSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIix0aGlzLmhhbmRsZVRvcERyYWdTdGFydENhcHR1cmUsITApLGUuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbmRcIix0aGlzLmhhbmRsZVRvcERyYWdFbmRDYXB0dXJlLCEwKSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW50ZXJcIix0aGlzLmhhbmRsZVRvcERyYWdFbnRlciksZS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2VudGVyXCIsdGhpcy5oYW5kbGVUb3BEcmFnRW50ZXJDYXB0dXJlLCEwKSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnbGVhdmVcIix0aGlzLmhhbmRsZVRvcERyYWdMZWF2ZUNhcHR1cmUsITApLGUuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsdGhpcy5oYW5kbGVUb3BEcmFnT3ZlciksZS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIix0aGlzLmhhbmRsZVRvcERyYWdPdmVyQ2FwdHVyZSwhMCksZS5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLHRoaXMuaGFuZGxlVG9wRHJvcCksZS5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLHRoaXMuaGFuZGxlVG9wRHJvcENhcHR1cmUsITApKX1yZW1vdmVFdmVudExpc3RlbmVycyhlKXtlLnJlbW92ZUV2ZW50TGlzdGVuZXImJihlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIix0aGlzLmhhbmRsZVRvcERyYWdTdGFydCksZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsdGhpcy5oYW5kbGVUb3BEcmFnU3RhcnRDYXB0dXJlLCEwKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsdGhpcy5oYW5kbGVUb3BEcmFnRW5kQ2FwdHVyZSwhMCksZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ2VudGVyXCIsdGhpcy5oYW5kbGVUb3BEcmFnRW50ZXIpLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdlbnRlclwiLHRoaXMuaGFuZGxlVG9wRHJhZ0VudGVyQ2FwdHVyZSwhMCksZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ2xlYXZlXCIsdGhpcy5oYW5kbGVUb3BEcmFnTGVhdmVDYXB0dXJlLCEwKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLHRoaXMuaGFuZGxlVG9wRHJhZ092ZXIpLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsdGhpcy5oYW5kbGVUb3BEcmFnT3ZlckNhcHR1cmUsITApLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyb3BcIix0aGlzLmhhbmRsZVRvcERyb3ApLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyb3BcIix0aGlzLmhhbmRsZVRvcERyb3BDYXB0dXJlLCEwKSl9Z2V0Q3VycmVudFNvdXJjZU5vZGVPcHRpb25zKCl7Y29uc3QgZT10aGlzLm1vbml0b3IuZ2V0U291cmNlSWQoKSx0PXRoaXMuc291cmNlTm9kZU9wdGlvbnMuZ2V0KGUpO3JldHVybiBFdCh7ZHJvcEVmZmVjdDp0aGlzLmFsdEtleVByZXNzZWQ/XCJjb3B5XCI6XCJtb3ZlXCJ9LHR8fHt9KX1nZXRDdXJyZW50RHJvcEVmZmVjdCgpe3JldHVybiB0aGlzLmlzRHJhZ2dpbmdOYXRpdmVJdGVtKCk/XCJjb3B5XCI6dGhpcy5nZXRDdXJyZW50U291cmNlTm9kZU9wdGlvbnMoKS5kcm9wRWZmZWN0fWdldEN1cnJlbnRTb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMoKXtjb25zdCBlPXRoaXMubW9uaXRvci5nZXRTb3VyY2VJZCgpO3JldHVybiBFdCh7YW5jaG9yWDouNSxhbmNob3JZOi41LGNhcHR1cmVEcmFnZ2luZ1N0YXRlOiExfSx0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucy5nZXQoZSl8fHt9KX1pc0RyYWdnaW5nTmF0aXZlSXRlbSgpe2NvbnN0IGU9dGhpcy5tb25pdG9yLmdldEl0ZW1UeXBlKCk7cmV0dXJuIE9iamVjdC5rZXlzKGd0KS5zb21lKCh0PT5ndFt0XT09PWUpKX1iZWdpbkRyYWdOYXRpdmVJdGVtKGUsdCl7dGhpcy5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSgpLHRoaXMuY3VycmVudE5hdGl2ZVNvdXJjZT1mdW5jdGlvbihlLHQpe2NvbnN0IHI9cHRbZV07aWYoIXIpdGhyb3cgbmV3IEVycm9yKGBuYXRpdmUgdHlwZSAke2V9IGhhcyBubyBjb25maWd1cmF0aW9uYCk7Y29uc3Qgbj1uZXcgY3Qocik7cmV0dXJuIG4ubG9hZERhdGFUcmFuc2Zlcih0KSxufShlLHQpLHRoaXMuY3VycmVudE5hdGl2ZUhhbmRsZT10aGlzLnJlZ2lzdHJ5LmFkZFNvdXJjZShlLHRoaXMuY3VycmVudE5hdGl2ZVNvdXJjZSksdGhpcy5hY3Rpb25zLmJlZ2luRHJhZyhbdGhpcy5jdXJyZW50TmF0aXZlSGFuZGxlXSl9c2V0Q3VycmVudERyYWdTb3VyY2VOb2RlKGUpe3RoaXMuY2xlYXJDdXJyZW50RHJhZ1NvdXJjZU5vZGUoKSx0aGlzLmN1cnJlbnREcmFnU291cmNlTm9kZT1lO3RoaXMubW91c2VNb3ZlVGltZW91dFRpbWVyPXNldFRpbWVvdXQoKCgpPT57dmFyIGU7cmV0dXJuIG51bGw9PT0oZT10aGlzLnJvb3RFbGVtZW50KXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsdGhpcy5lbmREcmFnSWZTb3VyY2VXYXNSZW1vdmVkRnJvbURPTSwhMCl9KSwxZTMpfWNsZWFyQ3VycmVudERyYWdTb3VyY2VOb2RlKCl7aWYodGhpcy5jdXJyZW50RHJhZ1NvdXJjZU5vZGUpe3ZhciBlO2lmKHRoaXMuY3VycmVudERyYWdTb3VyY2VOb2RlPW51bGwsdGhpcy5yb290RWxlbWVudCludWxsPT09KGU9dGhpcy53aW5kb3cpfHx2b2lkIDA9PT1lfHxlLmNsZWFyVGltZW91dCh0aGlzLm1vdXNlTW92ZVRpbWVvdXRUaW1lcnx8dm9pZCAwKSx0aGlzLnJvb3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIix0aGlzLmVuZERyYWdJZlNvdXJjZVdhc1JlbW92ZWRGcm9tRE9NLCEwKTtyZXR1cm4gdGhpcy5tb3VzZU1vdmVUaW1lb3V0VGltZXI9bnVsbCwhMH1yZXR1cm4hMX1oYW5kbGVEcmFnU3RhcnQoZSx0KXtlLmRlZmF1bHRQcmV2ZW50ZWR8fCh0aGlzLmRyYWdTdGFydFNvdXJjZUlkc3x8KHRoaXMuZHJhZ1N0YXJ0U291cmNlSWRzPVtdKSx0aGlzLmRyYWdTdGFydFNvdXJjZUlkcy51bnNoaWZ0KHQpKX1oYW5kbGVEcmFnRW50ZXIoZSx0KXt0aGlzLmRyYWdFbnRlclRhcmdldElkcy51bnNoaWZ0KHQpfWhhbmRsZURyYWdPdmVyKGUsdCl7bnVsbD09PXRoaXMuZHJhZ092ZXJUYXJnZXRJZHMmJih0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzPVtdKSx0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzLnVuc2hpZnQodCl9aGFuZGxlRHJvcChlLHQpe3RoaXMuZHJvcFRhcmdldElkcy51bnNoaWZ0KHQpfWNvbnN0cnVjdG9yKGUsdCxyKXt0aGlzLnNvdXJjZVByZXZpZXdOb2Rlcz1uZXcgTWFwLHRoaXMuc291cmNlUHJldmlld05vZGVPcHRpb25zPW5ldyBNYXAsdGhpcy5zb3VyY2VOb2Rlcz1uZXcgTWFwLHRoaXMuc291cmNlTm9kZU9wdGlvbnM9bmV3IE1hcCx0aGlzLmRyYWdTdGFydFNvdXJjZUlkcz1udWxsLHRoaXMuZHJvcFRhcmdldElkcz1bXSx0aGlzLmRyYWdFbnRlclRhcmdldElkcz1bXSx0aGlzLmN1cnJlbnROYXRpdmVTb3VyY2U9bnVsbCx0aGlzLmN1cnJlbnROYXRpdmVIYW5kbGU9bnVsbCx0aGlzLmN1cnJlbnREcmFnU291cmNlTm9kZT1udWxsLHRoaXMuYWx0S2V5UHJlc3NlZD0hMSx0aGlzLm1vdXNlTW92ZVRpbWVvdXRUaW1lcj1udWxsLHRoaXMuYXN5bmNFbmREcmFnRnJhbWVJZD1udWxsLHRoaXMuZHJhZ092ZXJUYXJnZXRJZHM9bnVsbCx0aGlzLmxhc3RDbGllbnRPZmZzZXQ9bnVsbCx0aGlzLmhvdmVyUmFmSWQ9bnVsbCx0aGlzLmdldFNvdXJjZUNsaWVudE9mZnNldD1lPT57Y29uc3QgdD10aGlzLnNvdXJjZU5vZGVzLmdldChlKTtyZXR1cm4gdCYmd3QodCl8fG51bGx9LHRoaXMuZW5kRHJhZ05hdGl2ZUl0ZW09KCk9Pnt0aGlzLmlzRHJhZ2dpbmdOYXRpdmVJdGVtKCkmJih0aGlzLmFjdGlvbnMuZW5kRHJhZygpLHRoaXMuY3VycmVudE5hdGl2ZUhhbmRsZSYmdGhpcy5yZWdpc3RyeS5yZW1vdmVTb3VyY2UodGhpcy5jdXJyZW50TmF0aXZlSGFuZGxlKSx0aGlzLmN1cnJlbnROYXRpdmVIYW5kbGU9bnVsbCx0aGlzLmN1cnJlbnROYXRpdmVTb3VyY2U9bnVsbCl9LHRoaXMuaXNOb2RlSW5Eb2N1bWVudD1lPT5Cb29sZWFuKGUmJnRoaXMuZG9jdW1lbnQmJnRoaXMuZG9jdW1lbnQuYm9keSYmdGhpcy5kb2N1bWVudC5ib2R5LmNvbnRhaW5zKGUpKSx0aGlzLmVuZERyYWdJZlNvdXJjZVdhc1JlbW92ZWRGcm9tRE9NPSgpPT57Y29uc3QgZT10aGlzLmN1cnJlbnREcmFnU291cmNlTm9kZTtudWxsPT1lfHx0aGlzLmlzTm9kZUluRG9jdW1lbnQoZSl8fCh0aGlzLmNsZWFyQ3VycmVudERyYWdTb3VyY2VOb2RlKCkmJnRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkmJnRoaXMuYWN0aW9ucy5lbmREcmFnKCksdGhpcy5jYW5jZWxIb3ZlcigpKX0sdGhpcy5zY2hlZHVsZUhvdmVyPWU9PntudWxsPT09dGhpcy5ob3ZlclJhZklkJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJiYodGhpcy5ob3ZlclJhZklkPXJlcXVlc3RBbmltYXRpb25GcmFtZSgoKCk9Pnt0aGlzLm1vbml0b3IuaXNEcmFnZ2luZygpJiZ0aGlzLmFjdGlvbnMuaG92ZXIoZXx8W10se2NsaWVudE9mZnNldDp0aGlzLmxhc3RDbGllbnRPZmZzZXR9KSx0aGlzLmhvdmVyUmFmSWQ9bnVsbH0pKSl9LHRoaXMuY2FuY2VsSG92ZXI9KCk9PntudWxsIT09dGhpcy5ob3ZlclJhZklkJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgY2FuY2VsQW5pbWF0aW9uRnJhbWUmJihjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmhvdmVyUmFmSWQpLHRoaXMuaG92ZXJSYWZJZD1udWxsKX0sdGhpcy5oYW5kbGVUb3BEcmFnU3RhcnRDYXB0dXJlPSgpPT57dGhpcy5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSgpLHRoaXMuZHJhZ1N0YXJ0U291cmNlSWRzPVtdfSx0aGlzLmhhbmRsZVRvcERyYWdTdGFydD1lPT57aWYoZS5kZWZhdWx0UHJldmVudGVkKXJldHVybjtjb25zdHtkcmFnU3RhcnRTb3VyY2VJZHM6dH09dGhpczt0aGlzLmRyYWdTdGFydFNvdXJjZUlkcz1udWxsO2NvbnN0IHI9U3QoZSk7dGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSYmKHRoaXMuYWN0aW9ucy5lbmREcmFnKCksdGhpcy5jYW5jZWxIb3ZlcigpKSx0aGlzLmFjdGlvbnMuYmVnaW5EcmFnKHR8fFtdLHtwdWJsaXNoU291cmNlOiExLGdldFNvdXJjZUNsaWVudE9mZnNldDp0aGlzLmdldFNvdXJjZUNsaWVudE9mZnNldCxjbGllbnRPZmZzZXQ6cn0pO2NvbnN0e2RhdGFUcmFuc2ZlcjpufT1lLG89dnQobik7aWYodGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSl7aWYobiYmXCJmdW5jdGlvblwiPT10eXBlb2Ygbi5zZXREcmFnSW1hZ2Upe2NvbnN0IGU9dGhpcy5tb25pdG9yLmdldFNvdXJjZUlkKCksdD10aGlzLnNvdXJjZU5vZGVzLmdldChlKSxvPXRoaXMuc291cmNlUHJldmlld05vZGVzLmdldChlKXx8dDtpZihvKXtjb25zdHthbmNob3JYOmUsYW5jaG9yWTppLG9mZnNldFg6cyxvZmZzZXRZOmF9PXRoaXMuZ2V0Q3VycmVudFNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucygpLGM9RHQodCxvLHIse2FuY2hvclg6ZSxhbmNob3JZOml9LHtvZmZzZXRYOnMsb2Zmc2V0WTphfSk7bi5zZXREcmFnSW1hZ2UobyxjLngsYy55KX19dHJ5e251bGw9PW58fG4uc2V0RGF0YShcImFwcGxpY2F0aW9uL2pzb25cIix7fSl9Y2F0Y2goZSl7fXRoaXMuc2V0Q3VycmVudERyYWdTb3VyY2VOb2RlKGUudGFyZ2V0KTtjb25zdHtjYXB0dXJlRHJhZ2dpbmdTdGF0ZTp0fT10aGlzLmdldEN1cnJlbnRTb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMoKTt0P3RoaXMuYWN0aW9ucy5wdWJsaXNoRHJhZ1NvdXJjZSgpOnNldFRpbWVvdXQoKCgpPT50aGlzLmFjdGlvbnMucHVibGlzaERyYWdTb3VyY2UoKSksMCl9ZWxzZSBpZihvKXRoaXMuYmVnaW5EcmFnTmF0aXZlSXRlbShvKTtlbHNle2lmKG4mJiFuLnR5cGVzJiYoZS50YXJnZXQmJiFlLnRhcmdldC5oYXNBdHRyaWJ1dGV8fCFlLnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIikpKXJldHVybjtlLnByZXZlbnREZWZhdWx0KCl9fSx0aGlzLmhhbmRsZVRvcERyYWdFbmRDYXB0dXJlPSgpPT57dGhpcy5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSgpJiZ0aGlzLm1vbml0b3IuaXNEcmFnZ2luZygpJiZ0aGlzLmFjdGlvbnMuZW5kRHJhZygpLHRoaXMuY2FuY2VsSG92ZXIoKX0sdGhpcy5oYW5kbGVUb3BEcmFnRW50ZXJDYXB0dXJlPWU9Pnt2YXIgdDsodGhpcy5kcmFnRW50ZXJUYXJnZXRJZHM9W10sdGhpcy5pc0RyYWdnaW5nTmF0aXZlSXRlbSgpKSYmKG51bGw9PT0odD10aGlzLmN1cnJlbnROYXRpdmVTb3VyY2UpfHx2b2lkIDA9PT10fHx0LmxvYWREYXRhVHJhbnNmZXIoZS5kYXRhVHJhbnNmZXIpKTtpZighdGhpcy5lbnRlckxlYXZlQ291bnRlci5lbnRlcihlLnRhcmdldCl8fHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpcmV0dXJuO2NvbnN0e2RhdGFUcmFuc2ZlcjpyfT1lLG49dnQocik7biYmdGhpcy5iZWdpbkRyYWdOYXRpdmVJdGVtKG4scil9LHRoaXMuaGFuZGxlVG9wRHJhZ0VudGVyPWU9Pntjb25zdHtkcmFnRW50ZXJUYXJnZXRJZHM6dH09dGhpcztpZih0aGlzLmRyYWdFbnRlclRhcmdldElkcz1bXSwhdGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSlyZXR1cm47dGhpcy5hbHRLZXlQcmVzc2VkPWUuYWx0S2V5LHQubGVuZ3RoPjAmJnRoaXMuYWN0aW9ucy5ob3Zlcih0LHtjbGllbnRPZmZzZXQ6U3QoZSl9KTt0LnNvbWUoKGU9PnRoaXMubW9uaXRvci5jYW5Ecm9wT25UYXJnZXQoZSkpKSYmKGUucHJldmVudERlZmF1bHQoKSxlLmRhdGFUcmFuc2ZlciYmKGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3Q9dGhpcy5nZXRDdXJyZW50RHJvcEVmZmVjdCgpKSl9LHRoaXMuaGFuZGxlVG9wRHJhZ092ZXJDYXB0dXJlPWU9Pnt2YXIgdDsodGhpcy5kcmFnT3ZlclRhcmdldElkcz1bXSx0aGlzLmlzRHJhZ2dpbmdOYXRpdmVJdGVtKCkpJiYobnVsbD09PSh0PXRoaXMuY3VycmVudE5hdGl2ZVNvdXJjZSl8fHZvaWQgMD09PXR8fHQubG9hZERhdGFUcmFuc2ZlcihlLmRhdGFUcmFuc2ZlcikpfSx0aGlzLmhhbmRsZVRvcERyYWdPdmVyPWU9Pntjb25zdHtkcmFnT3ZlclRhcmdldElkczp0fT10aGlzO2lmKHRoaXMuZHJhZ092ZXJUYXJnZXRJZHM9W10sIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpcmV0dXJuIGUucHJldmVudERlZmF1bHQoKSx2b2lkKGUuZGF0YVRyYW5zZmVyJiYoZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdD1cIm5vbmVcIikpO3RoaXMuYWx0S2V5UHJlc3NlZD1lLmFsdEtleSx0aGlzLmxhc3RDbGllbnRPZmZzZXQ9U3QoZSksdGhpcy5zY2hlZHVsZUhvdmVyKHQpOyh0fHxbXSkuc29tZSgoZT0+dGhpcy5tb25pdG9yLmNhbkRyb3BPblRhcmdldChlKSkpPyhlLnByZXZlbnREZWZhdWx0KCksZS5kYXRhVHJhbnNmZXImJihlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0PXRoaXMuZ2V0Q3VycmVudERyb3BFZmZlY3QoKSkpOnRoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKT9lLnByZXZlbnREZWZhdWx0KCk6KGUucHJldmVudERlZmF1bHQoKSxlLmRhdGFUcmFuc2ZlciYmKGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3Q9XCJub25lXCIpKX0sdGhpcy5oYW5kbGVUb3BEcmFnTGVhdmVDYXB0dXJlPWU9Pnt0aGlzLmlzRHJhZ2dpbmdOYXRpdmVJdGVtKCkmJmUucHJldmVudERlZmF1bHQoKTt0aGlzLmVudGVyTGVhdmVDb3VudGVyLmxlYXZlKGUudGFyZ2V0KSYmKHRoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKSYmc2V0VGltZW91dCgoKCk9PnRoaXMuZW5kRHJhZ05hdGl2ZUl0ZW0oKSksMCksdGhpcy5jYW5jZWxIb3ZlcigpKX0sdGhpcy5oYW5kbGVUb3BEcm9wQ2FwdHVyZT1lPT57dmFyIHQ7KHRoaXMuZHJvcFRhcmdldElkcz1bXSx0aGlzLmlzRHJhZ2dpbmdOYXRpdmVJdGVtKCkpPyhlLnByZXZlbnREZWZhdWx0KCksbnVsbD09PSh0PXRoaXMuY3VycmVudE5hdGl2ZVNvdXJjZSl8fHZvaWQgMD09PXR8fHQubG9hZERhdGFUcmFuc2ZlcihlLmRhdGFUcmFuc2ZlcikpOnZ0KGUuZGF0YVRyYW5zZmVyKSYmZS5wcmV2ZW50RGVmYXVsdCgpO3RoaXMuZW50ZXJMZWF2ZUNvdW50ZXIucmVzZXQoKX0sdGhpcy5oYW5kbGVUb3BEcm9wPWU9Pntjb25zdHtkcm9wVGFyZ2V0SWRzOnR9PXRoaXM7dGhpcy5kcm9wVGFyZ2V0SWRzPVtdLHRoaXMuYWN0aW9ucy5ob3Zlcih0LHtjbGllbnRPZmZzZXQ6U3QoZSl9KSx0aGlzLmFjdGlvbnMuZHJvcCh7ZHJvcEVmZmVjdDp0aGlzLmdldEN1cnJlbnREcm9wRWZmZWN0KCl9KSx0aGlzLmlzRHJhZ2dpbmdOYXRpdmVJdGVtKCk/dGhpcy5lbmREcmFnTmF0aXZlSXRlbSgpOnRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkmJnRoaXMuYWN0aW9ucy5lbmREcmFnKCksdGhpcy5jYW5jZWxIb3ZlcigpfSx0aGlzLmhhbmRsZVNlbGVjdFN0YXJ0PWU9Pntjb25zdCB0PWUudGFyZ2V0O1wiZnVuY3Rpb25cIj09dHlwZW9mIHQuZHJhZ0Ryb3AmJihcIklOUFVUXCI9PT10LnRhZ05hbWV8fFwiU0VMRUNUXCI9PT10LnRhZ05hbWV8fFwiVEVYVEFSRUFcIj09PXQudGFnTmFtZXx8dC5pc0NvbnRlbnRFZGl0YWJsZXx8KGUucHJldmVudERlZmF1bHQoKSx0LmRyYWdEcm9wKCkpKX0sdGhpcy5vcHRpb25zPW5ldyBjbGFzc3tnZXQgd2luZG93KCl7cmV0dXJuIHRoaXMuZ2xvYmFsQ29udGV4dD90aGlzLmdsb2JhbENvbnRleHQ6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6dm9pZCAwfWdldCBkb2N1bWVudCgpe3ZhciBlO3JldHVybihudWxsPT09KGU9dGhpcy5nbG9iYWxDb250ZXh0KXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5kb2N1bWVudCk/dGhpcy5nbG9iYWxDb250ZXh0LmRvY3VtZW50OnRoaXMud2luZG93P3RoaXMud2luZG93LmRvY3VtZW50OnZvaWQgMH1nZXQgcm9vdEVsZW1lbnQoKXt2YXIgZTtyZXR1cm4obnVsbD09PShlPXRoaXMub3B0aW9uc0FyZ3MpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLnJvb3RFbGVtZW50KXx8dGhpcy53aW5kb3d9Y29uc3RydWN0b3IoZSx0KXt0aGlzLm93bmVyRG9jdW1lbnQ9bnVsbCx0aGlzLmdsb2JhbENvbnRleHQ9ZSx0aGlzLm9wdGlvbnNBcmdzPXR9fSh0LHIpLHRoaXMuYWN0aW9ucz1lLmdldEFjdGlvbnMoKSx0aGlzLm1vbml0b3I9ZS5nZXRNb25pdG9yKCksdGhpcy5yZWdpc3RyeT1lLmdldFJlZ2lzdHJ5KCksdGhpcy5lbnRlckxlYXZlQ291bnRlcj1uZXcgYXQodGhpcy5pc05vZGVJbkRvY3VtZW50KX19Y29uc3Qga3Q9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBuZXcgSXQoZSx0LHIpfTt2YXIgTHQ7IWZ1bmN0aW9uKGUpe2UubW91c2U9XCJtb3VzZVwiLGUudG91Y2g9XCJ0b3VjaFwiLGUua2V5Ym9hcmQ9XCJrZXlib2FyZFwifShMdHx8KEx0PXt9KSk7Y2xhc3MgUHR7Z2V0IGRlbGF5KCl7dmFyIGU7cmV0dXJuIG51bGwhPT0oZT10aGlzLmFyZ3MuZGVsYXkpJiZ2b2lkIDAhPT1lP2U6MH1nZXQgc2Nyb2xsQW5nbGVSYW5nZXMoKXtyZXR1cm4gdGhpcy5hcmdzLnNjcm9sbEFuZ2xlUmFuZ2VzfWdldCBnZXREcm9wVGFyZ2V0RWxlbWVudHNBdFBvaW50KCl7cmV0dXJuIHRoaXMuYXJncy5nZXREcm9wVGFyZ2V0RWxlbWVudHNBdFBvaW50fWdldCBpZ25vcmVDb250ZXh0TWVudSgpe3ZhciBlO3JldHVybiBudWxsIT09KGU9dGhpcy5hcmdzLmlnbm9yZUNvbnRleHRNZW51KSYmdm9pZCAwIT09ZSYmZX1nZXQgZW5hYmxlSG92ZXJPdXRzaWRlVGFyZ2V0KCl7dmFyIGU7cmV0dXJuIG51bGwhPT0oZT10aGlzLmFyZ3MuZW5hYmxlSG92ZXJPdXRzaWRlVGFyZ2V0KSYmdm9pZCAwIT09ZSYmZX1nZXQgZW5hYmxlS2V5Ym9hcmRFdmVudHMoKXt2YXIgZTtyZXR1cm4gbnVsbCE9PShlPXRoaXMuYXJncy5lbmFibGVLZXlib2FyZEV2ZW50cykmJnZvaWQgMCE9PWUmJmV9Z2V0IGVuYWJsZU1vdXNlRXZlbnRzKCl7dmFyIGU7cmV0dXJuIG51bGwhPT0oZT10aGlzLmFyZ3MuZW5hYmxlTW91c2VFdmVudHMpJiZ2b2lkIDAhPT1lJiZlfWdldCBlbmFibGVUb3VjaEV2ZW50cygpe3ZhciBlO3JldHVybiBudWxsPT09KGU9dGhpcy5hcmdzLmVuYWJsZVRvdWNoRXZlbnRzKXx8dm9pZCAwPT09ZXx8ZX1nZXQgdG91Y2hTbG9wKCl7cmV0dXJuIHRoaXMuYXJncy50b3VjaFNsb3B8fDB9Z2V0IGRlbGF5VG91Y2hTdGFydCgpe3ZhciBlLHQscixuO3JldHVybiBudWxsIT09KG49bnVsbCE9PShyPW51bGw9PT0oZT10aGlzLmFyZ3MpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmRlbGF5VG91Y2hTdGFydCkmJnZvaWQgMCE9PXI/cjpudWxsPT09KHQ9dGhpcy5hcmdzKXx8dm9pZCAwPT09dD92b2lkIDA6dC5kZWxheSkmJnZvaWQgMCE9PW4/bjowfWdldCBkZWxheU1vdXNlU3RhcnQoKXt2YXIgZSx0LHIsbjtyZXR1cm4gbnVsbCE9PShuPW51bGwhPT0ocj1udWxsPT09KGU9dGhpcy5hcmdzKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5kZWxheU1vdXNlU3RhcnQpJiZ2b2lkIDAhPT1yP3I6bnVsbD09PSh0PXRoaXMuYXJncyl8fHZvaWQgMD09PXQ/dm9pZCAwOnQuZGVsYXkpJiZ2b2lkIDAhPT1uP246MH1nZXQgd2luZG93KCl7cmV0dXJuIHRoaXMuY29udGV4dCYmdGhpcy5jb250ZXh0LndpbmRvdz90aGlzLmNvbnRleHQud2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OnZvaWQgMH1nZXQgZG9jdW1lbnQoKXt2YXIgZTtyZXR1cm4obnVsbD09PShlPXRoaXMuY29udGV4dCl8fHZvaWQgMD09PWU/dm9pZCAwOmUuZG9jdW1lbnQpP3RoaXMuY29udGV4dC5kb2N1bWVudDp0aGlzLndpbmRvdz90aGlzLndpbmRvdy5kb2N1bWVudDp2b2lkIDB9Z2V0IHJvb3RFbGVtZW50KCl7dmFyIGU7cmV0dXJuKG51bGw9PT0oZT10aGlzLmFyZ3MpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLnJvb3RFbGVtZW50KXx8dGhpcy5kb2N1bWVudH1jb25zdHJ1Y3RvcihlLHQpe3RoaXMuYXJncz1lLHRoaXMuY29udGV4dD10fX1jb25zdCB4dD0xLE10PTA7ZnVuY3Rpb24gTnQoZSl7cmV0dXJuIHZvaWQgMD09PWUuYnV0dG9ufHxlLmJ1dHRvbj09PU10fWZ1bmN0aW9uIGp0KGUpe3JldHVybiEhZS50YXJnZXRUb3VjaGVzfWZ1bmN0aW9uIFJ0KGUsdCl7cmV0dXJuIGp0KGUpP2Z1bmN0aW9uKGUsdCl7cmV0dXJuIDE9PT1lLnRhcmdldFRvdWNoZXMubGVuZ3RoP1J0KGUudGFyZ2V0VG91Y2hlc1swXSk6dCYmMT09PWUudG91Y2hlcy5sZW5ndGgmJmUudG91Y2hlc1swXS50YXJnZXQ9PT10LnRhcmdldD9SdChlLnRvdWNoZXNbMF0pOnZvaWQgMH0oZSx0KTp7eDplLmNsaWVudFgseTplLmNsaWVudFl9fWNvbnN0IEF0PSgoKT0+e2xldCBlPSExO3RyeXthZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCgoKT0+e30pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcInBhc3NpdmVcIix7Z2V0OigpPT4oZT0hMCwhMCl9KSl9Y2F0Y2goZSl7fXJldHVybiBlfSkoKSxxdD17W0x0Lm1vdXNlXTp7c3RhcnQ6XCJtb3VzZWRvd25cIixtb3ZlOlwibW91c2Vtb3ZlXCIsZW5kOlwibW91c2V1cFwiLGNvbnRleHRtZW51OlwiY29udGV4dG1lbnVcIn0sW0x0LnRvdWNoXTp7c3RhcnQ6XCJ0b3VjaHN0YXJ0XCIsbW92ZTpcInRvdWNobW92ZVwiLGVuZDpcInRvdWNoZW5kXCJ9LFtMdC5rZXlib2FyZF06e2tleWRvd246XCJrZXlkb3duXCJ9fTtjbGFzcyBfdHtwcm9maWxlKCl7dmFyIGU7cmV0dXJue3NvdXJjZU5vZGVzOnRoaXMuc291cmNlTm9kZXMuc2l6ZSxzb3VyY2VQcmV2aWV3Tm9kZXM6dGhpcy5zb3VyY2VQcmV2aWV3Tm9kZXMuc2l6ZSxzb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnM6dGhpcy5zb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMuc2l6ZSx0YXJnZXROb2Rlczp0aGlzLnRhcmdldE5vZGVzLnNpemUsZHJhZ092ZXJUYXJnZXRJZHM6KG51bGw9PT0oZT10aGlzLmRyYWdPdmVyVGFyZ2V0SWRzKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5sZW5ndGgpfHwwfX1nZXQgZG9jdW1lbnQoKXtyZXR1cm4gdGhpcy5vcHRpb25zLmRvY3VtZW50fXNldHVwKCl7Y29uc3QgZT10aGlzLm9wdGlvbnMucm9vdEVsZW1lbnQ7ZSYmKEUoIV90LmlzU2V0VXAsXCJDYW5ub3QgaGF2ZSB0d28gVG91Y2ggYmFja2VuZHMgYXQgdGhlIHNhbWUgdGltZS5cIiksX3QuaXNTZXRVcD0hMCx0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZSxcInN0YXJ0XCIsdGhpcy5nZXRUb3BNb3ZlU3RhcnRIYW5kbGVyKCkpLHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlLFwic3RhcnRcIix0aGlzLmhhbmRsZVRvcE1vdmVTdGFydENhcHR1cmUsITApLHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlLFwibW92ZVwiLHRoaXMuaGFuZGxlVG9wTW92ZSksdGhpcy5hZGRFdmVudExpc3RlbmVyKGUsXCJtb3ZlXCIsdGhpcy5oYW5kbGVUb3BNb3ZlQ2FwdHVyZSwhMCksdGhpcy5hZGRFdmVudExpc3RlbmVyKGUsXCJlbmRcIix0aGlzLmhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlLCEwKSx0aGlzLm9wdGlvbnMuZW5hYmxlTW91c2VFdmVudHMmJiF0aGlzLm9wdGlvbnMuaWdub3JlQ29udGV4dE1lbnUmJnRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlLFwiY29udGV4dG1lbnVcIix0aGlzLmhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlKSx0aGlzLm9wdGlvbnMuZW5hYmxlS2V5Ym9hcmRFdmVudHMmJnRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlLFwia2V5ZG93blwiLHRoaXMuaGFuZGxlQ2FuY2VsT25Fc2NhcGUsITApKX10ZWFyZG93bigpe2NvbnN0IGU9dGhpcy5vcHRpb25zLnJvb3RFbGVtZW50O2UmJihfdC5pc1NldFVwPSExLHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0PXt9LHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLFwic3RhcnRcIix0aGlzLmhhbmRsZVRvcE1vdmVTdGFydENhcHR1cmUsITApLHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLFwic3RhcnRcIix0aGlzLmhhbmRsZVRvcE1vdmVTdGFydCksdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGUsXCJtb3ZlXCIsdGhpcy5oYW5kbGVUb3BNb3ZlQ2FwdHVyZSwhMCksdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGUsXCJtb3ZlXCIsdGhpcy5oYW5kbGVUb3BNb3ZlKSx0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSxcImVuZFwiLHRoaXMuaGFuZGxlVG9wTW92ZUVuZENhcHR1cmUsITApLHRoaXMub3B0aW9ucy5lbmFibGVNb3VzZUV2ZW50cyYmIXRoaXMub3B0aW9ucy5pZ25vcmVDb250ZXh0TWVudSYmdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGUsXCJjb250ZXh0bWVudVwiLHRoaXMuaGFuZGxlVG9wTW92ZUVuZENhcHR1cmUpLHRoaXMub3B0aW9ucy5lbmFibGVLZXlib2FyZEV2ZW50cyYmdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGUsXCJrZXlkb3duXCIsdGhpcy5oYW5kbGVDYW5jZWxPbkVzY2FwZSwhMCksdGhpcy51bmluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyKCkpfWFkZEV2ZW50TGlzdGVuZXIoZSx0LHIsbj0hMSl7Y29uc3Qgbz1BdD97Y2FwdHVyZTpuLHBhc3NpdmU6ITF9Om47dGhpcy5saXN0ZW5lclR5cGVzLmZvckVhY2goKGZ1bmN0aW9uKG4pe2NvbnN0IGk9cXRbbl1bdF07aSYmZS5hZGRFdmVudExpc3RlbmVyKGkscixvKX0pKX1yZW1vdmVFdmVudExpc3RlbmVyKGUsdCxyLG49ITEpe2NvbnN0IG89QXQ/e2NhcHR1cmU6bixwYXNzaXZlOiExfTpuO3RoaXMubGlzdGVuZXJUeXBlcy5mb3JFYWNoKChmdW5jdGlvbihuKXtjb25zdCBpPXF0W25dW3RdO2kmJmUucmVtb3ZlRXZlbnRMaXN0ZW5lcihpLHIsbyl9KSl9Y29ubmVjdERyYWdTb3VyY2UoZSx0KXtjb25zdCByPXRoaXMuaGFuZGxlTW92ZVN0YXJ0LmJpbmQodGhpcyxlKTtyZXR1cm4gdGhpcy5zb3VyY2VOb2Rlcy5zZXQoZSx0KSx0aGlzLmFkZEV2ZW50TGlzdGVuZXIodCxcInN0YXJ0XCIsciksKCk9Pnt0aGlzLnNvdXJjZU5vZGVzLmRlbGV0ZShlKSx0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodCxcInN0YXJ0XCIscil9fWNvbm5lY3REcmFnUHJldmlldyhlLHQscil7cmV0dXJuIHRoaXMuc291cmNlUHJldmlld05vZGVPcHRpb25zLnNldChlLHIpLHRoaXMuc291cmNlUHJldmlld05vZGVzLnNldChlLHQpLCgpPT57dGhpcy5zb3VyY2VQcmV2aWV3Tm9kZXMuZGVsZXRlKGUpLHRoaXMuc291cmNlUHJldmlld05vZGVPcHRpb25zLmRlbGV0ZShlKX19Y29ubmVjdERyb3BUYXJnZXQoZSx0KXtjb25zdCByPXRoaXMub3B0aW9ucy5yb290RWxlbWVudDtpZighdGhpcy5kb2N1bWVudHx8IXIpcmV0dXJuKCk9Pnt9O2NvbnN0IG49bj0+e2lmKCF0aGlzLmRvY3VtZW50fHwhcnx8IXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpcmV0dXJuO2xldCBvO3N3aXRjaChuLnR5cGUpe2Nhc2UgcXQubW91c2UubW92ZTpvPXt4Om4uY2xpZW50WCx5Om4uY2xpZW50WX07YnJlYWs7Y2FzZSBxdC50b3VjaC5tb3ZlOnZhciBpLHM7bz17eDoobnVsbD09PShpPW4udG91Y2hlc1swXSl8fHZvaWQgMD09PWk/dm9pZCAwOmkuY2xpZW50WCl8fDAseToobnVsbD09PShzPW4udG91Y2hlc1swXSl8fHZvaWQgMD09PXM/dm9pZCAwOnMuY2xpZW50WSl8fDB9fWNvbnN0IGE9bnVsbCE9bz90aGlzLmRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoby54LG8ueSk6dm9pZCAwLGM9YSYmdC5jb250YWlucyhhKTtyZXR1cm4gYT09PXR8fGM/dGhpcy5oYW5kbGVNb3ZlKG4sZSk6dm9pZCAwfTtyZXR1cm4gdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuZG9jdW1lbnQuYm9keSxcIm1vdmVcIixuKSx0aGlzLnRhcmdldE5vZGVzLnNldChlLHQpLCgpPT57dGhpcy5kb2N1bWVudCYmKHRoaXMudGFyZ2V0Tm9kZXMuZGVsZXRlKGUpLHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmRvY3VtZW50LmJvZHksXCJtb3ZlXCIsbikpfX1nZXRUb3BNb3ZlU3RhcnRIYW5kbGVyKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5kZWxheVRvdWNoU3RhcnR8fHRoaXMub3B0aW9ucy5kZWxheU1vdXNlU3RhcnQ/dGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnREZWxheTp0aGlzLmhhbmRsZVRvcE1vdmVTdGFydH1pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcihlKXt0aGlzLnVuaW5zdGFsbFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIoKSx0aGlzLmRyYWdnZWRTb3VyY2VOb2RlPWUsdGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcj1uZXcgTXV0YXRpb25PYnNlcnZlcigoKCk9PntlJiYhZS5wYXJlbnRFbGVtZW50JiYodGhpcy5yZXN1cnJlY3RTb3VyY2VOb2RlKCksdGhpcy51bmluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyKCkpfSkpLGUmJmUucGFyZW50RWxlbWVudCYmdGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlci5vYnNlcnZlKGUucGFyZW50RWxlbWVudCx7Y2hpbGRMaXN0OiEwfSl9cmVzdXJyZWN0U291cmNlTm9kZSgpe3RoaXMuZG9jdW1lbnQmJnRoaXMuZHJhZ2dlZFNvdXJjZU5vZGUmJih0aGlzLmRyYWdnZWRTb3VyY2VOb2RlLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy5kcmFnZ2VkU291cmNlTm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXJlYWN0aWRcIiksdGhpcy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGUpKX11bmluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyKCl7dGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlciYmdGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlci5kaXNjb25uZWN0KCksdGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcj12b2lkIDAsdGhpcy5kcmFnZ2VkU291cmNlTm9kZT12b2lkIDB9Y29uc3RydWN0b3IoZSx0LHIpe3RoaXMuZ2V0U291cmNlQ2xpZW50T2Zmc2V0PWU9Pntjb25zdCB0PXRoaXMuc291cmNlTm9kZXMuZ2V0KGUpO3JldHVybiB0JiZmdW5jdGlvbihlKXtjb25zdCB0PTE9PT1lLm5vZGVUeXBlP2U6ZS5wYXJlbnRFbGVtZW50O2lmKCF0KXJldHVybjtjb25zdHt0b3A6cixsZWZ0Om59PXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6bix5OnJ9fSh0KX0sdGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnRDYXB0dXJlPWU9PntOdChlKSYmKHRoaXMubW92ZVN0YXJ0U291cmNlSWRzPVtdKX0sdGhpcy5oYW5kbGVNb3ZlU3RhcnQ9ZT0+e0FycmF5LmlzQXJyYXkodGhpcy5tb3ZlU3RhcnRTb3VyY2VJZHMpJiZ0aGlzLm1vdmVTdGFydFNvdXJjZUlkcy51bnNoaWZ0KGUpfSx0aGlzLmhhbmRsZVRvcE1vdmVTdGFydD1lPT57aWYoIU50KGUpKXJldHVybjtjb25zdCB0PVJ0KGUpO3QmJihqdChlKSYmKHRoaXMubGFzdFRhcmdldFRvdWNoRmFsbGJhY2s9ZS50YXJnZXRUb3VjaGVzWzBdKSx0aGlzLl9tb3VzZUNsaWVudE9mZnNldD10KSx0aGlzLndhaXRpbmdGb3JEZWxheT0hMX0sdGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnREZWxheT1lPT57aWYoIU50KGUpKXJldHVybjtjb25zdCB0PWUudHlwZT09PXF0LnRvdWNoLnN0YXJ0P3RoaXMub3B0aW9ucy5kZWxheVRvdWNoU3RhcnQ6dGhpcy5vcHRpb25zLmRlbGF5TW91c2VTdGFydDt0aGlzLnRpbWVvdXQ9c2V0VGltZW91dCh0aGlzLmhhbmRsZVRvcE1vdmVTdGFydC5iaW5kKHRoaXMsZSksdCksdGhpcy53YWl0aW5nRm9yRGVsYXk9ITB9LHRoaXMuaGFuZGxlVG9wTW92ZUNhcHR1cmU9KCk9Pnt0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzPVtdfSx0aGlzLmhhbmRsZU1vdmU9KGUsdCk9Pnt0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzJiZ0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzLnVuc2hpZnQodCl9LHRoaXMuaGFuZGxlVG9wTW92ZT1lPT57aWYodGhpcy50aW1lb3V0JiZjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KSwhdGhpcy5kb2N1bWVudHx8dGhpcy53YWl0aW5nRm9yRGVsYXkpcmV0dXJuO2NvbnN0e21vdmVTdGFydFNvdXJjZUlkczp0LGRyYWdPdmVyVGFyZ2V0SWRzOnJ9PXRoaXMsbj10aGlzLm9wdGlvbnMuZW5hYmxlSG92ZXJPdXRzaWRlVGFyZ2V0LG89UnQoZSx0aGlzLmxhc3RUYXJnZXRUb3VjaEZhbGxiYWNrKTtpZighbylyZXR1cm47aWYodGhpcy5faXNTY3JvbGxpbmd8fCF0aGlzLm1vbml0b3IuaXNEcmFnZ2luZygpJiZmdW5jdGlvbihlLHQscixuLG8pe2lmKCFvKXJldHVybiExO2NvbnN0IGk9MTgwKk1hdGguYXRhbjIobi10LHItZSkvTWF0aC5QSSsxODA7Zm9yKGxldCBlPTA7ZTxvLmxlbmd0aDsrK2Upe2NvbnN0IHQ9b1tlXTtpZih0JiYobnVsbD09dC5zdGFydHx8aT49dC5zdGFydCkmJihudWxsPT10LmVuZHx8aTw9dC5lbmQpKXJldHVybiEwfXJldHVybiExfSh0aGlzLl9tb3VzZUNsaWVudE9mZnNldC54fHwwLHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0Lnl8fDAsby54LG8ueSx0aGlzLm9wdGlvbnMuc2Nyb2xsQW5nbGVSYW5nZXMpKXJldHVybiB2b2lkKHRoaXMuX2lzU2Nyb2xsaW5nPSEwKTt2YXIgaSxzLGEsYztpZighdGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSYmdGhpcy5fbW91c2VDbGllbnRPZmZzZXQuaGFzT3duUHJvcGVydHkoXCJ4XCIpJiZ0JiYoaT10aGlzLl9tb3VzZUNsaWVudE9mZnNldC54fHwwLHM9dGhpcy5fbW91c2VDbGllbnRPZmZzZXQueXx8MCxhPW8ueCxjPW8ueSxNYXRoLnNxcnQoTWF0aC5wb3coTWF0aC5hYnMoYS1pKSwyKStNYXRoLnBvdyhNYXRoLmFicyhjLXMpLDIpKT4odGhpcy5vcHRpb25zLnRvdWNoU2xvcD90aGlzLm9wdGlvbnMudG91Y2hTbG9wOjApKSYmKHRoaXMubW92ZVN0YXJ0U291cmNlSWRzPXZvaWQgMCx0aGlzLmFjdGlvbnMuYmVnaW5EcmFnKHQse2NsaWVudE9mZnNldDp0aGlzLl9tb3VzZUNsaWVudE9mZnNldCxnZXRTb3VyY2VDbGllbnRPZmZzZXQ6dGhpcy5nZXRTb3VyY2VDbGllbnRPZmZzZXQscHVibGlzaFNvdXJjZTohMX0pKSwhdGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSlyZXR1cm47Y29uc3QgdT10aGlzLnNvdXJjZU5vZGVzLmdldCh0aGlzLm1vbml0b3IuZ2V0U291cmNlSWQoKSk7dGhpcy5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcih1KSx0aGlzLmFjdGlvbnMucHVibGlzaERyYWdTb3VyY2UoKSxlLmNhbmNlbGFibGUmJmUucHJldmVudERlZmF1bHQoKTtjb25zdCBsPShyfHxbXSkubWFwKChlPT50aGlzLnRhcmdldE5vZGVzLmdldChlKSkpLmZpbHRlcigoZT0+ISFlKSksZD10aGlzLm9wdGlvbnMuZ2V0RHJvcFRhcmdldEVsZW1lbnRzQXRQb2ludD90aGlzLm9wdGlvbnMuZ2V0RHJvcFRhcmdldEVsZW1lbnRzQXRQb2ludChvLngsby55LGwpOnRoaXMuZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQoby54LG8ueSksaD1bXTtmb3IoY29uc3QgZSBpbiBkKXtpZighZC5oYXNPd25Qcm9wZXJ0eShlKSljb250aW51ZTtsZXQgdD1kW2VdO2ZvcihudWxsIT10JiZoLnB1c2godCk7dDspdD10LnBhcmVudEVsZW1lbnQsdCYmLTE9PT1oLmluZGV4T2YodCkmJmgucHVzaCh0KX1jb25zdCBnPWguZmlsdGVyKChlPT5sLmluZGV4T2YoZSk+LTEpKS5tYXAoKGU9PnRoaXMuX2dldERyb3BUYXJnZXRJZChlKSkpLmZpbHRlcigoZT0+ISFlKSkuZmlsdGVyKCgoZSx0LHIpPT5yLmluZGV4T2YoZSk9PT10KSk7aWYobilmb3IoY29uc3QgZSBpbiB0aGlzLnRhcmdldE5vZGVzKXtjb25zdCB0PXRoaXMudGFyZ2V0Tm9kZXMuZ2V0KGUpO2lmKHUmJnQmJnQuY29udGFpbnModSkmJi0xPT09Zy5pbmRleE9mKGUpKXtnLnVuc2hpZnQoZSk7YnJlYWt9fWcucmV2ZXJzZSgpLHRoaXMuYWN0aW9ucy5ob3ZlcihnLHtjbGllbnRPZmZzZXQ6b30pfSx0aGlzLl9nZXREcm9wVGFyZ2V0SWQ9ZT0+e2NvbnN0IHQ9dGhpcy50YXJnZXROb2Rlcy5rZXlzKCk7bGV0IHI9dC5uZXh0KCk7Zm9yKDshMT09PXIuZG9uZTspe2NvbnN0IG49ci52YWx1ZTtpZihlPT09dGhpcy50YXJnZXROb2Rlcy5nZXQobikpcmV0dXJuIG47cj10Lm5leHQoKX19LHRoaXMuaGFuZGxlVG9wTW92ZUVuZENhcHR1cmU9ZT0+e3RoaXMuX2lzU2Nyb2xsaW5nPSExLHRoaXMubGFzdFRhcmdldFRvdWNoRmFsbGJhY2s9dm9pZCAwLGZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lLmJ1dHRvbnN8fDA9PShlLmJ1dHRvbnMmeHQpfShlKSYmKHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkmJiF0aGlzLm1vbml0b3IuZGlkRHJvcCgpPyhlLmNhbmNlbGFibGUmJmUucHJldmVudERlZmF1bHQoKSx0aGlzLl9tb3VzZUNsaWVudE9mZnNldD17fSx0aGlzLnVuaW5zdGFsbFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIoKSx0aGlzLmFjdGlvbnMuZHJvcCgpLHRoaXMuYWN0aW9ucy5lbmREcmFnKCkpOnRoaXMubW92ZVN0YXJ0U291cmNlSWRzPXZvaWQgMCl9LHRoaXMuaGFuZGxlQ2FuY2VsT25Fc2NhcGU9ZT0+e1wiRXNjYXBlXCI9PT1lLmtleSYmdGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSYmKHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0PXt9LHRoaXMudW5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcigpLHRoaXMuYWN0aW9ucy5lbmREcmFnKCkpfSx0aGlzLm9wdGlvbnM9bmV3IFB0KHIsdCksdGhpcy5hY3Rpb25zPWUuZ2V0QWN0aW9ucygpLHRoaXMubW9uaXRvcj1lLmdldE1vbml0b3IoKSx0aGlzLnNvdXJjZU5vZGVzPW5ldyBNYXAsdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZXM9bmV3IE1hcCx0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucz1uZXcgTWFwLHRoaXMudGFyZ2V0Tm9kZXM9bmV3IE1hcCx0aGlzLmxpc3RlbmVyVHlwZXM9W10sdGhpcy5fbW91c2VDbGllbnRPZmZzZXQ9e30sdGhpcy5faXNTY3JvbGxpbmc9ITEsdGhpcy5vcHRpb25zLmVuYWJsZU1vdXNlRXZlbnRzJiZ0aGlzLmxpc3RlbmVyVHlwZXMucHVzaChMdC5tb3VzZSksdGhpcy5vcHRpb25zLmVuYWJsZVRvdWNoRXZlbnRzJiZ0aGlzLmxpc3RlbmVyVHlwZXMucHVzaChMdC50b3VjaCksdGhpcy5vcHRpb25zLmVuYWJsZUtleWJvYXJkRXZlbnRzJiZ0aGlzLmxpc3RlbmVyVHlwZXMucHVzaChMdC5rZXlib2FyZCl9fWNvbnN0IHp0PWZ1bmN0aW9uKGUsdD17fSxyPXt9KXtyZXR1cm4gbmV3IF90KGUsdCxyKX0sSHQ9XCJhYmNkZWZnaFwiLnNwbGl0KFwiXCIpLEJ0PXthODpcImJSXCIsYjg6XCJiTlwiLGM4OlwiYkJcIixkODpcImJRXCIsZTg6XCJiS1wiLGY4OlwiYkJcIixnODpcImJOXCIsaDg6XCJiUlwiLGE3OlwiYlBcIixiNzpcImJQXCIsYzc6XCJiUFwiLGQ3OlwiYlBcIixlNzpcImJQXCIsZjc6XCJiUFwiLGc3OlwiYlBcIixoNzpcImJQXCIsYTI6XCJ3UFwiLGIyOlwid1BcIixjMjpcIndQXCIsZDI6XCJ3UFwiLGUyOlwid1BcIixmMjpcIndQXCIsZzI6XCJ3UFwiLGgyOlwid1BcIixhMTpcIndSXCIsYjE6XCJ3TlwiLGMxOlwid0JcIixkMTpcIndRXCIsZTE6XCJ3S1wiLGYxOlwid0JcIixnMTpcIndOXCIsaDE6XCJ3UlwifSxXdD17YTowLGI6MSxjOjIsZDozLGU6NCxmOjUsZzo2LGg6N30sVXQ9e2E6NyxiOjYsYzo1LGQ6NCxlOjMsZjoyLGc6MSxoOjB9LEZ0PVs3LDYsNSw0LDMsMiwxLDBdLCR0PVswLDEsMiwzLDQsNSw2LDddLFZ0PXt3UDplKFwic3ZnXCIsT2JqZWN0LmFzc2lnbih7eG1sbnM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLHZlcnNpb246XCIxLjFcIix3aWR0aDpcIjQ1XCIsaGVpZ2h0OlwiNDVcIn0se2NoaWxkcmVuOmUoXCJwYXRoXCIse2Q6XCJtIDIyLjUsOSBjIC0yLjIxLDAgLTQsMS43OSAtNCw0IDAsMC44OSAwLjI5LDEuNzEgMC43OCwyLjM4IEMgMTcuMzMsMTYuNSAxNiwxOC41OSAxNiwyMSBjIDAsMi4wMyAwLjk0LDMuODQgMi40MSw1LjAzIEMgMTUuNDEsMjcuMDkgMTEsMzEuNTggMTEsMzkuNSBIIDM0IEMgMzQsMzEuNTggMjkuNTksMjcuMDkgMjYuNTksMjYuMDMgMjguMDYsMjQuODQgMjksMjMuMDMgMjksMjEgMjksMTguNTkgMjcuNjcsMTYuNSAyNS43MiwxNS4zOCAyNi4yMSwxNC43MSAyNi41LDEzLjg5IDI2LjUsMTMgYyAwLC0yLjIxIC0xLjc5LC00IC00LC00IHpcIixzdHlsZTp7b3BhY2l0eTpcIjFcIixmaWxsOlwiI2ZmZmZmZlwiLGZpbGxPcGFjaXR5OlwiMVwiLGZpbGxSdWxlOlwibm9uemVyb1wiLHN0cm9rZTpcIiMwMDAwMDBcIixzdHJva2VXaWR0aDpcIjEuNVwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwibWl0ZXJcIixzdHJva2VNaXRlcmxpbWl0OlwiNFwiLHN0cm9rZURhc2hhcnJheTpcIm5vbmVcIixzdHJva2VPcGFjaXR5OlwiMVwifX0pfSkpLHdSOmUoXCJzdmdcIixPYmplY3QuYXNzaWduKHt4bWxuczpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsdmVyc2lvbjpcIjEuMVwiLHdpZHRoOlwiNDVcIixoZWlnaHQ6XCI0NVwifSx7Y2hpbGRyZW46dChcImdcIixPYmplY3QuYXNzaWduKHtzdHlsZTp7b3BhY2l0eTpcIjFcIixmaWxsOlwiI2ZmZmZmZlwiLGZpbGxPcGFjaXR5OlwiMVwiLGZpbGxSdWxlOlwiZXZlbm9kZFwiLHN0cm9rZTpcIiMwMDAwMDBcIixzdHJva2VXaWR0aDpcIjEuNVwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIixzdHJva2VNaXRlcmxpbWl0OlwiNFwiLHN0cm9rZURhc2hhcnJheTpcIm5vbmVcIixzdHJva2VPcGFjaXR5OlwiMVwifX0se2NoaWxkcmVuOltlKFwicGF0aFwiLHtkOlwiTSA5LDM5IEwgMzYsMzkgTCAzNiwzNiBMIDksMzYgTCA5LDM5IHogXCIsc3R5bGU6e3N0cm9rZUxpbmVjYXA6XCJidXR0XCJ9fSksZShcInBhdGhcIix7ZDpcIk0gMTIsMzYgTCAxMiwzMiBMIDMzLDMyIEwgMzMsMzYgTCAxMiwzNiB6IFwiLHN0eWxlOntzdHJva2VMaW5lY2FwOlwiYnV0dFwifX0pLGUoXCJwYXRoXCIse2Q6XCJNIDExLDE0IEwgMTEsOSBMIDE1LDkgTCAxNSwxMSBMIDIwLDExIEwgMjAsOSBMIDI1LDkgTCAyNSwxMSBMIDMwLDExIEwgMzAsOSBMIDM0LDkgTCAzNCwxNFwiLHN0eWxlOntzdHJva2VMaW5lY2FwOlwiYnV0dFwifX0pLGUoXCJwYXRoXCIse2Q6XCJNIDM0LDE0IEwgMzEsMTcgTCAxNCwxNyBMIDExLDE0XCJ9KSxlKFwicGF0aFwiLHtkOlwiTSAzMSwxNyBMIDMxLDI5LjUgTCAxNCwyOS41IEwgMTQsMTdcIixzdHlsZTp7c3Ryb2tlTGluZWNhcDpcImJ1dHRcIixzdHJva2VMaW5lam9pbjpcIm1pdGVyXCJ9fSksZShcInBhdGhcIix7ZDpcIk0gMzEsMjkuNSBMIDMyLjUsMzIgTCAxMi41LDMyIEwgMTQsMjkuNVwifSksZShcInBhdGhcIix7ZDpcIk0gMTEsMTQgTCAzNCwxNFwiLHN0eWxlOntmaWxsOlwibm9uZVwiLHN0cm9rZTpcIiMwMDAwMDBcIixzdHJva2VMaW5lam9pbjpcIm1pdGVyXCJ9fSldfSkpfSkpLHdOOmUoXCJzdmdcIixPYmplY3QuYXNzaWduKHt4bWxuczpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsdmVyc2lvbjpcIjEuMVwiLHdpZHRoOlwiNDVcIixoZWlnaHQ6XCI0NVwifSx7Y2hpbGRyZW46dChcImdcIixPYmplY3QuYXNzaWduKHtzdHlsZTp7b3BhY2l0eTpcIjFcIixmaWxsOlwibm9uZVwiLGZpbGxPcGFjaXR5OlwiMVwiLGZpbGxSdWxlOlwiZXZlbm9kZFwiLHN0cm9rZTpcIiMwMDAwMDBcIixzdHJva2VXaWR0aDpcIjEuNVwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIixzdHJva2VNaXRlcmxpbWl0OlwiNFwiLHN0cm9rZURhc2hhcnJheTpcIm5vbmVcIixzdHJva2VPcGFjaXR5OlwiMVwifX0se2NoaWxkcmVuOltlKFwicGF0aFwiLHtkOlwiTSAyMiwxMCBDIDMyLjUsMTEgMzguNSwxOCAzOCwzOSBMIDE1LDM5IEMgMTUsMzAgMjUsMzIuNSAyMywxOFwiLHN0eWxlOntmaWxsOlwiI2ZmZmZmZlwiLHN0cm9rZTpcIiMwMDAwMDBcIn19KSxlKFwicGF0aFwiLHtkOlwiTSAyNCwxOCBDIDI0LjM4LDIwLjkxIDE4LjQ1LDI1LjM3IDE2LDI3IEMgMTMsMjkgMTMuMTgsMzEuMzQgMTEsMzEgQyA5Ljk1OCwzMC4wNiAxMi40MSwyNy45NiAxMSwyOCBDIDEwLDI4IDExLjE5LDI5LjIzIDEwLDMwIEMgOSwzMCA1Ljk5NywzMSA2LDI2IEMgNiwyNCAxMiwxNCAxMiwxNCBDIDEyLDE0IDEzLjg5LDEyLjEgMTQsMTAuNSBDIDEzLjI3LDkuNTA2IDEzLjUsOC41IDEzLjUsNy41IEMgMTQuNSw2LjUgMTYuNSwxMCAxNi41LDEwIEwgMTguNSwxMCBDIDE4LjUsMTAgMTkuMjgsOC4wMDggMjEsNyBDIDIyLDcgMjIsMTAgMjIsMTBcIixzdHlsZTp7ZmlsbDpcIiNmZmZmZmZcIixzdHJva2U6XCIjMDAwMDAwXCJ9fSksZShcInBhdGhcIix7ZDpcIk0gOS41IDI1LjUgQSAwLjUgMC41IDAgMSAxIDguNSwyNS41IEEgMC41IDAuNSAwIDEgMSA5LjUgMjUuNSB6XCIsc3R5bGU6e2ZpbGw6XCIjMDAwMDAwXCIsc3Ryb2tlOlwiIzAwMDAwMFwifX0pLGUoXCJwYXRoXCIse2Q6XCJNIDE1IDE1LjUgQSAwLjUgMS41IDAgMSAxICAxNCwxNS41IEEgMC41IDEuNSAwIDEgMSAgMTUgMTUuNSB6XCIsdHJhbnNmb3JtOlwibWF0cml4KDAuODY2LDAuNSwtMC41LDAuODY2LDkuNjkzLC01LjE3MylcIixzdHlsZTp7ZmlsbDpcIiMwMDAwMDBcIixzdHJva2U6XCIjMDAwMDAwXCJ9fSldfSkpfSkpLHdCOmUoXCJzdmdcIixPYmplY3QuYXNzaWduKHt4bWxuczpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsdmVyc2lvbjpcIjEuMVwiLHdpZHRoOlwiNDVcIixoZWlnaHQ6XCI0NVwifSx7Y2hpbGRyZW46dChcImdcIixPYmplY3QuYXNzaWduKHtzdHlsZTp7b3BhY2l0eTpcIjFcIixmaWxsOlwibm9uZVwiLGZpbGxSdWxlOlwiZXZlbm9kZFwiLGZpbGxPcGFjaXR5OlwiMVwiLHN0cm9rZTpcIiMwMDAwMDBcIixzdHJva2VXaWR0aDpcIjEuNVwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIixzdHJva2VNaXRlcmxpbWl0OlwiNFwiLHN0cm9rZURhc2hhcnJheTpcIm5vbmVcIixzdHJva2VPcGFjaXR5OlwiMVwifX0se2NoaWxkcmVuOlt0KFwiZ1wiLE9iamVjdC5hc3NpZ24oe3N0eWxlOntmaWxsOlwiI2ZmZmZmZlwiLHN0cm9rZTpcIiMwMDAwMDBcIixzdHJva2VMaW5lY2FwOlwiYnV0dFwifX0se2NoaWxkcmVuOltlKFwicGF0aFwiLHtkOlwiTSA5LDM2IEMgMTIuMzksMzUuMDMgMTkuMTEsMzYuNDMgMjIuNSwzNCBDIDI1Ljg5LDM2LjQzIDMyLjYxLDM1LjAzIDM2LDM2IEMgMzYsMzYgMzcuNjUsMzYuNTQgMzksMzggQyAzOC4zMiwzOC45NyAzNy4zNSwzOC45OSAzNiwzOC41IEMgMzIuNjEsMzcuNTMgMjUuODksMzguOTYgMjIuNSwzNy41IEMgMTkuMTEsMzguOTYgMTIuMzksMzcuNTMgOSwzOC41IEMgNy42NSwzOC45OSA2LjY4LDM4Ljk3IDYsMzggQyA3LjM1LDM2LjU0IDksMzYgOSwzNiB6XCJ9KSxlKFwicGF0aFwiLHtkOlwiTSAxNSwzMiBDIDE3LjUsMzQuNSAyNy41LDM0LjUgMzAsMzIgQyAzMC41LDMwLjUgMzAsMzAgMzAsMzAgQyAzMCwyNy41IDI3LjUsMjYgMjcuNSwyNiBDIDMzLDI0LjUgMzMuNSwxNC41IDIyLjUsMTAuNSBDIDExLjUsMTQuNSAxMiwyNC41IDE3LjUsMjYgQyAxNy41LDI2IDE1LDI3LjUgMTUsMzAgQyAxNSwzMCAxNC41LDMwLjUgMTUsMzIgelwifSksZShcInBhdGhcIix7ZDpcIk0gMjUgOCBBIDIuNSAyLjUgMCAxIDEgIDIwLDggQSAyLjUgMi41IDAgMSAxICAyNSA4IHpcIn0pXX0pKSxlKFwicGF0aFwiLHtkOlwiTSAxNy41LDI2IEwgMjcuNSwyNiBNIDE1LDMwIEwgMzAsMzAgTSAyMi41LDE1LjUgTCAyMi41LDIwLjUgTSAyMCwxOCBMIDI1LDE4XCIsc3R5bGU6e2ZpbGw6XCJub25lXCIsc3Ryb2tlOlwiIzAwMDAwMFwiLHN0cm9rZUxpbmVqb2luOlwibWl0ZXJcIn19KV19KSl9KSksd1E6ZShcInN2Z1wiLE9iamVjdC5hc3NpZ24oe3htbG5zOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIix2ZXJzaW9uOlwiMS4xXCIsd2lkdGg6XCI0NVwiLGhlaWdodDpcIjQ1XCJ9LHtjaGlsZHJlbjp0KFwiZ1wiLE9iamVjdC5hc3NpZ24oe3N0eWxlOntmaWxsOlwiI2ZmZmZmZlwiLHN0cm9rZTpcIiMwMDAwMDBcIixzdHJva2VXaWR0aDpcIjEuNVwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIn19LHtjaGlsZHJlbjpbZShcInBhdGhcIix7ZDpcIk0gOSwyNiBDIDE3LjUsMjQuNSAzMCwyNC41IDM2LDI2IEwgMzguNSwxMy41IEwgMzEsMjUgTCAzMC43LDEwLjkgTCAyNS41LDI0LjUgTCAyMi41LDEwIEwgMTkuNSwyNC41IEwgMTQuMywxMC45IEwgMTQsMjUgTCA2LjUsMTMuNSBMIDksMjYgelwifSksZShcInBhdGhcIix7ZDpcIk0gOSwyNiBDIDksMjggMTAuNSwyOCAxMS41LDMwIEMgMTIuNSwzMS41IDEyLjUsMzEgMTIsMzMuNSBDIDEwLjUsMzQuNSAxMSwzNiAxMSwzNiBDIDkuNSwzNy41IDExLDM4LjUgMTEsMzguNSBDIDE3LjUsMzkuNSAyNy41LDM5LjUgMzQsMzguNSBDIDM0LDM4LjUgMzUuNSwzNy41IDM0LDM2IEMgMzQsMzYgMzQuNSwzNC41IDMzLDMzLjUgQyAzMi41LDMxIDMyLjUsMzEuNSAzMy41LDMwIEMgMzQuNSwyOCAzNiwyOCAzNiwyNiBDIDI3LjUsMjQuNSAxNy41LDI0LjUgOSwyNiB6XCJ9KSxlKFwicGF0aFwiLHtkOlwiTSAxMS41LDMwIEMgMTUsMjkgMzAsMjkgMzMuNSwzMFwiLHN0eWxlOntmaWxsOlwibm9uZVwifX0pLGUoXCJwYXRoXCIse2Q6XCJNIDEyLDMzLjUgQyAxOCwzMi41IDI3LDMyLjUgMzMsMzMuNVwiLHN0eWxlOntmaWxsOlwibm9uZVwifX0pLGUoXCJjaXJjbGVcIix7Y3g6XCI2XCIsY3k6XCIxMlwiLHI6XCIyXCJ9KSxlKFwiY2lyY2xlXCIse2N4OlwiMTRcIixjeTpcIjlcIixyOlwiMlwifSksZShcImNpcmNsZVwiLHtjeDpcIjIyLjVcIixjeTpcIjhcIixyOlwiMlwifSksZShcImNpcmNsZVwiLHtjeDpcIjMxXCIsY3k6XCI5XCIscjpcIjJcIn0pLGUoXCJjaXJjbGVcIix7Y3g6XCIzOVwiLGN5OlwiMTJcIixyOlwiMlwifSldfSkpfSkpLHdLOmUoXCJzdmdcIixPYmplY3QuYXNzaWduKHt4bWxuczpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsdmVyc2lvbjpcIjEuMVwiLHdpZHRoOlwiNDVcIixoZWlnaHQ6XCI0NVwifSx7Y2hpbGRyZW46dChcImdcIixPYmplY3QuYXNzaWduKHtzdHlsZTp7ZmlsbDpcIm5vbmVcIixmaWxsT3BhY2l0eTpcIjFcIixmaWxsUnVsZTpcImV2ZW5vZGRcIixzdHJva2U6XCIjMDAwMDAwXCIsc3Ryb2tlV2lkdGg6XCIxLjVcIixzdHJva2VMaW5lY2FwOlwicm91bmRcIixzdHJva2VMaW5lam9pbjpcInJvdW5kXCIsc3Ryb2tlTWl0ZXJsaW1pdDpcIjRcIixzdHJva2VEYXNoYXJyYXk6XCJub25lXCIsc3Ryb2tlT3BhY2l0eTpcIjFcIn19LHtjaGlsZHJlbjpbZShcInBhdGhcIix7ZDpcIk0gMjIuNSwxMS42MyBMIDIyLjUsNlwiLHN0eWxlOntmaWxsOlwibm9uZVwiLHN0cm9rZTpcIiMwMDAwMDBcIixzdHJva2VMaW5lam9pbjpcIm1pdGVyXCJ9fSksZShcInBhdGhcIix7ZDpcIk0gMjAsOCBMIDI1LDhcIixzdHlsZTp7ZmlsbDpcIm5vbmVcIixzdHJva2U6XCIjMDAwMDAwXCIsc3Ryb2tlTGluZWpvaW46XCJtaXRlclwifX0pLGUoXCJwYXRoXCIse2Q6XCJNIDIyLjUsMjUgQyAyMi41LDI1IDI3LDE3LjUgMjUuNSwxNC41IEMgMjUuNSwxNC41IDI0LjUsMTIgMjIuNSwxMiBDIDIwLjUsMTIgMTkuNSwxNC41IDE5LjUsMTQuNSBDIDE4LDE3LjUgMjIuNSwyNSAyMi41LDI1XCIsc3R5bGU6e2ZpbGw6XCIjZmZmZmZmXCIsc3Ryb2tlOlwiIzAwMDAwMFwiLHN0cm9rZUxpbmVjYXA6XCJidXR0XCIsc3Ryb2tlTGluZWpvaW46XCJtaXRlclwifX0pLGUoXCJwYXRoXCIse2Q6XCJNIDEyLjUsMzcgQyAxOCw0MC41IDI3LDQwLjUgMzIuNSwzNyBMIDMyLjUsMzAgQyAzMi41LDMwIDQxLjUsMjUuNSAzOC41LDE5LjUgQyAzNC41LDEzIDI1LDE2IDIyLjUsMjMuNSBMIDIyLjUsMjcgTCAyMi41LDIzLjUgQyAyMCwxNiAxMC41LDEzIDYuNSwxOS41IEMgMy41LDI1LjUgMTIuNSwzMCAxMi41LDMwIEwgMTIuNSwzN1wiLHN0eWxlOntmaWxsOlwiI2ZmZmZmZlwiLHN0cm9rZTpcIiMwMDAwMDBcIn19KSxlKFwicGF0aFwiLHtkOlwiTSAxMi41LDMwIEMgMTgsMjcgMjcsMjcgMzIuNSwzMFwiLHN0eWxlOntmaWxsOlwibm9uZVwiLHN0cm9rZTpcIiMwMDAwMDBcIn19KSxlKFwicGF0aFwiLHtkOlwiTSAxMi41LDMzLjUgQyAxOCwzMC41IDI3LDMwLjUgMzIuNSwzMy41XCIsc3R5bGU6e2ZpbGw6XCJub25lXCIsc3Ryb2tlOlwiIzAwMDAwMFwifX0pLGUoXCJwYXRoXCIse2Q6XCJNIDEyLjUsMzcgQyAxOCwzNCAyNywzNCAzMi41LDM3XCIsc3R5bGU6e2ZpbGw6XCJub25lXCIsc3Ryb2tlOlwiIzAwMDAwMFwifX0pXX0pKX0pKSxiUDplKFwic3ZnXCIsT2JqZWN0LmFzc2lnbih7eG1sbnM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLHZlcnNpb246XCIxLjFcIix3aWR0aDpcIjQ1XCIsaGVpZ2h0OlwiNDVcIn0se2NoaWxkcmVuOmUoXCJwYXRoXCIse2Q6XCJtIDIyLjUsOSBjIC0yLjIxLDAgLTQsMS43OSAtNCw0IDAsMC44OSAwLjI5LDEuNzEgMC43OCwyLjM4IEMgMTcuMzMsMTYuNSAxNiwxOC41OSAxNiwyMSBjIDAsMi4wMyAwLjk0LDMuODQgMi40MSw1LjAzIEMgMTUuNDEsMjcuMDkgMTEsMzEuNTggMTEsMzkuNSBIIDM0IEMgMzQsMzEuNTggMjkuNTksMjcuMDkgMjYuNTksMjYuMDMgMjguMDYsMjQuODQgMjksMjMuMDMgMjksMjEgMjksMTguNTkgMjcuNjcsMTYuNSAyNS43MiwxNS4zOCAyNi4yMSwxNC43MSAyNi41LDEzLjg5IDI2LjUsMTMgYyAwLC0yLjIxIC0xLjc5LC00IC00LC00IHpcIixzdHlsZTp7b3BhY2l0eTpcIjFcIixmaWxsOlwiIzAwMDAwMFwiLGZpbGxPcGFjaXR5OlwiMVwiLGZpbGxSdWxlOlwibm9uemVyb1wiLHN0cm9rZTpcIiMwMDAwMDBcIixzdHJva2VXaWR0aDpcIjEuNVwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwibWl0ZXJcIixzdHJva2VNaXRlcmxpbWl0OlwiNFwiLHN0cm9rZURhc2hhcnJheTpcIm5vbmVcIixzdHJva2VPcGFjaXR5OlwiMVwifX0pfSkpLGJSOmUoXCJzdmdcIixPYmplY3QuYXNzaWduKHt4bWxuczpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsdmVyc2lvbjpcIjEuMVwiLHdpZHRoOlwiNDVcIixoZWlnaHQ6XCI0NVwifSx7Y2hpbGRyZW46dChcImdcIixPYmplY3QuYXNzaWduKHtzdHlsZTp7b3BhY2l0eTpcIjFcIixmaWxsOlwiIzAwMDAwMFwiLGZpbGxPcGFjaXR5OlwiMVwiLGZpbGxSdWxlOlwiZXZlbm9kZFwiLHN0cm9rZTpcIiMwMDAwMDBcIixzdHJva2VXaWR0aDpcIjEuNVwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIixzdHJva2VNaXRlcmxpbWl0OlwiNFwiLHN0cm9rZURhc2hhcnJheTpcIm5vbmVcIixzdHJva2VPcGFjaXR5OlwiMVwifX0se2NoaWxkcmVuOltlKFwicGF0aFwiLHtkOlwiTSA5LDM5IEwgMzYsMzkgTCAzNiwzNiBMIDksMzYgTCA5LDM5IHogXCIsc3R5bGU6e3N0cm9rZUxpbmVjYXA6XCJidXR0XCJ9fSksZShcInBhdGhcIix7ZDpcIk0gMTIuNSwzMiBMIDE0LDI5LjUgTCAzMSwyOS41IEwgMzIuNSwzMiBMIDEyLjUsMzIgeiBcIixzdHlsZTp7c3Ryb2tlTGluZWNhcDpcImJ1dHRcIn19KSxlKFwicGF0aFwiLHtkOlwiTSAxMiwzNiBMIDEyLDMyIEwgMzMsMzIgTCAzMywzNiBMIDEyLDM2IHogXCIsc3R5bGU6e3N0cm9rZUxpbmVjYXA6XCJidXR0XCJ9fSksZShcInBhdGhcIix7ZDpcIk0gMTQsMjkuNSBMIDE0LDE2LjUgTCAzMSwxNi41IEwgMzEsMjkuNSBMIDE0LDI5LjUgeiBcIixzdHlsZTp7c3Ryb2tlTGluZWNhcDpcImJ1dHRcIixzdHJva2VMaW5lam9pbjpcIm1pdGVyXCJ9fSksZShcInBhdGhcIix7ZDpcIk0gMTQsMTYuNSBMIDExLDE0IEwgMzQsMTQgTCAzMSwxNi41IEwgMTQsMTYuNSB6IFwiLHN0eWxlOntzdHJva2VMaW5lY2FwOlwiYnV0dFwifX0pLGUoXCJwYXRoXCIse2Q6XCJNIDExLDE0IEwgMTEsOSBMIDE1LDkgTCAxNSwxMSBMIDIwLDExIEwgMjAsOSBMIDI1LDkgTCAyNSwxMSBMIDMwLDExIEwgMzAsOSBMIDM0LDkgTCAzNCwxNCBMIDExLDE0IHogXCIsc3R5bGU6e3N0cm9rZUxpbmVjYXA6XCJidXR0XCJ9fSksZShcInBhdGhcIix7ZDpcIk0gMTIsMzUuNSBMIDMzLDM1LjUgTCAzMywzNS41XCIsc3R5bGU6e2ZpbGw6XCJub25lXCIsc3Ryb2tlOlwiI2ZmZmZmZlwiLHN0cm9rZVdpZHRoOlwiMVwiLHN0cm9rZUxpbmVqb2luOlwibWl0ZXJcIn19KSxlKFwicGF0aFwiLHtkOlwiTSAxMywzMS41IEwgMzIsMzEuNVwiLHN0eWxlOntmaWxsOlwibm9uZVwiLHN0cm9rZTpcIiNmZmZmZmZcIixzdHJva2VXaWR0aDpcIjFcIixzdHJva2VMaW5lam9pbjpcIm1pdGVyXCJ9fSksZShcInBhdGhcIix7ZDpcIk0gMTQsMjkuNSBMIDMxLDI5LjVcIixzdHlsZTp7ZmlsbDpcIm5vbmVcIixzdHJva2U6XCIjZmZmZmZmXCIsc3Ryb2tlV2lkdGg6XCIxXCIsc3Ryb2tlTGluZWpvaW46XCJtaXRlclwifX0pLGUoXCJwYXRoXCIse2Q6XCJNIDE0LDE2LjUgTCAzMSwxNi41XCIsc3R5bGU6e2ZpbGw6XCJub25lXCIsc3Ryb2tlOlwiI2ZmZmZmZlwiLHN0cm9rZVdpZHRoOlwiMVwiLHN0cm9rZUxpbmVqb2luOlwibWl0ZXJcIn19KSxlKFwicGF0aFwiLHtkOlwiTSAxMSwxNCBMIDM0LDE0XCIsc3R5bGU6e2ZpbGw6XCJub25lXCIsc3Ryb2tlOlwiI2ZmZmZmZlwiLHN0cm9rZVdpZHRoOlwiMVwiLHN0cm9rZUxpbmVqb2luOlwibWl0ZXJcIn19KV19KSl9KSksYk46ZShcInN2Z1wiLE9iamVjdC5hc3NpZ24oe3htbG5zOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIix2ZXJzaW9uOlwiMS4xXCIsd2lkdGg6XCI0NVwiLGhlaWdodDpcIjQ1XCJ9LHtjaGlsZHJlbjp0KFwiZ1wiLE9iamVjdC5hc3NpZ24oe3N0eWxlOntvcGFjaXR5OlwiMVwiLGZpbGw6XCJub25lXCIsZmlsbE9wYWNpdHk6XCIxXCIsZmlsbFJ1bGU6XCJldmVub2RkXCIsc3Ryb2tlOlwiIzAwMDAwMFwiLHN0cm9rZVdpZHRoOlwiMS41XCIsc3Ryb2tlTGluZWNhcDpcInJvdW5kXCIsc3Ryb2tlTGluZWpvaW46XCJyb3VuZFwiLHN0cm9rZU1pdGVybGltaXQ6XCI0XCIsc3Ryb2tlRGFzaGFycmF5Olwibm9uZVwiLHN0cm9rZU9wYWNpdHk6XCIxXCJ9fSx7Y2hpbGRyZW46W2UoXCJwYXRoXCIse2Q6XCJNIDIyLDEwIEMgMzIuNSwxMSAzOC41LDE4IDM4LDM5IEwgMTUsMzkgQyAxNSwzMCAyNSwzMi41IDIzLDE4XCIsc3R5bGU6e2ZpbGw6XCIjMDAwMDAwXCIsc3Ryb2tlOlwiIzAwMDAwMFwifX0pLGUoXCJwYXRoXCIse2Q6XCJNIDI0LDE4IEMgMjQuMzgsMjAuOTEgMTguNDUsMjUuMzcgMTYsMjcgQyAxMywyOSAxMy4xOCwzMS4zNCAxMSwzMSBDIDkuOTU4LDMwLjA2IDEyLjQxLDI3Ljk2IDExLDI4IEMgMTAsMjggMTEuMTksMjkuMjMgMTAsMzAgQyA5LDMwIDUuOTk3LDMxIDYsMjYgQyA2LDI0IDEyLDE0IDEyLDE0IEMgMTIsMTQgMTMuODksMTIuMSAxNCwxMC41IEMgMTMuMjcsOS41MDYgMTMuNSw4LjUgMTMuNSw3LjUgQyAxNC41LDYuNSAxNi41LDEwIDE2LjUsMTAgTCAxOC41LDEwIEMgMTguNSwxMCAxOS4yOCw4LjAwOCAyMSw3IEMgMjIsNyAyMiwxMCAyMiwxMFwiLHN0eWxlOntmaWxsOlwiIzAwMDAwMFwiLHN0cm9rZTpcIiMwMDAwMDBcIn19KSxlKFwicGF0aFwiLHtkOlwiTSA5LjUgMjUuNSBBIDAuNSAwLjUgMCAxIDEgOC41LDI1LjUgQSAwLjUgMC41IDAgMSAxIDkuNSAyNS41IHpcIixzdHlsZTp7ZmlsbDpcIiNmZmZmZmZcIixzdHJva2U6XCIjZmZmZmZmXCJ9fSksZShcInBhdGhcIix7ZDpcIk0gMTUgMTUuNSBBIDAuNSAxLjUgMCAxIDEgIDE0LDE1LjUgQSAwLjUgMS41IDAgMSAxICAxNSAxNS41IHpcIix0cmFuc2Zvcm06XCJtYXRyaXgoMC44NjYsMC41LC0wLjUsMC44NjYsOS42OTMsLTUuMTczKVwiLHN0eWxlOntmaWxsOlwiI2ZmZmZmZlwiLHN0cm9rZTpcIiNmZmZmZmZcIn19KSxlKFwicGF0aFwiLHtkOlwiTSAyNC41NSwxMC40IEwgMjQuMSwxMS44NSBMIDI0LjYsMTIgQyAyNy43NSwxMyAzMC4yNSwxNC40OSAzMi41LDE4Ljc1IEMgMzQuNzUsMjMuMDEgMzUuNzUsMjkuMDYgMzUuMjUsMzkgTCAzNS4yLDM5LjUgTCAzNy40NSwzOS41IEwgMzcuNSwzOSBDIDM4LDI4Ljk0IDM2LjYyLDIyLjE1IDM0LjI1LDE3LjY2IEMgMzEuODgsMTMuMTcgMjguNDYsMTEuMDIgMjUuMDYsMTAuNSBMIDI0LjU1LDEwLjQgeiBcIixzdHlsZTp7ZmlsbDpcIiNmZmZmZmZcIixzdHJva2U6XCJub25lXCJ9fSldfSkpfSkpLGJCOmUoXCJzdmdcIixPYmplY3QuYXNzaWduKHt4bWxuczpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsdmVyc2lvbjpcIjEuMVwiLHdpZHRoOlwiNDVcIixoZWlnaHQ6XCI0NVwifSx7Y2hpbGRyZW46dChcImdcIixPYmplY3QuYXNzaWduKHtzdHlsZTp7b3BhY2l0eTpcIjFcIixmaWxsOlwibm9uZVwiLGZpbGxSdWxlOlwiZXZlbm9kZFwiLGZpbGxPcGFjaXR5OlwiMVwiLHN0cm9rZTpcIiMwMDAwMDBcIixzdHJva2VXaWR0aDpcIjEuNVwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIixzdHJva2VNaXRlcmxpbWl0OlwiNFwiLHN0cm9rZURhc2hhcnJheTpcIm5vbmVcIixzdHJva2VPcGFjaXR5OlwiMVwifX0se2NoaWxkcmVuOlt0KFwiZ1wiLE9iamVjdC5hc3NpZ24oe3N0eWxlOntmaWxsOlwiIzAwMDAwMFwiLHN0cm9rZTpcIiMwMDAwMDBcIixzdHJva2VMaW5lY2FwOlwiYnV0dFwifX0se2NoaWxkcmVuOltlKFwicGF0aFwiLHtkOlwiTSA5LDM2IEMgMTIuMzksMzUuMDMgMTkuMTEsMzYuNDMgMjIuNSwzNCBDIDI1Ljg5LDM2LjQzIDMyLjYxLDM1LjAzIDM2LDM2IEMgMzYsMzYgMzcuNjUsMzYuNTQgMzksMzggQyAzOC4zMiwzOC45NyAzNy4zNSwzOC45OSAzNiwzOC41IEMgMzIuNjEsMzcuNTMgMjUuODksMzguOTYgMjIuNSwzNy41IEMgMTkuMTEsMzguOTYgMTIuMzksMzcuNTMgOSwzOC41IEMgNy42NSwzOC45OSA2LjY4LDM4Ljk3IDYsMzggQyA3LjM1LDM2LjU0IDksMzYgOSwzNiB6XCJ9KSxlKFwicGF0aFwiLHtkOlwiTSAxNSwzMiBDIDE3LjUsMzQuNSAyNy41LDM0LjUgMzAsMzIgQyAzMC41LDMwLjUgMzAsMzAgMzAsMzAgQyAzMCwyNy41IDI3LjUsMjYgMjcuNSwyNiBDIDMzLDI0LjUgMzMuNSwxNC41IDIyLjUsMTAuNSBDIDExLjUsMTQuNSAxMiwyNC41IDE3LjUsMjYgQyAxNy41LDI2IDE1LDI3LjUgMTUsMzAgQyAxNSwzMCAxNC41LDMwLjUgMTUsMzIgelwifSksZShcInBhdGhcIix7ZDpcIk0gMjUgOCBBIDIuNSAyLjUgMCAxIDEgIDIwLDggQSAyLjUgMi41IDAgMSAxICAyNSA4IHpcIn0pXX0pKSxlKFwicGF0aFwiLHtkOlwiTSAxNy41LDI2IEwgMjcuNSwyNiBNIDE1LDMwIEwgMzAsMzAgTSAyMi41LDE1LjUgTCAyMi41LDIwLjUgTSAyMCwxOCBMIDI1LDE4XCIsc3R5bGU6e2ZpbGw6XCJub25lXCIsc3Ryb2tlOlwiI2ZmZmZmZlwiLHN0cm9rZUxpbmVqb2luOlwibWl0ZXJcIn19KV19KSl9KSksYlE6ZShcInN2Z1wiLE9iamVjdC5hc3NpZ24oe3htbG5zOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIix2ZXJzaW9uOlwiMS4xXCIsd2lkdGg6XCI0NVwiLGhlaWdodDpcIjQ1XCJ9LHtjaGlsZHJlbjp0KFwiZ1wiLE9iamVjdC5hc3NpZ24oe3N0eWxlOntmaWxsOlwiIzAwMDAwMFwiLHN0cm9rZTpcIiMwMDAwMDBcIixzdHJva2VXaWR0aDpcIjEuNVwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIn19LHtjaGlsZHJlbjpbZShcInBhdGhcIix7ZDpcIk0gOSwyNiBDIDE3LjUsMjQuNSAzMCwyNC41IDM2LDI2IEwgMzguNSwxMy41IEwgMzEsMjUgTCAzMC43LDEwLjkgTCAyNS41LDI0LjUgTCAyMi41LDEwIEwgMTkuNSwyNC41IEwgMTQuMywxMC45IEwgMTQsMjUgTCA2LjUsMTMuNSBMIDksMjYgelwiLHN0eWxlOntzdHJva2VMaW5lY2FwOlwiYnV0dFwiLGZpbGw6XCIjMDAwMDAwXCJ9fSksZShcInBhdGhcIix7ZDpcIm0gOSwyNiBjIDAsMiAxLjUsMiAyLjUsNCAxLDEuNSAxLDEgMC41LDMuNSAtMS41LDEgLTEsMi41IC0xLDIuNSAtMS41LDEuNSAwLDIuNSAwLDIuNSA2LjUsMSAxNi41LDEgMjMsMCAwLDAgMS41LC0xIDAsLTIuNSAwLDAgMC41LC0xLjUgLTEsLTIuNSAtMC41LC0yLjUgLTAuNSwtMiAwLjUsLTMuNSAxLC0yIDIuNSwtMiAyLjUsLTQgLTguNSwtMS41IC0xOC41LC0xLjUgLTI3LDAgelwifSksZShcInBhdGhcIix7ZDpcIk0gMTEuNSwzMCBDIDE1LDI5IDMwLDI5IDMzLjUsMzBcIn0pLGUoXCJwYXRoXCIse2Q6XCJtIDEyLDMzLjUgYyA2LC0xIDE1LC0xIDIxLDBcIn0pLGUoXCJjaXJjbGVcIix7Y3g6XCI2XCIsY3k6XCIxMlwiLHI6XCIyXCJ9KSxlKFwiY2lyY2xlXCIse2N4OlwiMTRcIixjeTpcIjlcIixyOlwiMlwifSksZShcImNpcmNsZVwiLHtjeDpcIjIyLjVcIixjeTpcIjhcIixyOlwiMlwifSksZShcImNpcmNsZVwiLHtjeDpcIjMxXCIsY3k6XCI5XCIscjpcIjJcIn0pLGUoXCJjaXJjbGVcIix7Y3g6XCIzOVwiLGN5OlwiMTJcIixyOlwiMlwifSksZShcInBhdGhcIix7ZDpcIk0gMTEsMzguNSBBIDM1LDM1IDEgMCAwIDM0LDM4LjVcIixzdHlsZTp7ZmlsbDpcIm5vbmVcIixzdHJva2U6XCIjMDAwMDAwXCIsc3Ryb2tlTGluZWNhcDpcImJ1dHRcIn19KSx0KFwiZ1wiLE9iamVjdC5hc3NpZ24oe3N0eWxlOntmaWxsOlwibm9uZVwiLHN0cm9rZTpcIiNmZmZmZmZcIn19LHtjaGlsZHJlbjpbZShcInBhdGhcIix7ZDpcIk0gMTEsMjkgQSAzNSwzNSAxIDAgMSAzNCwyOVwifSksZShcInBhdGhcIix7ZDpcIk0gMTIuNSwzMS41IEwgMzIuNSwzMS41XCJ9KSxlKFwicGF0aFwiLHtkOlwiTSAxMS41LDM0LjUgQSAzNSwzNSAxIDAgMCAzMy41LDM0LjVcIn0pLGUoXCJwYXRoXCIse2Q6XCJNIDEwLjUsMzcuNSBBIDM1LDM1IDEgMCAwIDM0LjUsMzcuNVwifSldfSkpXX0pKX0pKSxiSzplKFwic3ZnXCIsT2JqZWN0LmFzc2lnbih7eG1sbnM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLHZlcnNpb246XCIxLjFcIix3aWR0aDpcIjQ1XCIsaGVpZ2h0OlwiNDVcIn0se2NoaWxkcmVuOnQoXCJnXCIsT2JqZWN0LmFzc2lnbih7c3R5bGU6e2ZpbGw6XCJub25lXCIsZmlsbE9wYWNpdHk6XCIxXCIsZmlsbFJ1bGU6XCJldmVub2RkXCIsc3Ryb2tlOlwiIzAwMDAwMFwiLHN0cm9rZVdpZHRoOlwiMS41XCIsc3Ryb2tlTGluZWNhcDpcInJvdW5kXCIsc3Ryb2tlTGluZWpvaW46XCJyb3VuZFwiLHN0cm9rZU1pdGVybGltaXQ6XCI0XCIsc3Ryb2tlRGFzaGFycmF5Olwibm9uZVwiLHN0cm9rZU9wYWNpdHk6XCIxXCJ9fSx7Y2hpbGRyZW46W2UoXCJwYXRoXCIse2Q6XCJNIDIyLjUsMTEuNjMgTCAyMi41LDZcIixzdHlsZTp7ZmlsbDpcIm5vbmVcIixzdHJva2U6XCIjMDAwMDAwXCIsc3Ryb2tlTGluZWpvaW46XCJtaXRlclwifSxpZDpcInBhdGg2NTcwXCJ9KSxlKFwicGF0aFwiLHtkOlwiTSAyMi41LDI1IEMgMjIuNSwyNSAyNywxNy41IDI1LjUsMTQuNSBDIDI1LjUsMTQuNSAyNC41LDEyIDIyLjUsMTIgQyAyMC41LDEyIDE5LjUsMTQuNSAxOS41LDE0LjUgQyAxOCwxNy41IDIyLjUsMjUgMjIuNSwyNVwiLHN0eWxlOntmaWxsOlwiIzAwMDAwMFwiLGZpbGxPcGFjaXR5OlwiMVwiLHN0cm9rZUxpbmVjYXA6XCJidXR0XCIsc3Ryb2tlTGluZWpvaW46XCJtaXRlclwifX0pLGUoXCJwYXRoXCIse2Q6XCJNIDEyLjUsMzcgQyAxOCw0MC41IDI3LDQwLjUgMzIuNSwzNyBMIDMyLjUsMzAgQyAzMi41LDMwIDQxLjUsMjUuNSAzOC41LDE5LjUgQyAzNC41LDEzIDI1LDE2IDIyLjUsMjMuNSBMIDIyLjUsMjcgTCAyMi41LDIzLjUgQyAyMCwxNiAxMC41LDEzIDYuNSwxOS41IEMgMy41LDI1LjUgMTIuNSwzMCAxMi41LDMwIEwgMTIuNSwzN1wiLHN0eWxlOntmaWxsOlwiIzAwMDAwMFwiLHN0cm9rZTpcIiMwMDAwMDBcIn19KSxlKFwicGF0aFwiLHtkOlwiTSAyMCw4IEwgMjUsOFwiLHN0eWxlOntmaWxsOlwibm9uZVwiLHN0cm9rZTpcIiMwMDAwMDBcIixzdHJva2VMaW5lam9pbjpcIm1pdGVyXCJ9fSksZShcInBhdGhcIix7ZDpcIk0gMzIsMjkuNSBDIDMyLDI5LjUgNDAuNSwyNS41IDM4LjAzLDE5Ljg1IEMgMzQuMTUsMTQgMjUsMTggMjIuNSwyNC41IEwgMjIuNSwyNi42IEwgMjIuNSwyNC41IEMgMjAsMTggMTAuODUsMTQgNi45NywxOS44NSBDIDQuNSwyNS41IDEzLDI5LjUgMTMsMjkuNVwiLHN0eWxlOntmaWxsOlwibm9uZVwiLHN0cm9rZTpcIiNmZmZmZmZcIn19KSxlKFwicGF0aFwiLHtkOlwiTSAxMi41LDMwIEMgMTgsMjcgMjcsMjcgMzIuNSwzMCBNIDEyLjUsMzMuNSBDIDE4LDMwLjUgMjcsMzAuNSAzMi41LDMzLjUgTSAxMi41LDM3IEMgMTgsMzQgMjcsMzQgMzIuNSwzN1wiLHN0eWxlOntmaWxsOlwibm9uZVwiLHN0cm9rZTpcIiNmZmZmZmZcIn19KV19KSl9KSl9O2Z1bmN0aW9uIFl0KGUsdCxyKXtjb25zdCBuPXQvOCxvPVwid2hpdGVcIj09PWU/RnQ6JHQ7cmV0dXJue3g6KFwid2hpdGVcIj09PWU/V3Q6VXQpW3JbMF1dKm4rbi8yLHk6b1twYXJzZUludChyWzFdLDEwKS0xXSpuK24vMn19ZnVuY3Rpb24gS3QoZSl7cmV0dXJuXCJzdGFydFwiPT09ZT9CdDpcInN0cmluZ1wiPT10eXBlb2YgZT9mdW5jdGlvbihlKXtpZighZnVuY3Rpb24oZSl7ZT1lLnJlcGxhY2UoLyAuKyQvLFwiXCIpLGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVwbGFjZSgvOC9nLFwiMTExMTExMTFcIikucmVwbGFjZSgvNy9nLFwiMTExMTExMVwiKS5yZXBsYWNlKC82L2csXCIxMTExMTFcIikucmVwbGFjZSgvNS9nLFwiMTExMTFcIikucmVwbGFjZSgvNC9nLFwiMTExMVwiKS5yZXBsYWNlKC8zL2csXCIxMTFcIikucmVwbGFjZSgvMi9nLFwiMTFcIil9KGUpO2NvbnN0IHQ9ZS5zcGxpdChcIi9cIik7aWYoOCE9PXQubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgZT0wO2U8ODtlKyspaWYoOCE9PXRbZV0ubGVuZ3RofHwtMSE9PXRbZV0uc2VhcmNoKC9bXmtxcm5icEtRUk5CUDFdLykpcmV0dXJuITE7cmV0dXJuITB9KGUpKXJldHVybnt9O2NvbnN0IHQ9KGU9ZS5yZXBsYWNlKC8gLiskLyxcIlwiKSkuc3BsaXQoXCIvXCIpLHI9e307bGV0IG49ODtmb3IobGV0IGU9MDtlPDg7ZSsrKXtjb25zdCBvPXRbZV0uc3BsaXQoXCJcIik7bGV0IGk9MDtmb3IobGV0IGU9MDtlPG8ubGVuZ3RoO2UrKylpZigtMSE9PW9bZV0uc2VhcmNoKC9bMS04XS8pKXtpKz1wYXJzZUludChvW2VdLDEwKX1lbHNle3JbSHRbaV0rbl09WHQob1tlXSksaSs9MX1uLT0xfXJldHVybiByfShlKTplfWZ1bmN0aW9uIFh0KGUpe3JldHVybiBlLnRvTG93ZXJDYXNlKCk9PT1lP1wiYlwiK2UudG9VcHBlckNhc2UoKTpcIndcIitlLnRvVXBwZXJDYXNlKCl9Y29uc3QgR3Q9ZT0+QXJyYXkuZnJvbShlKS5tYXAoKGU9PmUuc3BsaXQoXCIsXCIpKSksUXQ9KGUsdD0hMCxyKT0+e2NvbnN0W24sb109YShuZXcgU2V0KSxbcyxjXT1hKCk7aSgoKCk9PntlJiYoMCE9PWUubGVuZ3RofHxuLnNpemU+MCkmJm8oKGU9Pm5ldyBTZXQobnVsbD09ZT92b2lkIDA6ZS5tYXAoKGU9PmUuam9pbihcIixcIikpKSkpKGUpKX0pLFtlXSksaSgoKCk9PntudWxsPT1yfHxyKEd0KG4pKX0pLFtuXSk7cmV0dXJue2Fycm93czpHdChuKSxuZXdBcnJvdzpzLGNsZWFyQXJyb3dzOmZ1bmN0aW9uKCl7byhuZXcgU2V0KSxjKHZvaWQgMCl9LHJlbW92ZUFycm93OihlLHQpPT57bGV0IHI7Y29uc3QgaT1BcnJheS5mcm9tKG4pO2Zvcihjb25zdFtuXW9mIGkuZW50cmllcygpKWlbbl1bMF09PT1lJiZpW25dWzFdPT09dCYmKG8oKGU9Pntjb25zdCB0PVsuLi5lXTtyZXR1cm4gdC5zcGxpY2UobiwxKSxuZXcgU2V0KHQpfSkpLHI9W2UsdF0pO3JldHVybiBCb29sZWFuKHIpfSxkcmF3TmV3QXJyb3c6KGUscik9Pnt0JiZlIT09ciYmYyhbZSxyXSl9LHNldEFycm93czpvLG9uQXJyb3dEcmF3RW5kOihlLHQpPT57aWYoZT09PXQpcmV0dXJuO2NvbnN0IHI9YCR7ZX0sJHt0fWAsaT1uZXcgU2V0KG4pO2kuaGFzKHIpP2kuZGVsZXRlKHIpOmkuYWRkKHIpLGModm9pZCAwKSxvKGkpfX19LEp0PW4oe30pLFp0PSgpPT5oKEp0KSxlcj1nKCgoe2FuaW1hdGlvbkR1cmF0aW9uOnQ9MzAwLGFyZUFycm93c0FsbG93ZWQ6cj0hMCxhcmVQaWVjZXNEcmFnZ2FibGU6bj0hMCxhcmVQcmVtb3Zlc0FsbG93ZWQ6bz0hMSxib2FyZE9yaWVudGF0aW9uOnM9XCJ3aGl0ZVwiLGJvYXJkV2lkdGg6YyxjaGlsZHJlbjp1LGNsZWFyUHJlbW92ZXNPblJpZ2h0Q2xpY2s6bD0hMCxjdXN0b21BcnJvd3M6ZCxjdXN0b21BcnJvd0NvbG9yOmg9XCJyZ2IoMjU1LDE3MCwwKVwiLGN1c3RvbUJvYXJkU3R5bGU6ZyxjdXN0b21EYXJrU3F1YXJlU3R5bGU6dj17YmFja2dyb3VuZENvbG9yOlwiI0I1ODg2M1wifSxjdXN0b21Ecm9wU3F1YXJlU3R5bGU6bT17Ym94U2hhZG93OlwiaW5zZXQgMCAwIDFweCA2cHggcmdiYSgyNTUsMjU1LDI1NSwwLjc1KVwifSxjdXN0b21MaWdodFNxdWFyZVN0eWxlOnk9e2JhY2tncm91bmRDb2xvcjpcIiNGMEQ5QjVcIn0sY3VzdG9tUGllY2VzOmIsY3VzdG9tUHJlbW92ZURhcmtTcXVhcmVTdHlsZTpPPXtiYWNrZ3JvdW5kQ29sb3I6XCIjQTQyMzIzXCJ9LGN1c3RvbVByZW1vdmVMaWdodFNxdWFyZVN0eWxlOnc9e2JhY2tncm91bmRDb2xvcjpcIiNCRDI4MjhcIn0sY3VzdG9tU3F1YXJlOlM9XCJkaXZcIixjdXN0b21TcXVhcmVTdHlsZXM6RCxkcm9wT2ZmQm9hcmRBY3Rpb246Qz1cInNuYXBiYWNrXCIsaWQ6VD0wLGlzRHJhZ2dhYmxlUGllY2U6RT0oKCk9PiEwKSxnZXRQb3NpdGlvbk9iamVjdDpJPSgoKT0+e30pLG9uQXJyb3dzQ2hhbmdlOms9KCgpPT57fSksb25EcmFnT3ZlclNxdWFyZTpMPSgoKT0+e30pLG9uTW91c2VPdXRTcXVhcmU6UD0oKCk9Pnt9KSxvbk1vdXNlT3ZlclNxdWFyZTp4PSgoKT0+e30pLG9uUGllY2VDbGljazpNPSgoKT0+e30pLG9uUGllY2VEcmFnQmVnaW46Tj0oKCk9Pnt9KSxvblBpZWNlRHJhZ0VuZDpqPSgoKT0+e30pLG9uUGllY2VEcm9wOlI9KCgpPT4hMCksb25Qcm9tb3Rpb25QaWVjZVNlbGVjdDpBLG9uU3F1YXJlQ2xpY2s6cT0oKCk9Pnt9KSxvblNxdWFyZVJpZ2h0Q2xpY2s6Xz0oKCk9Pnt9KSxwb3NpdGlvbjp6PVwic3RhcnRcIixwcm9tb3Rpb25EaWFsb2dWYXJpYW50Okg9XCJkZWZhdWx0XCIscHJvbW90aW9uVG9TcXVhcmU6Qj1udWxsLHNob3dCb2FyZE5vdGF0aW9uOlc9ITAsc2hvd1Byb21vdGlvbkRpYWxvZzpVPSExLHNuYXBUb0N1cnNvcjpGPSEwLGF1dG9Qcm9tb3RlVG9RdWVlbjokPSExfSxWKT0+e2NvbnN0W1ksS109YShLdCh6KSksW1gsR109YSh7cmVtb3ZlZDp7fSxhZGRlZDp7fX0pLFtRLEpdPWEodm9pZCAwKSxbWixlZV09YShVJiYhJCksW3RlLHJlXT1hKG51bGwpLFtuZSxvZV09YShCKSxbaWUsc2VdPWEoW10pLGFlPWYoaWUpLFtjZSx1ZV09YSgpLFtsZSxkZV09YShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sVnQpLGIpKSxbaGUsZ2VdPWEoITEpLFtmZSxwZV09YSgpLFt2ZSxtZV09YSghMSk7cChWLCgoKT0+KHtjbGVhclByZW1vdmVzKGU9ITApe0NlKGUpfX0pKSksaSgoKCk9PntkZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sVnQpLGIpKX0pLFtiXSksaSgoKCk9PntlZShVKSxvZShCKX0pLFtCLFVdKSxpKCgoKT0+e3ZhciBlLHIsbjtUZSgpO2NvbnN0IGk9S3Qoeikscz1mdW5jdGlvbihlLHQpe2NvbnN0IHI9e3JlbW92ZWQ6e30sYWRkZWQ6e319O3JldHVybiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChuPT57dFtuXSE9PWVbbl0mJihyLnJlbW92ZWRbbl09ZVtuXSl9KSksT2JqZWN0LmtleXModCkuZm9yRWFjaCgobj0+e2Vbbl0hPT10W25dJiYoci5hZGRlZFtuXT10W25dKX0pKSxyfShZLGkpLGE9KG51bGw9PT0oZT1PYmplY3Qua2V5cyhzLmFkZGVkKSl8fHZvaWQgMD09PWU/dm9pZCAwOmUubGVuZ3RoKTw9Mj9udWxsPT09KG49bnVsbD09PShyPU9iamVjdC5lbnRyaWVzKHMuYWRkZWQpKXx8dm9pZCAwPT09cj92b2lkIDA6clswXSl8fHZvaWQgMD09PW4/dm9pZCAwOm5bMV1bMF06dm9pZCAwO2lmKHZlKUsoaSksbWUoITEpLG8mJkRlKGEpLGZlJiZjbGVhclRpbWVvdXQoZmUpO2Vsc2UgaWYoaGUpSyhpKSxtZSghMSksbyYmRGUoYSk7ZWxzZXshZnVuY3Rpb24oZSl7bGV0IHQ9ITE7cmV0dXJuIE9iamVjdC5rZXlzKEJ0KS5mb3JFYWNoKChyPT57ZVtyXSE9PUJ0W3JdJiYodD0hMCl9KSksT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgocj0+e0J0W3JdIT09ZVtyXSYmKHQ9ITApfSkpLHR9KGkpfHx2b2lkIDA9PT1RP0oodm9pZCAwKTpKKGEpLEcocyksbWUoITApO2NvbnN0IGU9c2V0VGltZW91dCgoKCk9PntLKGkpLG1lKCExKSxvJiZEZShhKX0pLHQpO3BlKGUpfXJldHVybiBnZSghMSksSShpKSxPZSgpLCgpPT57Y2xlYXJUaW1lb3V0KGZlKX19KSxbel0pO2NvbnN0e2Fycm93czp5ZSxuZXdBcnJvdzpiZSxjbGVhckFycm93czpPZSxkcmF3TmV3QXJyb3c6d2Usb25BcnJvd0RyYXdFbmQ6U2V9PVF0KGQscixrKTtmdW5jdGlvbiBEZShlKXtpZigwPT09YWUuY3VycmVudC5sZW5ndGgpcmV0dXJuO2NvbnN0IHQ9YWUuY3VycmVudFswXTtpZih2b2lkIDAhPT10LnBpZWNlWzBdJiZ0LnBpZWNlWzBdIT09ZSYmUi5sZW5ndGgpe0oodC5waWVjZVswXSksZ2UoITApO2lmKFIodC5zb3VyY2VTcSx0LnRhcmdldFNxLHQucGllY2UpKXtjb25zdCBlPVsuLi5hZS5jdXJyZW50XTtlLnNoaWZ0KCksYWUuY3VycmVudD1lLHNlKFsuLi5lXSl9ZWxzZSBDZSgpfX1mdW5jdGlvbiBDZShlPSEwKXtlJiZKKHZvaWQgMCksYWUuY3VycmVudD1bXSxzZShbXSl9ZnVuY3Rpb24gVGUoKXtyZShudWxsKSxvZShudWxsKSxlZSghMSl9Y29uc3QgRWU9e2FuaW1hdGlvbkR1cmF0aW9uOnQsYXJlUGllY2VzRHJhZ2dhYmxlOm4sYXJlUHJlbW92ZXNBbGxvd2VkOm8sYm9hcmRPcmllbnRhdGlvbjpzLGJvYXJkV2lkdGg6YyxjdXN0b21BcnJvd0NvbG9yOmgsY3VzdG9tQm9hcmRTdHlsZTpnLGN1c3RvbURhcmtTcXVhcmVTdHlsZTp2LGN1c3RvbURyb3BTcXVhcmVTdHlsZTptLGN1c3RvbUxpZ2h0U3F1YXJlU3R5bGU6eSxjdXN0b21QcmVtb3ZlRGFya1NxdWFyZVN0eWxlOk8sY3VzdG9tUHJlbW92ZUxpZ2h0U3F1YXJlU3R5bGU6dyxjdXN0b21TcXVhcmU6UyxjdXN0b21TcXVhcmVTdHlsZXM6RCxpZDpULGlzRHJhZ2dhYmxlUGllY2U6RSxvbkRyYWdPdmVyU3F1YXJlOkwsb25Nb3VzZU91dFNxdWFyZTpQLG9uTW91c2VPdmVyU3F1YXJlOngsb25QaWVjZUNsaWNrOk0sb25QaWVjZURyYWdCZWdpbjpOLG9uUGllY2VEcmFnRW5kOmosb25QaWVjZURyb3A6UixvblByb21vdGlvblBpZWNlU2VsZWN0OkEsb25TcXVhcmVDbGljazpxLHNob3dCb2FyZE5vdGF0aW9uOlcsc25hcFRvQ3Vyc29yOkYscHJvbW90aW9uRGlhbG9nVmFyaWFudDpILGFycm93czp5ZSxuZXdBcnJvdzpiZSxvbkFycm93RHJhd0VuZDpTZSxjaGVzc1BpZWNlczpsZSxjbGVhckFycm93czpPZSxkcmF3TmV3QXJyb3c6d2UsY2xlYXJDdXJyZW50UmlnaHRDbGlja0Rvd246ZnVuY3Rpb24oKXt1ZSh2b2lkIDApfSxjdXJyZW50UG9zaXRpb246WSxoYW5kbGVTZXRQb3NpdGlvbjpmdW5jdGlvbihlLHQscixuKXtpZihlPT09dClyZXR1cm47aWYoT2UoKSxvJiZ2ZXx8byYmKFE9PT1yWzBdfHxhZS5jdXJyZW50LmZpbHRlcigoZT0+ZS5waWVjZVswXT09PXJbMF0pKS5sZW5ndGg+MCkpe2NvbnN0IG49Wy4uLmFlLmN1cnJlbnRdO3JldHVybiBuLnB1c2goe3NvdXJjZVNxOmUsdGFyZ2V0U3E6dCxwaWVjZTpyfSksYWUuY3VycmVudD1uLHNlKFsuLi5uXSksdm9pZCBUZSgpfWlmKCFvJiZ2ZSlyZXR1cm47Y29uc3QgaT1PYmplY3QuYXNzaWduKHt9LFkpO2lmKGdlKCEhbiksSihyWzBdKSxSLmxlbmd0aCl7UihlLHQscil8fENlKCl9ZWxzZVwidHJhc2hcIiE9PUN8fHR8fGRlbGV0ZSBpW2VdLGRlbGV0ZSBpW2VdLGlbdF09cixLKGkpO1RlKCksSShpKX0saXNXYWl0aW5nRm9yQW5pbWF0aW9uOnZlLGxhc3RQaWVjZUNvbG91cjpRLG9uUmlnaHRDbGlja0Rvd246ZnVuY3Rpb24oZSl7dWUoZSl9LG9uUmlnaHRDbGlja1VwOmZ1bmN0aW9uKGUpe2lmKGNlKXtpZihjZT09PWUpcmV0dXJuIHVlKHZvaWQgMCksbCYmQ2UoITEpLHZvaWQgXyhlKX1lbHNlIHVlKHZvaWQgMCl9LHBvc2l0aW9uRGlmZmVyZW5jZXM6WCxwcm9tb3RlRnJvbVNxdWFyZTp0ZSxwcm9tb3RlVG9TcXVhcmU6bmUscHJlbW92ZXM6aWUsc2V0UHJvbW90ZUZyb21TcXVhcmU6cmUsc2V0UHJvbW90ZVRvU3F1YXJlOm9lLHNldFNob3dQcm9tb3RlRGlhbG9nOmVlLHNob3dQcm9tb3RlRGlhbG9nOlosYXV0b1Byb21vdGVUb1F1ZWVuOiQsY3VycmVudFJpZ2h0Q2xpY2tEb3duOmNlfTtyZXR1cm4gZShKdC5Qcm92aWRlcixPYmplY3QuYXNzaWduKHt2YWx1ZTpFZX0se2NoaWxkcmVuOnV9KSl9KSk7ZnVuY3Rpb24gdHIoe3JvdzpuLGNvbDpvfSl7Y29uc3R7Ym9hcmRPcmllbnRhdGlvbjppLGJvYXJkV2lkdGg6cyxjdXN0b21EYXJrU3F1YXJlU3R5bGU6YSxjdXN0b21MaWdodFNxdWFyZVN0eWxlOmN9PVp0KCksdT1jLmJhY2tncm91bmRDb2xvcixsPWEuYmFja2dyb3VuZENvbG9yLGQ9MD09PW8saD03PT09bjtmdW5jdGlvbiBnKCl7cmV0dXJuXCJ3aGl0ZVwiPT09aT84LW46bisxfWZ1bmN0aW9uIGYoKXtyZXR1cm5cImJsYWNrXCI9PT1pP0h0Wzctb106SHRbb119cmV0dXJuIGQmJmg/dChyLHtjaGlsZHJlbjpbZShcImRpdlwiLE9iamVjdC5hc3NpZ24oe3N0eWxlOk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7ekluZGV4OjMscG9zaXRpb246XCJhYnNvbHV0ZVwifSx7Y29sb3I6dX0pLG5yKHMpKX0se2NoaWxkcmVuOmcoKX0pKSxlKFwiZGl2XCIsT2JqZWN0LmFzc2lnbih7c3R5bGU6T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt6SW5kZXg6Myxwb3NpdGlvbjpcImFic29sdXRlXCJ9LHtjb2xvcjp1fSkscnIocykpfSx7Y2hpbGRyZW46ZigpfSkpXX0pOmg/ZShcImRpdlwiLE9iamVjdC5hc3NpZ24oe3N0eWxlOk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7ekluZGV4OjMscG9zaXRpb246XCJhYnNvbHV0ZVwifSx7Y29sb3I6byUyIT0wP2w6dX0pLHJyKHMpKX0se2NoaWxkcmVuOmYoKX0pKTpkP2UoXCJkaXZcIixPYmplY3QuYXNzaWduKHtzdHlsZTpPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe3pJbmRleDozLHBvc2l0aW9uOlwiYWJzb2x1dGVcIn0se2NvbG9yOm4lMj09MD9sOnV9KSxucihzKSl9LHtjaGlsZHJlbjpnKCl9KSk6bnVsbH1jb25zdCBycj1lPT4oe2FsaWduU2VsZjpcImZsZXgtZW5kXCIscGFkZGluZ0xlZnQ6ZS84LWUvNDgsZm9udFNpemU6ZS80OH0pLG5yPWU9Pih7YWxpZ25TZWxmOlwiZmxleC1zdGFydFwiLHBhZGRpbmdSaWdodDplLzgtZS80OCxmb250U2l6ZTplLzQ4fSk7ZnVuY3Rpb24gb3Ioe2lzUHJlbW92ZWRQaWVjZTp0PSExLHBpZWNlOnIsc3F1YXJlOm4sc3F1YXJlczpvfSl7Y29uc3R7YW5pbWF0aW9uRHVyYXRpb246cyxhcmVQaWVjZXNEcmFnZ2FibGU6YyxhcmVQcmVtb3Zlc0FsbG93ZWQ6dSxib2FyZFdpZHRoOmwsY2hlc3NQaWVjZXM6ZCxjdXJyZW50UG9zaXRpb246aCxpZDpnLGlzRHJhZ2dhYmxlUGllY2U6Zixpc1dhaXRpbmdGb3JBbmltYXRpb246cCxvblBpZWNlQ2xpY2s6dixvblBpZWNlRHJhZ0JlZ2luOm0sb25QaWVjZURyYWdFbmQ6eSxwb3NpdGlvbkRpZmZlcmVuY2VzOmIscHJlbW92ZXM6T309WnQoKSxbdyxTXT1hKHtvcGFjaXR5OjEsekluZGV4OjUsdG91Y2hBY3Rpb246XCJub25lXCIsY3Vyc29yOmMmJmYoe3BpZWNlOnIsc291cmNlU3F1YXJlOm59KT9cIi13ZWJraXQtZ3JhYlwiOlwiZGVmYXVsdFwifSksW3tjYW5EcmFnOkQsaXNEcmFnZ2luZzpDfSxULEVdPXR0KCgoKT0+KHt0eXBlOlwicGllY2VcIixpdGVtOigpPT4obShyLG4pLHtwaWVjZTpyLHNxdWFyZTpuLGlkOmd9KSxlbmQ6KCk9PnkocixuKSxjb2xsZWN0OmU9Pih7Y2FuRHJhZzpmKHtwaWVjZTpyLHNvdXJjZVNxdWFyZTpufSksaXNEcmFnZ2luZzohIWUuaXNEcmFnZ2luZygpfSl9KSksW3IsbixoLGddKTtyZXR1cm4gRSgoQ3R8fChDdD1uZXcgSW1hZ2UsQ3Quc3JjPVwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBQUFBQ0g1QkFFS0FBRUFMQUFBQUFBQkFBRUFBQUlDVEFFQU93PT1cIiksQ3QpLHtjYXB0dXJlRHJhZ2dpbmdTdGF0ZTohMH0pLGkoKCgpPT57UygoZT0+T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvcGFjaXR5OkM/MDoxfSkpKX0pLFtDXSksaSgoKCk9PntpZighdSlyZXR1cm47bGV0IGU9ITE7IXQmJk8uZmluZCgoZT0+ZS50YXJnZXRTcT09PW4pKSYmKGU9ITApLE8uZmluZCgoZT0+ZS5zb3VyY2VTcT09PW4mJmUucGllY2U9PT1yKSkmJihlPSEwKSxTKCh0PT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse2Rpc3BsYXk6ZT9cIm5vbmVcIjpcInVuc2V0XCJ9KSkpfSksW2gsT10pLGkoKCgpPT57dmFyIGU7Y29uc3Qgcj1udWxsPT09KGU9Yi5yZW1vdmVkKXx8dm9pZCAwPT09ZT92b2lkIDA6ZVtuXTtpZighYi5hZGRlZClyZXR1cm47Y29uc3QgaT1PYmplY3QuZW50cmllcyhiLmFkZGVkKS5maW5kKCgoW2UsdF0pPT50PT09cnx8XCJQXCI9PT0obnVsbD09cj92b2lkIDA6clsxXSkmJihcIjFcIj09PWVbMV18fFwiOFwiPT09ZVsxXSkpKTtpZihwJiZyJiZpJiYhdCl7Y29uc3R7c291cmNlU3E6ZSx0YXJnZXRTcTp0fT0oYT1uLGM9aVswXSx7c291cmNlU3E6b1thXSx0YXJnZXRTcTpvW2NdfSk7ZSYmdCYmUygocj0+T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHt0cmFuc2Zvcm06YHRyYW5zbGF0ZSgke3QueC1lLnh9cHgsICR7dC55LWUueX1weClgLHRyYW5zaXRpb246YHRyYW5zZm9ybSAke3N9bXNgLHpJbmRleDo2fSkpKX12YXIgYSxjfSksW2JdKSxpKCgoKT0+e2NvbnN0e3NvdXJjZVNxOmV9PXtzb3VyY2VTcTpvW25dfTtlJiZTKChlPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse3RyYW5zZm9ybTpcInRyYW5zbGF0ZSgwcHgsIDBweClcIix0cmFuc2l0aW9uOlwidHJhbnNmb3JtIDBtc1wifSkpKX0pLFtoXSksaSgoKCk9PntTKChlPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse2N1cnNvcjpjJiZmKHtwaWVjZTpyLHNvdXJjZVNxdWFyZTpufSk/XCItd2Via2l0LWdyYWJcIjpcImRlZmF1bHRcIn0pKSl9KSxbbixoLGNdKSxlKFwiZGl2XCIsT2JqZWN0LmFzc2lnbih7cmVmOmMmJkQ/VDpudWxsLG9uQ2xpY2s6KCk9PnYociksXCJkYXRhLXBpZWNlXCI6cixzdHlsZTp3fSx7Y2hpbGRyZW46XCJmdW5jdGlvblwiPT10eXBlb2YgZFtyXT9kW3JdKHtzcXVhcmVXaWR0aDpsLzgsaXNEcmFnZ2luZzpDfSk6ZShcInN2Z1wiLE9iamVjdC5hc3NpZ24oe3ZpZXdCb3g6XCIxIDEgNDMgNDNcIix3aWR0aDpsLzgsaGVpZ2h0OmwvOH0se2NoaWxkcmVuOmUoXCJnXCIse2NoaWxkcmVuOmRbcl19KX0pKX0pKX1mdW5jdGlvbiBpcih7c3F1YXJlOnQsc3F1YXJlQ29sb3I6cixzZXRTcXVhcmVzOm4sc3F1YXJlSGFzUHJlbW92ZTpvLGNoaWxkcmVuOnN9KXtjb25zdCBhPWYobnVsbCkse2JvYXJkV2lkdGg6Yyxib2FyZE9yaWVudGF0aW9uOnUsY2xlYXJBcnJvd3M6bCxjdXJyZW50UG9zaXRpb246ZCxjdXN0b21Cb2FyZFN0eWxlOmgsY3VzdG9tRGFya1NxdWFyZVN0eWxlOmcsY3VzdG9tRHJvcFNxdWFyZVN0eWxlOnAsY3VzdG9tTGlnaHRTcXVhcmVTdHlsZTp2LGN1c3RvbVByZW1vdmVEYXJrU3F1YXJlU3R5bGU6bSxjdXN0b21QcmVtb3ZlTGlnaHRTcXVhcmVTdHlsZTp5LGN1c3RvbVNxdWFyZTpiLGN1c3RvbVNxdWFyZVN0eWxlczpPLGhhbmRsZVNldFBvc2l0aW9uOncsaXNXYWl0aW5nRm9yQW5pbWF0aW9uOlMsbGFzdFBpZWNlQ29sb3VyOkQsb25EcmFnT3ZlclNxdWFyZTpDLG9uTW91c2VPdXRTcXVhcmU6VCxvbk1vdXNlT3ZlclNxdWFyZTpFLG9uUGllY2VEcm9wOkksb25SaWdodENsaWNrRG93bjprLG9uUmlnaHRDbGlja1VwOkwsb25TcXVhcmVDbGljazpQLHNldFByb21vdGVGcm9tU3F1YXJlOngsc2V0UHJvbW90ZVRvU3F1YXJlOk0sc2V0U2hvd1Byb21vdGVEaWFsb2c6TixhdXRvUHJvbW90ZVRvUXVlZW46aixjdXJyZW50UmlnaHRDbGlja0Rvd246UixkcmF3TmV3QXJyb3c6QSxvbkFycm93RHJhd0VuZDpxfT1adCgpLFt7aXNPdmVyOl99LHpdPWl0KCgoKT0+KHthY2NlcHQ6XCJwaWVjZVwiLGRyb3A6SCxjb2xsZWN0OmU9Pih7aXNPdmVyOiEhZS5pc092ZXIoKX0pfSkpLFt0LGQsSSxTLERdKTtmdW5jdGlvbiBIKGUpe01hdGguYWJzKGUuc3F1YXJlWzBdLmNoYXJDb2RlQXQoMCktdFswXS5jaGFyQ29kZUF0KDApKTw9MSYmKFwid1BcIj09PWUucGllY2UmJlwiOFwiPT09dFsxXXx8XCJiUFwiPT09ZS5waWVjZSYmXCIxXCI9PT10WzFdKT9qP3coZS5zcXVhcmUsdCxcIjhcIj09PXRbMV0/XCJ3UVwiOlwiYlFcIik6KHgoZS5zcXVhcmUpLE0odCksTighMCkpOncoZS5zcXVhcmUsdCxlLnBpZWNlLCEwKX1pKCgoKT0+e2lmKGEuY3VycmVudCl7Y29uc3R7eDplLHk6cn09YS5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO24oKG49Pk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7W3RdOnt4OmUseTpyfX0pKSl9fSksW2MsdV0pO2NvbnN0IEI9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxjcih0LHUsaCkpLFwiYmxhY2tcIj09PXI/Zzp2KSxvJiYoXCJibGFja1wiPT09cj9tOnkpKSxfJiZwKTtyZXR1cm4gZShcImRpdlwiLE9iamVjdC5hc3NpZ24oe3JlZjp6LHN0eWxlOkIsXCJkYXRhLXNxdWFyZS1jb2xvclwiOnIsXCJkYXRhLXNxdWFyZVwiOnQsb25Nb3VzZU92ZXI6ZT0+ezI9PT1lLmJ1dHRvbnMmJlImJkEoUix0KSxlLnJlbGF0ZWRUYXJnZXQmJmUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpfHxFKHQpfSxvbk1vdXNlT3V0OmU9PntlLnJlbGF0ZWRUYXJnZXQmJmUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpfHxUKHQpfSxvbk1vdXNlRG93bjplPT57Mj09PWUuYnV0dG9uJiZrKHQpfSxvbk1vdXNlVXA6ZT0+ezI9PT1lLmJ1dHRvbiYmKFImJnEoUix0KSxMKHQpKX0sb25EcmFnRW50ZXI6KCk9PkModCksb25DbGljazooKT0+e1AodCksbCgpfSxvbkNvbnRleHRNZW51OmU9PntlLnByZXZlbnREZWZhdWx0KCl9fSx7Y2hpbGRyZW46ZShiLFwic3RyaW5nXCI9PXR5cGVvZiBiP09iamVjdC5hc3NpZ24oe3JlZjphLHN0eWxlOk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGFyKGMpKSxzciksIW8mJihudWxsPT1PP3ZvaWQgMDpPW3RdKSl9LHtjaGlsZHJlbjpzfSk6T2JqZWN0LmFzc2lnbih7cmVmOmEsc3F1YXJlOnQsc3F1YXJlQ29sb3I6cixzdHlsZTpPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhcihjKSksc3IpLCFvJiYobnVsbD09Tz92b2lkIDA6T1t0XSkpfSx7Y2hpbGRyZW46c30pKX0pKX1jb25zdCBzcj17ZGlzcGxheTpcImZsZXhcIixqdXN0aWZ5Q29udGVudDpcImNlbnRlclwifSxhcj1lPT4oe3dpZHRoOmUvOCxoZWlnaHQ6ZS84fSksY3I9KGUsdCxyKT0+KG51bGw9PXI/dm9pZCAwOnIuYm9yZGVyUmFkaXVzKT9cImExXCI9PT1lP1wid2hpdGVcIj09PXQ/e2JvcmRlckJvdHRvbUxlZnRSYWRpdXM6ci5ib3JkZXJSYWRpdXN9Ontib3JkZXJUb3BSaWdodFJhZGl1czpyLmJvcmRlclJhZGl1c306XCJhOFwiPT09ZT9cIndoaXRlXCI9PT10P3tib3JkZXJUb3BMZWZ0UmFkaXVzOnIuYm9yZGVyUmFkaXVzfTp7Ym9yZGVyQm90dG9tUmlnaHRSYWRpdXM6ci5ib3JkZXJSYWRpdXN9OlwiaDFcIj09PWU/XCJ3aGl0ZVwiPT09dD97Ym9yZGVyQm90dG9tUmlnaHRSYWRpdXM6ci5ib3JkZXJSYWRpdXN9Ontib3JkZXJUb3BMZWZ0UmFkaXVzOnIuYm9yZGVyUmFkaXVzfTpcImg4XCI9PT1lP1wid2hpdGVcIj09PXQ/e2JvcmRlclRvcFJpZ2h0UmFkaXVzOnIuYm9yZGVyUmFkaXVzfTp7Ym9yZGVyQm90dG9tTGVmdFJhZGl1czpyLmJvcmRlclJhZGl1c306e306e307ZnVuY3Rpb24gdXIoKXtjb25zdFtyLG5dPWEoe30pLHtib2FyZE9yaWVudGF0aW9uOm8sYm9hcmRXaWR0aDppLGN1cnJlbnRQb3NpdGlvbjpzLGN1c3RvbUJvYXJkU3R5bGU6YyxpZDp1LHByZW1vdmVzOmwsc2hvd0JvYXJkTm90YXRpb246ZH09WnQoKTtyZXR1cm4gZShcImRpdlwiLE9iamVjdC5hc3NpZ24oe1wiZGF0YS1ib2FyZGlkXCI6dSxzdHlsZTpPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbHIoaSkpLGMpfSx7Y2hpbGRyZW46Wy4uLkFycmF5KDgpXS5tYXAoKChhLGMpPT5lKFwiZGl2XCIsT2JqZWN0LmFzc2lnbih7c3R5bGU6e2Rpc3BsYXk6XCJmbGV4XCIsZmxleFdyYXA6XCJub3dyYXBcIix3aWR0aDppfX0se2NoaWxkcmVuOlsuLi5BcnJheSg4KV0ubWFwKCgoaSxhKT0+e2NvbnN0IHU9XCJibGFja1wiPT09bz9IdFs3LWFdKyhjKzEpOkh0W2FdKyg4LWMpLGg9YSUyPT1jJTI/XCJ3aGl0ZVwiOlwiYmxhY2tcIixnPWwuZmluZCgoZT0+ZS5zb3VyY2VTcT09PXV8fGUudGFyZ2V0U3E9PT11KSksZj1sLmZpbmQoKGU9PmUudGFyZ2V0U3E9PT11KSk7cmV0dXJuIHQoaXIsT2JqZWN0LmFzc2lnbih7c3F1YXJlOnUsc3F1YXJlQ29sb3I6aCxzZXRTcXVhcmVzOm4sc3F1YXJlSGFzUHJlbW92ZTohIWd9LHtjaGlsZHJlbjpbc1t1XSYmZShvcix7cGllY2U6c1t1XSxzcXVhcmU6dSxzcXVhcmVzOnJ9KSxmJiZlKG9yLHtpc1ByZW1vdmVkUGllY2U6ITAscGllY2U6Zi5waWVjZSxzcXVhcmU6dSxzcXVhcmVzOnJ9KSxkJiZlKHRyLHtyb3c6Yyxjb2w6YX0pXX0pLGAke2F9JHtjfWApfSkpfSksYy50b1N0cmluZygpKSkpfSkpfWNvbnN0IGxyPWU9Pih7Y3Vyc29yOlwiZGVmYXVsdFwiLGhlaWdodDplLHdpZHRoOmV9KSxkcj0oKT0+e2NvbnN0e2Fycm93czpyLG5ld0Fycm93Om4sYm9hcmRPcmllbnRhdGlvbjpvLGJvYXJkV2lkdGg6aSxjdXN0b21BcnJvd0NvbG9yOnN9PVp0KCksYT1bLi4ucixuXS5maWx0ZXIoQm9vbGVhbik7cmV0dXJuIGUoXCJzdmdcIixPYmplY3QuYXNzaWduKHt3aWR0aDppLGhlaWdodDppLHN0eWxlOntwb3NpdGlvbjpcImFic29sdXRlXCIsdG9wOlwiMFwiLGxlZnQ6XCIwXCIscG9pbnRlckV2ZW50czpcIm5vbmVcIix6SW5kZXg6XCIxMFwifX0se2NoaWxkcmVuOmEubWFwKCgobixhKT0+e2NvbnN0IGM9WXQobyxpLG5bMF0pLHU9WXQobyxpLG5bMV0pO2xldCBsPWkvMzI7Y29uc3QgZD1hPT09ci5sZW5ndGg7ci5zb21lKChlPT5lWzBdIT09blswXSYmZVsxXT09PW5bMV0pKSYmIWQmJihsPWkvMTYpO2NvbnN0IGg9dS54LWMueCxnPXUueS1jLnksZj1NYXRoLmh5cG90KGcsaCkscD17eDpjLngraCooZi1sKS9mLHk6Yy55K2cqKGYtbCkvZn07cmV0dXJuIHQodix7Y2hpbGRyZW46W2UoXCJtYXJrZXJcIixPYmplY3QuYXNzaWduKHtpZDpcImFycm93aGVhZFwiLG1hcmtlcldpZHRoOlwiMlwiLG1hcmtlckhlaWdodDpcIjIuNVwiLHJlZlg6XCIxLjI1XCIscmVmWTpcIjEuMjVcIixvcmllbnQ6XCJhdXRvXCJ9LHtjaGlsZHJlbjplKFwicG9seWdvblwiLHtwb2ludHM6XCIwLjMgMCwgMiAxLjI1LCAwLjMgMi41XCIsZmlsbDpzfSl9KSksZShcImxpbmVcIix7eDE6Yy54LHkxOmMueSx4MjpwLngseTI6cC55LG9wYWNpdHk6ZD9cIjAuNVwiOlwiMC42NVwiLHN0cm9rZTpzLHN0cm9rZVdpZHRoOmQ/LjkqaS8zNjppLzM2LG1hcmtlckVuZDpcInVybCgjYXJyb3doZWFkKVwifSldfSxgJHtuWzBdfS0ke25bMV19JHtkP1wiYWN0aXZlXCI6XCJcIn1gKX0pKX0pKX07ZnVuY3Rpb24gaHIoe29wdGlvbjp0fSl7Y29uc3RbcixuXT1hKCExKSx7Ym9hcmRXaWR0aDpvLGNoZXNzUGllY2VzOmksY3VzdG9tRGFya1NxdWFyZVN0eWxlOnMsY3VzdG9tTGlnaHRTcXVhcmVTdHlsZTpjLGhhbmRsZVNldFBvc2l0aW9uOnUsb25Qcm9tb3Rpb25QaWVjZVNlbGVjdDpsLHByb21vdGVGcm9tU3F1YXJlOmQscHJvbW90ZVRvU3F1YXJlOmgscHJvbW90aW9uRGlhbG9nVmFyaWFudDpnfT1adCgpLGY9KCk9Pntzd2l0Y2godFsxXSl7Y2FzZVwiUVwiOnJldHVybiBzLmJhY2tncm91bmRDb2xvcjtjYXNlXCJSXCI6cmV0dXJuIGMuYmFja2dyb3VuZENvbG9yO2Nhc2VcIk5cIjpyZXR1cm5cImRlZmF1bHRcIj09PWc/Yy5iYWNrZ3JvdW5kQ29sb3I6cy5iYWNrZ3JvdW5kQ29sb3I7Y2FzZVwiQlwiOnJldHVyblwiZGVmYXVsdFwiPT09Zz9zLmJhY2tncm91bmRDb2xvcjpjLmJhY2tncm91bmRDb2xvcn19O3JldHVybiBlKFwiZGl2XCIsT2JqZWN0LmFzc2lnbih7b25DbGljazooKT0+eyhudWxsPT1sP3ZvaWQgMDpsLmxlbmd0aCk/bCh0KTp1KGQsaCx0KX0sb25Nb3VzZU92ZXI6KCk9Pm4oITApLG9uTW91c2VPdXQ6KCk9Pm4oITEpLFwiZGF0YS1waWVjZVwiOnQsc3R5bGU6e2N1cnNvcjpcInBvaW50ZXJcIixiYWNrZ3JvdW5kQ29sb3I6cj9mKCk6YCR7ZigpfWFhYCxib3JkZXJSYWRpdXM6XCI0cHhcIix0cmFuc2l0aW9uOlwiYWxsIDAuMXMgZWFzZS1vdXRcIn19LHtjaGlsZHJlbjpcImZ1bmN0aW9uXCI9PXR5cGVvZiBpW3RdP2UoXCJkaXZcIixPYmplY3QuYXNzaWduKHtzdHlsZTp7dHJhbnNpdGlvbjpcImFsbCAwLjFzIGVhc2Utb3V0XCIsdHJhbnNmb3JtOnI/XCJzY2FsZSgxKVwiOlwic2NhbGUoMC44NSlcIn19LHtjaGlsZHJlbjppW3RdKHtzcXVhcmVXaWR0aDpvLzgsaXNEcmFnZ2luZzohMX0pfSkpOmUoXCJzdmdcIixPYmplY3QuYXNzaWduKHt2aWV3Qm94OlwiMSAxIDQzIDQzXCIsd2lkdGg6by84LGhlaWdodDpvLzgsc3R5bGU6e3RyYW5zaXRpb246XCJhbGwgMC4xcyBlYXNlLW91dFwiLHRyYW5zZm9ybTpyP1wic2NhbGUoMSlcIjpcInNjYWxlKDAuODUpXCJ9fSx7Y2hpbGRyZW46ZShcImdcIix7Y2hpbGRyZW46aVt0XX0pfSkpfSkpfWZ1bmN0aW9uIGdyKCl7Y29uc3R7Ym9hcmRPcmllbnRhdGlvbjp0LGJvYXJkV2lkdGg6cixwcm9tb3Rpb25EaWFsb2dWYXJpYW50Om4scHJvbW90ZVRvU3F1YXJlOm99PVp0KCksaT1cIjFcIj09PShudWxsPT1vP3ZvaWQgMDpvWzFdKT9cImJcIjpcIndcIixzPVtgJHtudWxsIT1pP2k6XCJ3XCJ9UWAsYCR7bnVsbCE9aT9pOlwid1wifVJgLGAke251bGwhPWk/aTpcIndcIn1OYCxgJHtudWxsIT1pP2k6XCJ3XCJ9QmBdLGE9e2RlZmF1bHQ6e2Rpc3BsYXk6XCJncmlkXCIsZ3JpZFRlbXBsYXRlQ29sdW1uczpcIjFmciAxZnJcIix0cmFuc2Zvcm06YHRyYW5zbGF0ZSgkey1yLzh9cHgsICR7LXIvOH1weClgfSx2ZXJ0aWNhbDp7dHJhbnNmb3JtOmB0cmFuc2xhdGUoJHstci8xNn1weCwgJHstci8xNn1weClgfSxtb2RhbDp7ZGlzcGxheTpcImZsZXhcIixqdXN0aWZ5Q29udGVudDpcImNlbnRlclwiLGFsaWduSXRlbXM6XCJjZW50ZXJcIix0cmFuc2Zvcm06YHRyYW5zbGF0ZSgwcHgsICR7MypyLzh9cHgpYCx3aWR0aDpcIjEwMCVcIixoZWlnaHQ6ci80K1wicHhcIix0b3A6MCxiYWNrZ3JvdW5kQ29sb3I6XCJ3aGl0ZVwiLGxlZnQ6MH19LGM9WXQodCxyLG98fFwiYThcIik7cmV0dXJuIGUoXCJkaXZcIixPYmplY3QuYXNzaWduKHtzdHlsZTpPYmplY3QuYXNzaWduKHtwb3NpdGlvbjpcImFic29sdXRlXCIsdG9wOmAke251bGw9PWM/dm9pZCAwOmMueX1weGAsbGVmdDpgJHtudWxsPT1jP3ZvaWQgMDpjLnh9cHhgLHpJbmRleDoxZTN9LGFbbl0pLHRpdGxlOlwiQ2hvb3NlIHByb21vdGlvbiBwaWVjZVwifSx7Y2hpbGRyZW46cy5tYXAoKHQ9PmUoaHIse29wdGlvbjp0fSx0KSkpfSkpfWNvbnN0IGZyPXt3aGl0ZUtpbmc6ZShcInN2Z1wiLE9iamVjdC5hc3NpZ24oe3htbG5zOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIix2ZXJzaW9uOlwiMS4xXCIsc3R5bGU6e3NoYXBlUmVuZGVyaW5nOlwiZ2VvbWV0cmljUHJlY2lzaW9uXCIsdGV4dFJlbmRlcmluZzpcImdlb21ldHJpY1ByZWNpc2lvblwiLGltYWdlUmVuZGVyaW5nOlwiY3Jpc3AtZWRnZXNcIn0sdmlld0JveDpcIjAgMCA0MjEwIDEyOTcwXCIseDpcIjBweFwiLHk6XCIwcHhcIixmaWxsUnVsZTpcImV2ZW5vZGRcIixjbGlwUnVsZTpcImV2ZW5vZGRcIix3aWR0aDpcIjI1MFwiLGhlaWdodDpcIjI1MFwifSx7Y2hpbGRyZW46ZShcImdcIix7Y2hpbGRyZW46ZShcInBhdGhcIix7c3R5bGU6e2ZpbGw6XCJibGFja1wiLGZpbGxSdWxlOlwibm9uemVyb1wifSxkOlwiTTIxMDUgMGMxNjksMCAyODYsMTYwIDI0OSwzMTVsMjAwIDBjLTE3MiwyNjYgLTIzMSw0NzkgLTI1Niw3OTIgMzE1LC0yNCA1MzAsLTg2IDc5MiwtMjU1bDAgODk3Yy0yNjUsLTE3MSAtNDc5LC0yMzEgLTc5MiwtMjU2IDE4LDIzNCA3NSw0OTUgMTg1LDY4MmwzMzkgMGMyMzMsMCAzNjksMjY5IDIyNSw0NTZsNTQ1IDAgLTU5NSAxOTE2YzEzMCw5NCAxNTgsMjc1IDU5LDQwMiA0NjUsMCA0MTYsNTY4IDUxLDU2OGwtMzM0IDAgNDY1IDI4NjcgMzMyIDBjMjUwLDAgMzgxLDMwNiAxOTksNDg1IDE2Miw2MyAyNzMsMjIwIDI3MywzOTlsMCA2MzMgMTY4IDAgMCA0NzVjLTE0MDMsMCAtMjgwNywwIC00MjEwLDBsMCAtNDc1IDE2NyAwIDAgLTYzM2MwLC0xNzkgMTEyLC0zMzYgMjc0LC0zOTkgLTE4MSwtMTc4IC01MiwtNDg1IDE5OSwtNDg1bDMzMiAwIDQ2NSAtMjg2NyAtMzM1IDBjLTM1MywwIC00MTgsLTU2OCA1MSwtNTY4IC05OCwtMTI3IC03MCwtMzA4IDU5LC00MDJsLTU5NCAtMTkxNmMxODEsMCAzNjMsMCA1NDUsMCAtMTQ0LC0xODcgLTksLTQ1NiAyMjUsLTQ1NmwzMzkgMGMxMTAsLTE4NyAxNjcsLTQ0OCAxODUsLTY4MiAtMzE1LDI1IC01MzAsODcgLTc5MywyNTZsMCAtODk3YzI2NiwxNzEgNDgwLDIzMSA3OTMsMjU1IC0yNSwtMzE1IC04NywtNTI5IC0yNTYsLTc5MmwxOTkgMGMtMzYsLTE1NSA4MSwtMzE1IDI1MCwtMzE1em0tMTk5NCAxMDAxMmwwIDI1MyAzOTg4IDAgMCAtMjUzYy0xMzMwLDAgLTI2NTksMCAtMzk4OCwwem00ODQgLTEwNjBjLTE3NCwwIC0zMTYsMTQyIC0zMTYsMzE2bDAgNjMzIDM2NTIgMCAwIC02MzNjMCwtMTc0IC0xNDIsLTMxNiAtMzE2LC0zMTYgLTEwMDcsMCAtMjAxMywwIC0zMDIwLDB6bTQ1IC00NTdjLTIzMCwwIC0yMjUsMzQ1IDAsMzQ1bDI5MzAgMGMyMzAsMCAyMjUsLTM0NSAwLC0zNDUgLTk3NywwIC0xOTUzLDAgLTI5MzAsMHptMjAyMCAtMjk3OGwtMTExMSAwIC00NjUgMjg2NyAyMDQxIDAgLTQ2NSAtMjg2N3ptLTE1NTggLTQ1NmMtMjI5LDAgLTIyNCwzNDUgMCwzNDUgNjY5LDAgMTMzNywwIDIwMDUsMCAyMzAsMCAyMjUsLTM0NSAwLC0zNDUgLTY2OCwwIC0xMzM2LDAgLTIwMDUsMHptMTczMCAtNDU3bC0xNDU0IDBjLTIyOSwwIC0yMjQsMzQ1IDAsMzQ1bDE0NTQgMGMyMjksMCAyMjQsLTM0NSAwLC0zNDV6bS0yMDY0IC0xODYybDU0NCAxNzUxYzUyOSwwIDEwNTcsMCAxNTg2LDBsNTQ0IC0xNzUxYy04OTIsMCAtMTc4MywwIC0yNjc0LDB6bTEwODUgLTU2N2w1MDQgMGMtMTI2LC0yNDcgLTE2MywtNTI2IC0xNzcsLTgwMCAyNzMsMTUgNTUzLDUyIDgwMCwxNzdsMCAtNTA0Yy0yNDcsMTI2IC01MjcsMTYzIC04MDAsMTc3IDE0LC0yNzMgNTEsLTU1MiAxNzcsLTc5OSAtMTY4LDAgLTMzNiwwIC01MDQsMCAxMjUsMjQ3IDE2Miw1MjYgMTc3LDc5OSAtMjc0LC0xNCAtNTUzLC01MSAtODAwLC0xNzdsMCA1MDRjMjQ3LC0xMjUgNTI3LC0xNjIgODAwLC0xNzcgLTE1LDI3NCAtNTIsNTUzIC0xNzcsODAwem05NjkgMTExbC0xNDM0IDBjLTIzMCwwIC0yMjUsMzQ1IDAsMzQ1bDE0MzQgMGMyMzAsMCAyMjUsLTM0NSAwLC0zNDV6bS03MTcgLTIxNzVjLTEwNSwwIC0xNzUsMTA5IC0xMzMsMjA0bDI2NiAwYzQyLC05NiAtMzAsLTIwNSAtMTMzLC0yMDR6XCJ9KX0pfSkpfTtmdW5jdGlvbiBwcih7Y2hpbGRyZW46dH0pe3RyeXtyZXR1cm4gZShyLHtjaGlsZHJlbjp0fSl9Y2F0Y2godCl7cmV0dXJuIGNvbnNvbGUubG9nKHQpLGUodnIse3Nob3dFcnJvcjohMH0pfX1mdW5jdGlvbiB2cih7c2hvd0Vycm9yOnI9ITF9KXtyZXR1cm4gdChcImRpdlwiLE9iamVjdC5hc3NpZ24oe3N0eWxlOntkaXNwbGF5OlwiZmxleFwiLGp1c3RpZnlDb250ZW50OlwiY2VudGVyXCIsYWxpZ25JdGVtczpcImNlbnRlclwiLGZsZXhEaXJlY3Rpb246XCJjb2x1bW5cIn19LHtjaGlsZHJlbjpbZShcImRpdlwiLE9iamVjdC5hc3NpZ24oe3N0eWxlOnt3aWR0aDoyNTAsaGVpZ2h0OjI1MCx0cmFuc2Zvcm06XCJyb3RhdGUoOTBkZWcpXCJ9fSx7Y2hpbGRyZW46ZnIud2hpdGVLaW5nfSkpLHImJmUoXCJoMVwiLHtjaGlsZHJlbjpcIlNvbWV0aGluZyB3ZW50IHdyb25nXCJ9KV19KSl9ZnVuY3Rpb24gbXIoKXtjb25zdCBuPWYobnVsbCkse2JvYXJkV2lkdGg6byxjbGVhckN1cnJlbnRSaWdodENsaWNrRG93bjpzLG9uUHJvbW90aW9uUGllY2VTZWxlY3Q6YSxzZXRTaG93UHJvbW90ZURpYWxvZzpjLHNob3dQcm9tb3RlRGlhbG9nOnV9PVp0KCk7cmV0dXJuIGkoKCgpPT57ZnVuY3Rpb24gZShlKXtuLmN1cnJlbnQmJiFuLmN1cnJlbnQuY29udGFpbnMoZS50YXJnZXQpJiZzKCl9cmV0dXJuIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsZSksKCk9Pntkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLGUpfX0pLFtdKSxvP3QoXCJkaXZcIixPYmplY3QuYXNzaWduKHtyZWY6bixzdHlsZTp7cG9zaXRpb246XCJyZWxhdGl2ZVwifX0se2NoaWxkcmVuOltlKHVyLHt9KSxlKGRyLHt9KSx1JiZ0KHIse2NoaWxkcmVuOltlKFwiZGl2XCIse29uQ2xpY2s6KCk9PntjKCExKSxudWxsPT1hfHxhKCl9LHN0eWxlOntwb3NpdGlvbjpcImFic29sdXRlXCIsdG9wOlwiMFwiLGxlZnQ6XCIwXCIsekluZGV4OlwiMTAwXCIsYmFja2dyb3VuZENvbG9yOlwicmdiYSgyMiwyMSwxOCwuNylcIix3aWR0aDpvLGhlaWdodDpvfX0pLGUoZ3Ise30pXX0pXX0pKTplKHZyLHt9KX1mdW5jdGlvbiB5cigpe2NvbnN0e2JvYXJkV2lkdGg6dCxjaGVzc1BpZWNlczpyLGlkOm4sc25hcFRvQ3Vyc29yOm99PVp0KCkscz1mdW5jdGlvbihlKXtjb25zdCB0PUplKCkuZ2V0TW9uaXRvcigpLFtyLG5dPVJlKHQsZSk7cmV0dXJuIGkoKCgpPT50LnN1YnNjcmliZVRvT2Zmc2V0Q2hhbmdlKG4pKSksaSgoKCk9PnQuc3Vic2NyaWJlVG9TdGF0ZUNoYW5nZShuKSkpLHJ9KChlPT4oe2l0ZW06ZS5nZXRJdGVtKCksY2xpZW50T2Zmc2V0OmUuZ2V0Q2xpZW50T2Zmc2V0KCksc291cmNlQ2xpZW50T2Zmc2V0OmUuZ2V0U291cmNlQ2xpZW50T2Zmc2V0KCksaXNEcmFnZ2luZzplLmlzRHJhZ2dpbmcoKX0pKSkse2lzRHJhZ2dpbmc6YSxpdGVtOnUsY2xpZW50T2Zmc2V0Omwsc291cmNlQ2xpZW50T2Zmc2V0OmR9PXMsaD1jKCgoZSxyKT0+e2lmKCFlfHwhcilyZXR1cm57ZGlzcGxheTpcIm5vbmVcIn07bGV0e3g6bix5Oml9PW8/ZTpyO2lmKG8pe2NvbnN0IGU9dC84LzI7bi09ZSxpLT1lfWNvbnN0IHM9YHRyYW5zbGF0ZSgke259cHgsICR7aX1weClgO3JldHVybnt0cmFuc2Zvcm06cyxXZWJraXRUcmFuc2Zvcm06cyx0b3VjaEFjdGlvbjpcIm5vbmVcIn19KSxbdCxvXSk7cmV0dXJuIGEmJnUuaWQ9PT1uP2UoXCJkaXZcIixPYmplY3QuYXNzaWduKHtzdHlsZTp7cG9zaXRpb246XCJmaXhlZFwiLHBvaW50ZXJFdmVudHM6XCJub25lXCIsekluZGV4OjEwLGxlZnQ6MCx0b3A6MH19LHtjaGlsZHJlbjplKFwiZGl2XCIsT2JqZWN0LmFzc2lnbih7c3R5bGU6aChsLGQpfSx7Y2hpbGRyZW46XCJmdW5jdGlvblwiPT10eXBlb2Ygclt1LnBpZWNlXT9yW3UucGllY2VdKHtzcXVhcmVXaWR0aDp0LzgsaXNEcmFnZ2luZzohMH0pOmUoXCJzdmdcIixPYmplY3QuYXNzaWduKHt2aWV3Qm94OlwiMSAxIDQzIDQzXCIsd2lkdGg6dC84LGhlaWdodDp0Lzh9LHtjaGlsZHJlbjplKFwiZ1wiLHtjaGlsZHJlbjpyW3UucGllY2VdfSl9KSl9KSl9KSk6bnVsbH1jb25zdCBicj1nKCgocixuKT0+e2NvbnN0e2N1c3RvbURuZEJhY2tlbmQ6byxjdXN0b21EbmRCYWNrZW5kT3B0aW9uczpzfT1yLGM9ZnVuY3Rpb24oZSx0KXt2YXIgcj17fTtmb3IodmFyIG4gaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxuKSYmdC5pbmRleE9mKG4pPDAmJihyW25dPWVbbl0pO2lmKG51bGwhPWUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBvPTA7Zm9yKG49T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtvPG4ubGVuZ3RoO28rKyl0LmluZGV4T2YobltvXSk8MCYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsbltvXSkmJihyW25bb11dPWVbbltvXV0pfXJldHVybiByfShyLFtcImN1c3RvbURuZEJhY2tlbmRcIixcImN1c3RvbURuZEJhY2tlbmRPcHRpb25zXCJdKSxbdSxsXT1hKCksW2QsaF09YSghMSksW2cscF09YSghMSksW3YsbV09YShyLmJvYXJkV2lkdGgpLHk9ZihudWxsKTtpKCgoKT0+e3AoXCJvbnRvdWNoc3RhcnRcImluIHdpbmRvdyksaCghMCksbCh3aW5kb3cpfSksW10pLGkoKCgpPT57dmFyIGU7aWYodm9pZCAwPT09ci5ib2FyZFdpZHRoJiYobnVsbD09PShlPXkuY3VycmVudCl8fHZvaWQgMD09PWU/dm9pZCAwOmUub2Zmc2V0V2lkdGgpKXtjb25zdCBlPW5ldyBSZXNpemVPYnNlcnZlcigoKCk9Pnt2YXIgZTttKG51bGw9PT0oZT15LmN1cnJlbnQpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLm9mZnNldFdpZHRoKX0pKTtyZXR1cm4gZS5vYnNlcnZlKHkuY3VycmVudCksKCk9PntlLmRpc2Nvbm5lY3QoKX19fSksW3kuY3VycmVudCx1XSk7Y29uc3QgYj1vfHwoZz96dDprdCk7cmV0dXJuIGQmJnU/ZShwcix7Y2hpbGRyZW46dChcImRpdlwiLE9iamVjdC5hc3NpZ24oe3N0eWxlOntkaXNwbGF5OlwiZmxleFwiLGZsZXhEaXJlY3Rpb246XCJjb2x1bW5cIix3aWR0aDpcIjEwMCVcIn19LHtjaGlsZHJlbjpbZShcImRpdlwiLHtyZWY6eSxzdHlsZTp7d2lkdGg6XCIxMDAlXCJ9fSksZSh4ZSxPYmplY3QuYXNzaWduKHtiYWNrZW5kOmIsY29udGV4dDp1LG9wdGlvbnM6bz9zOnZvaWQgMH0se2NoaWxkcmVuOnYmJnQoZXIsT2JqZWN0LmFzc2lnbih7Ym9hcmRXaWR0aDp2fSxjLHtyZWY6bn0se2NoaWxkcmVuOltlKHlyLHt9KSxlKG1yLHt9KV19KSl9KSldfSkpfSk6bnVsbH0pKTtleHBvcnR7YnIgYXMgQ2hlc3Nib2FyZH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/react-chessboard/dist/index.esm.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=D%3A%5Cpersonal%20projects%5C7.%20chess%20chain%5Cchess-chain%5Cfrontend%5Csrc%5Ccomponents%5CChessBoard.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);